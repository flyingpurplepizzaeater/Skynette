---
phase: 13-autonomy-levels
plan: 04
type: execute
wave: 2
depends_on: ["13-01"]
files_modified:
  - src/agent/safety/allowlist.py
  - src/agent/safety/autonomy.py
  - src/agent/safety/__init__.py
autonomous: true

must_haves:
  truths:
    - "Users can define tool-based rules (always allow web_search)"
    - "Users can define path-based rules (always allow file writes to /src/*)"
    - "Blocklist rules override allowlist and autonomy level"
    - "Rules use glob patterns via fnmatch"
  artifacts:
    - path: "src/agent/safety/allowlist.py"
      provides: "AutonomyRule dataclass, matches_rules function"
      exports: ["AutonomyRule", "matches_rules"]
  key_links:
    - from: "src/agent/safety/autonomy.py"
      to: "src/agent/safety/allowlist.py"
      via: "imports matches_rules"
      pattern: "from.*allowlist import.*matches_rules"
---

<objective>
Implement allowlist and blocklist rule matching

Purpose: Allow users to override autonomy level decisions with explicit allow/block rules based on tool name or path patterns.

Output: `src/agent/safety/allowlist.py` with rule models and matching logic, integrated into AutonomySettings.check_rules().
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-autonomy-levels/13-CONTEXT.md
@.planning/phases/13-autonomy-levels/13-RESEARCH.md
@src/agent/safety/autonomy.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create allowlist rule models and matching logic</name>
  <files>src/agent/safety/allowlist.py</files>
  <action>
Create `src/agent/safety/allowlist.py`:

```python
"""
Allowlist and Blocklist Rules

Pattern-based rules for overriding autonomy level decisions.
"""

from dataclasses import dataclass
from fnmatch import fnmatch
from typing import Literal, Optional


@dataclass
class AutonomyRule:
    """
    Rule for overriding autonomy approval decisions.

    Attributes:
        rule_type: "allow" (skip approval) or "block" (require approval)
        scope: "tool" (matches tool name) or "path" (matches file path param)
        pattern: Glob pattern to match against (e.g., "web_search" or "/src/*")
        tool_name: For path rules, optionally limit to specific tool
    """

    rule_type: Literal["allow", "block"]
    scope: Literal["tool", "path"]
    pattern: str
    tool_name: Optional[str] = None

    def matches(self, tool: str, params: dict) -> bool:
        """
        Check if this rule matches the given tool call.

        Args:
            tool: Tool name being called
            params: Tool parameters

        Returns:
            True if rule matches, False otherwise
        """
        if self.scope == "tool":
            return fnmatch(tool, self.pattern)

        if self.scope == "path":
            # Tool restriction check
            if self.tool_name is not None and self.tool_name != tool:
                return False

            # Path pattern check
            path = params.get("path", "")
            if not path:
                return False
            return fnmatch(path, self.pattern)

        return False

    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        return {
            "rule_type": self.rule_type,
            "scope": self.scope,
            "pattern": self.pattern,
            "tool_name": self.tool_name,
        }

    @classmethod
    def from_dict(cls, data: dict) -> "AutonomyRule":
        """Create from dictionary (JSON deserialization)."""
        return cls(
            rule_type=data["rule_type"],
            scope=data["scope"],
            pattern=data["pattern"],
            tool_name=data.get("tool_name"),
        )


def matches_rules(
    tool_name: str,
    params: dict,
    allowlist: list[AutonomyRule],
    blocklist: list[AutonomyRule],
) -> Optional[bool]:
    """
    Check if action matches any allowlist or blocklist rules.

    Blocklist rules take priority over allowlist rules.

    Args:
        tool_name: Name of the tool being called
        params: Tool parameters
        allowlist: List of allow rules
        blocklist: List of block rules

    Returns:
        True if explicitly allowed (skip approval)
        False if explicitly blocked (require approval)
        None if no rule matches (use autonomy level threshold)
    """
    # Check blocklist first (higher priority)
    for rule in blocklist:
        if rule.matches(tool_name, params):
            return False  # Blocked = require approval

    # Check allowlist
    for rule in allowlist:
        if rule.matches(tool_name, params):
            return True  # Allowed = skip approval

    # No matching rule
    return None
```
  </action>
  <verify>Module imports: `python -c "from src.agent.safety.allowlist import AutonomyRule, matches_rules; r = AutonomyRule('allow', 'tool', 'web_*'); print(r.matches('web_search', {}))"`</verify>
  <done>AutonomyRule dataclass and matches_rules function are implemented</done>
</task>

<task type="auto">
  <name>Task 2: Integrate rules into AutonomySettings</name>
  <files>src/agent/safety/autonomy.py</files>
  <action>
Update `src/agent/safety/autonomy.py` to use allowlist module:

1. Add import at top:
```python
from src.agent.safety.allowlist import AutonomyRule, matches_rules
```

2. Update `AutonomySettings` dataclass to properly type rules and implement check_rules:
```python
@dataclass
class AutonomySettings:
    """Settings for a project's autonomy level."""

    level: AutonomyLevel = "L2"
    allowlist_rules: list = field(default_factory=list)
    blocklist_rules: list = field(default_factory=list)

    def auto_executes(self, risk_level: RiskLevel) -> bool:
        """
        Check if the given risk level auto-executes at current autonomy level.

        Args:
            risk_level: The risk level to check

        Returns:
            True if this risk level auto-executes, False if requires approval
        """
        auto_execute_levels = AUTONOMY_THRESHOLDS[self.level]
        return risk_level in auto_execute_levels

    def check_rules(self, tool_name: str, params: dict) -> bool | None:
        """
        Check if action matches any allowlist/blocklist rules.

        Args:
            tool_name: Name of the tool being called
            params: Tool parameters

        Returns:
            True if explicitly allowed (skip approval)
            False if explicitly blocked (require approval)
            None if no rule matches (use autonomy level)
        """
        # Convert dict rules to AutonomyRule objects if needed
        allowlist = [
            AutonomyRule.from_dict(r) if isinstance(r, dict) else r
            for r in self.allowlist_rules
        ]
        blocklist = [
            AutonomyRule.from_dict(r) if isinstance(r, dict) else r
            for r in self.blocklist_rules
        ]

        return matches_rules(tool_name, params, allowlist, blocklist)
```
  </action>
  <verify>Rules work: `python -c "
from src.agent.safety.autonomy import AutonomySettings
from src.agent.safety.allowlist import AutonomyRule

settings = AutonomySettings(
    level='L2',
    allowlist_rules=[AutonomyRule('allow', 'tool', 'web_*')],
    blocklist_rules=[AutonomyRule('block', 'path', '/critical/*', 'file_write')],
)

# web_search should be allowed
print(f'web_search: {settings.check_rules(\"web_search\", {})}')  # True

# file_write to /critical should be blocked
print(f'file_write critical: {settings.check_rules(\"file_write\", {\"path\": \"/critical/data.txt\"})}')  # False

# file_write elsewhere: no rule match
print(f'file_write normal: {settings.check_rules(\"file_write\", {\"path\": \"/src/main.py\"})}')  # None
"`</verify>
  <done>AutonomySettings.check_rules() uses allowlist/blocklist rules</done>
</task>

<task type="auto">
  <name>Task 3: Export allowlist types from safety module</name>
  <files>src/agent/safety/__init__.py</files>
  <action>
Update `src/agent/safety/__init__.py` to export allowlist types:

Add imports:
```python
from src.agent.safety.allowlist import (
    AutonomyRule,
    matches_rules,
)
```

Add to `__all__`:
- "AutonomyRule"
- "matches_rules"
  </action>
  <verify>Exports work: `python -c "from src.agent.safety import AutonomyRule, matches_rules; print('OK')"`</verify>
  <done>Allowlist types are exported from the safety module</done>
</task>

</tasks>

<verification>
- [ ] `AutonomyRule` supports "tool" and "path" scope
- [ ] Tool rules use glob patterns via fnmatch
- [ ] Path rules can be limited to specific tools
- [ ] Blocklist takes priority over allowlist
- [ ] Rules work with dict or AutonomyRule input (JSON serialization)
- [ ] `matches_rules()` returns True/False/None correctly
- [ ] All types exported from safety module
</verification>

<success_criteria>
1. Tool-based rules match tool names with glob patterns
2. Path-based rules match file paths in tool parameters
3. Blocklist rules always override allowlist
4. Rule serialization works (to_dict/from_dict)
5. AutonomySettings.check_rules() integrates seamlessly with classification
</success_criteria>

<output>
After completion, create `.planning/phases/13-autonomy-levels/13-04-SUMMARY.md`
</output>
