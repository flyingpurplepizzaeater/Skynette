---
phase: 13-autonomy-levels
plan: 06
type: execute
wave: 3
depends_on: ["13-03", "13-04"]
files_modified:
  - src/agent/loop/executor.py
  - src/agent/models/event.py
autonomous: true

must_haves:
  truths:
    - "Executor passes project_path to ActionClassifier.classify()"
    - "Mid-task level changes take effect immediately on remaining steps"
    - "Downgrade re-evaluates pending actions under new level"
    - "Auto-executed steps are marked (for UI 'auto' badge)"
  artifacts:
    - path: "src/agent/loop/executor.py"
      provides: "Autonomy-aware execution loop"
      contains: "project_path"
    - path: "src/agent/models/event.py"
      provides: "auto_executed flag in events"
      contains: "auto_executed"
  key_links:
    - from: "src/agent/loop/executor.py"
      to: "src/agent/safety/classification.py"
      via: "classify() with project_path"
      pattern: "classify.*project_path"
---

<objective>
Wire autonomy levels into the agent executor

Purpose: Ensure the executor uses project-specific autonomy levels when classifying actions and handles mid-task level changes correctly.

Output: `AgentExecutor` passes project_path to classify(), events include auto_executed flag, and level change callbacks trigger re-evaluation on downgrade.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-autonomy-levels/13-CONTEXT.md
@.planning/phases/13-autonomy-levels/13-RESEARCH.md
@src/agent/loop/executor.py
@src/agent/models/event.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add auto_executed flag to events</name>
  <files>src/agent/models/event.py</files>
  <action>
Update `src/agent/models/event.py` to include auto_executed information:

1. Update `action_classified` factory method to include `auto_executed` flag:

Find the `action_classified` static method and update its signature and data:
```python
@staticmethod
def action_classified(
    tool_name: str,
    risk_level: str,
    reason: str,
    requires_approval: bool,
    session_id: str,
    auto_executed: bool = False,
) -> "AgentEvent":
    """
    Create an action_classified event.

    Args:
        tool_name: Name of the tool
        risk_level: Risk classification (safe, moderate, destructive, critical)
        reason: Human-readable reason for classification
        requires_approval: Whether approval is required
        session_id: Session ID
        auto_executed: Whether this action will auto-execute (would have needed approval at lower level)

    Returns:
        AgentEvent for action classification
    """
    return AgentEvent(
        type="action_classified",
        data={
            "tool_name": tool_name,
            "risk_level": risk_level,
            "reason": reason,
            "requires_approval": requires_approval,
            "auto_executed": auto_executed,
        },
        session_id=session_id,
    )
```

2. Update `step_completed` factory method to include `auto_executed`:

```python
@staticmethod
def step_completed(
    step_id: str,
    result: dict,
    session_id: str,
    auto_executed: bool = False,
) -> "AgentEvent":
    """
    Create a step_completed event.

    Args:
        step_id: ID of the completed step
        result: Step result data
        session_id: Session ID
        auto_executed: Whether this step auto-executed (would have needed approval at lower level)

    Returns:
        AgentEvent for step completion
    """
    return AgentEvent(
        type="step_completed",
        data={
            "step_id": step_id,
            "result": result,
            "auto_executed": auto_executed,
        },
        session_id=session_id,
    )
```

Note: If these methods don't exist as static methods yet, update the inline AgentEvent creation in executor to include the auto_executed flag.
  </action>
  <verify>Event imports work: `python -c "from src.agent.models.event import AgentEvent; print('OK')"`</verify>
  <done>Events include auto_executed flag for UI badge display</done>
</task>

<task type="auto">
  <name>Task 2: Wire project_path into executor classification</name>
  <files>src/agent/loop/executor.py</files>
  <action>
Update `AgentExecutor` to use project-specific autonomy levels:

1. Add project_path to `__init__`:
```python
def __init__(self, session: AgentSession, project_path: str | None = None):
    # ... existing init ...
    self._project_path = project_path
```

2. Update `_execute_tool_with_safety()` to pass project_path to classify:

Find the line:
```python
classification = self.classifier.classify(tool_name, params)
```

Change to:
```python
classification = self.classifier.classify(tool_name, params, self._project_path)
```

3. Calculate `auto_executed` flag - an action auto-executed if:
   - It has a risk level that normally requires approval at lower autonomy levels
   - But current level allows it to auto-execute

Add after classification:
```python
# Determine if this action is "auto-executing" (would need approval at lower level)
# An action auto-executes at current level if:
# - It doesn't require approval at current level
# - But would require approval at a lower level (L1 requires all, so any non-approval is auto)
auto_executed = not classification.requires_approval and classification.risk_level != "safe"
```

4. Pass auto_executed to events:

Update the action_classified event emission:
```python
events.append(AgentEvent.action_classified(
    tool_name=tool_name,
    risk_level=classification.risk_level,
    reason=classification.reason,
    requires_approval=classification.requires_approval,
    session_id=self.session.id,
    auto_executed=auto_executed,  # Add this
))
```

5. Also track auto_executed at step level for the step_completed event later in `_execute_step`.
  </action>
  <verify>Executor imports work: `python -c "from src.agent.loop.executor import AgentExecutor; print('OK')"`</verify>
  <done>Executor passes project_path to classify and tracks auto_executed</done>
</task>

<task type="auto">
  <name>Task 3: Handle mid-task level changes on downgrade</name>
  <files>src/agent/loop/executor.py</files>
  <action>
Update `AgentExecutor` to handle autonomy level changes during execution:

1. Add import at top:
```python
from src.agent.safety.autonomy import get_autonomy_service
```

2. Add callback registration in `run()` method, inside the try block before `_run_with_safety`:

```python
async def run(self, task: str) -> AsyncIterator[AgentEvent]:
    """Execute a task, yielding events as execution progresses."""
    # Initialize safety systems for this execution
    self.kill_switch.reset()
    self.approval_manager.start_session(self.session.id)

    # Register for autonomy level changes
    autonomy_service = get_autonomy_service()
    autonomy_service.on_level_changed(self._on_autonomy_downgrade)

    try:
        async for event in self._run_with_safety(task):
            yield event
    finally:
        # Cleanup safety systems
        self.approval_manager.end_session()
        self.kill_switch.reset()
        # Note: Don't remove callback - service manages its own lifecycle
```

3. Add flag to track if downgrade occurred:
```python
# In __init__:
self._level_downgraded: bool = False
```

4. Add callback method:
```python
def _on_autonomy_downgrade(
    self,
    project_path: str,
    old_level: str,
    new_level: str,
    downgrade: bool,
) -> None:
    """
    Handle autonomy level downgrade during execution.

    On downgrade, set flag to re-evaluate pending actions.

    Args:
        project_path: Project that changed
        old_level: Previous level
        new_level: New level
        downgrade: Whether this is a downgrade (more restrictive)
    """
    if downgrade and project_path == self._project_path:
        self._level_downgraded = True
        logger.info(
            f"Autonomy downgrade: {old_level} -> {new_level}, "
            "remaining actions will be re-evaluated"
        )
```

5. In the main execution loop (in `_run_with_safety`), check the flag before executing each step:

After getting the next step and before `_execute_step`, add:
```python
# Check if autonomy was downgraded mid-task
if self._level_downgraded:
    self._level_downgraded = False
    # Re-evaluation happens automatically because classify() is called
    # fresh for each step with current autonomy settings
    logger.debug("Re-evaluating step under new autonomy level")
```

The key insight: because `classify()` is called fresh for each step and reads current autonomy settings, mid-task level changes automatically take effect. The callback/flag is primarily for logging and potential future use (e.g., pausing for user confirmation on downgrade).
  </action>
  <verify>Executor handles downgrade: `python -c "from src.agent.loop.executor import AgentExecutor; print('OK')"`</verify>
  <done>Executor handles mid-task autonomy level changes with re-evaluation on downgrade</done>
</task>

</tasks>

<verification>
- [ ] `AgentExecutor.__init__` accepts optional project_path
- [ ] `classify()` is called with project_path
- [ ] `auto_executed` flag calculated correctly (non-safe that doesn't require approval)
- [ ] Events include auto_executed in data
- [ ] Level change callback registered during execution
- [ ] Downgrade flag triggers re-evaluation message
- [ ] Mid-task level changes take effect on next step
</verification>

<success_criteria>
1. Executor uses project-specific autonomy level for classification
2. auto_executed flag correctly identifies actions that auto-execute at current level
3. Level changes during execution are detected via callback
4. Downgrade causes remaining steps to be classified under new (stricter) level
5. No blocking or performance impact from level change detection
</success_criteria>

<output>
After completion, create `.planning/phases/13-autonomy-levels/13-06-SUMMARY.md`
</output>
