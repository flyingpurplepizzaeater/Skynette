---
phase: 13-autonomy-levels
plan: 07
type: execute
wave: 4
depends_on: ["13-01", "13-02", "13-03", "13-04", "13-05", "13-06"]
files_modified:
  - tests/agent/safety/test_autonomy.py
  - tests/agent/safety/test_allowlist.py
  - tests/agent/ui/test_autonomy_ui.py
autonomous: true

must_haves:
  truths:
    - "Unit tests verify all four autonomy levels behave correctly"
    - "Unit tests verify allowlist/blocklist rule matching"
    - "Unit tests verify storage persistence"
    - "All tests pass"
  artifacts:
    - path: "tests/agent/safety/test_autonomy.py"
      provides: "Autonomy level and service tests"
      min_lines: 100
    - path: "tests/agent/safety/test_allowlist.py"
      provides: "Rule matching tests"
      min_lines: 80
  key_links:
    - from: "tests/agent/safety/test_autonomy.py"
      to: "src/agent/safety/autonomy.py"
      via: "imports"
      pattern: "from src.agent.safety.autonomy import"
---

<objective>
Create comprehensive unit tests for autonomy level system

Purpose: Verify all autonomy level functionality works correctly, including level thresholds, rule matching, storage persistence, and UI components.

Output: Test files in `tests/agent/safety/` covering all autonomy functionality.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-autonomy-levels/13-CONTEXT.md
@.planning/phases/13-autonomy-levels/13-RESEARCH.md
@src/agent/safety/autonomy.py
@src/agent/safety/allowlist.py
@src/agent/safety/classification.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create autonomy level and service tests</name>
  <files>tests/agent/safety/test_autonomy.py</files>
  <action>
Create `tests/agent/safety/test_autonomy.py`:

```python
"""
Tests for Autonomy Level System

Covers: AutonomyLevel, AUTONOMY_THRESHOLDS, AutonomySettings, AutonomyLevelService
"""

import gc
import tempfile
from pathlib import Path

import pytest

from src.agent.safety.autonomy import (
    AutonomyLevel,
    AutonomySettings,
    AutonomyLevelService,
    AUTONOMY_COLORS,
    AUTONOMY_LABELS,
    AUTONOMY_THRESHOLDS,
    get_autonomy_service,
)
from src.data.storage import WorkflowStorage


class TestAutonomyThresholds:
    """Test autonomy level threshold mappings."""

    def test_l1_no_auto_execute(self):
        """L1 (Assistant) should auto-execute nothing."""
        assert AUTONOMY_THRESHOLDS["L1"] == set()

    def test_l2_safe_only(self):
        """L2 (Collaborator) should auto-execute only safe actions."""
        assert AUTONOMY_THRESHOLDS["L2"] == {"safe"}

    def test_l3_safe_and_moderate(self):
        """L3 (Trusted) should auto-execute safe and moderate actions."""
        assert AUTONOMY_THRESHOLDS["L3"] == {"safe", "moderate"}

    def test_l4_not_critical(self):
        """L4 (Expert) should auto-execute everything except critical."""
        assert AUTONOMY_THRESHOLDS["L4"] == {"safe", "moderate", "destructive"}

    def test_all_levels_have_labels(self):
        """All levels should have human-readable labels."""
        for level in ["L1", "L2", "L3", "L4"]:
            assert level in AUTONOMY_LABELS
            assert len(AUTONOMY_LABELS[level]) > 0

    def test_all_levels_have_colors(self):
        """All levels should have color codes."""
        for level in ["L1", "L2", "L3", "L4"]:
            assert level in AUTONOMY_COLORS
            assert AUTONOMY_COLORS[level].startswith("#")


class TestAutonomySettings:
    """Test AutonomySettings dataclass."""

    def test_default_level_is_l2(self):
        """Default autonomy level should be L2 (Collaborator)."""
        settings = AutonomySettings()
        assert settings.level == "L2"

    def test_auto_executes_l1(self):
        """L1 should not auto-execute any risk level."""
        settings = AutonomySettings(level="L1")
        assert not settings.auto_executes("safe")
        assert not settings.auto_executes("moderate")
        assert not settings.auto_executes("destructive")
        assert not settings.auto_executes("critical")

    def test_auto_executes_l2(self):
        """L2 should only auto-execute safe."""
        settings = AutonomySettings(level="L2")
        assert settings.auto_executes("safe")
        assert not settings.auto_executes("moderate")
        assert not settings.auto_executes("destructive")
        assert not settings.auto_executes("critical")

    def test_auto_executes_l3(self):
        """L3 should auto-execute safe and moderate."""
        settings = AutonomySettings(level="L3")
        assert settings.auto_executes("safe")
        assert settings.auto_executes("moderate")
        assert not settings.auto_executes("destructive")
        assert not settings.auto_executes("critical")

    def test_auto_executes_l4(self):
        """L4 should auto-execute everything except critical."""
        settings = AutonomySettings(level="L4")
        assert settings.auto_executes("safe")
        assert settings.auto_executes("moderate")
        assert settings.auto_executes("destructive")
        assert not settings.auto_executes("critical")

    def test_check_rules_returns_none_when_empty(self):
        """check_rules should return None when no rules defined."""
        settings = AutonomySettings()
        assert settings.check_rules("any_tool", {}) is None


class TestAutonomyLevelService:
    """Test AutonomyLevelService."""

    @pytest.fixture
    def temp_storage(self):
        """Create temporary storage for testing."""
        temp_dir = tempfile.mkdtemp()
        storage = WorkflowStorage(temp_dir)
        yield storage
        # Cleanup
        gc.collect()  # Windows SQLite cleanup per 09-06

    @pytest.fixture
    def service(self):
        """Create fresh service instance."""
        return AutonomyLevelService()

    def test_get_settings_default(self, service):
        """get_settings with None should return default L2."""
        settings = service.get_settings(None)
        assert settings.level == "L2"

    def test_set_and_get_level(self, service, temp_storage):
        """set_level should update level and persist."""
        project = str(Path(tempfile.mkdtemp()).resolve())
        service.set_level(project, "L3")

        # Should be in cache
        assert service._current_levels.get(project) == "L3"

    def test_is_downgrade(self, service):
        """_is_downgrade should correctly identify downgrades."""
        # L4 -> L1 is downgrade
        assert service._is_downgrade("L4", "L1")
        # L3 -> L2 is downgrade
        assert service._is_downgrade("L3", "L2")
        # L1 -> L4 is upgrade (not downgrade)
        assert not service._is_downgrade("L1", "L4")
        # Same level is not downgrade
        assert not service._is_downgrade("L2", "L2")

    def test_level_changed_callback(self, service):
        """Downgrade should trigger callback."""
        callback_data = []

        def callback(path, old, new, downgrade):
            callback_data.append((path, old, new, downgrade))

        service.on_level_changed(callback)
        project = str(Path(tempfile.mkdtemp()).resolve())

        # Set initial level
        service._current_levels[project] = "L4"

        # Downgrade to L2
        service.set_level(project, "L2")

        assert len(callback_data) == 1
        assert callback_data[0][0] == project
        assert callback_data[0][1] == "L4"
        assert callback_data[0][2] == "L2"
        assert callback_data[0][3] is True  # downgrade=True


class TestGlobalService:
    """Test global service singleton."""

    def test_singleton(self):
        """get_autonomy_service should return same instance."""
        svc1 = get_autonomy_service()
        svc2 = get_autonomy_service()
        assert svc1 is svc2
```
  </action>
  <verify>Tests pass: `python -m pytest tests/agent/safety/test_autonomy.py -v`</verify>
  <done>Autonomy level and service unit tests are created and passing</done>
</task>

<task type="auto">
  <name>Task 2: Create allowlist rule tests</name>
  <files>tests/agent/safety/test_allowlist.py</files>
  <action>
Create `tests/agent/safety/test_allowlist.py`:

```python
"""
Tests for Allowlist and Blocklist Rules

Covers: AutonomyRule, matches_rules
"""

import pytest

from src.agent.safety.allowlist import AutonomyRule, matches_rules


class TestAutonomyRule:
    """Test AutonomyRule dataclass."""

    def test_tool_rule_exact_match(self):
        """Tool rule should match exact tool name."""
        rule = AutonomyRule("allow", "tool", "web_search")
        assert rule.matches("web_search", {})
        assert not rule.matches("web_scrape", {})

    def test_tool_rule_glob_pattern(self):
        """Tool rule should support glob patterns."""
        rule = AutonomyRule("allow", "tool", "web_*")
        assert rule.matches("web_search", {})
        assert rule.matches("web_scrape", {})
        assert not rule.matches("file_read", {})

    def test_path_rule_exact_match(self):
        """Path rule should match exact path."""
        rule = AutonomyRule("block", "path", "/critical/data.txt")
        assert rule.matches("file_write", {"path": "/critical/data.txt"})
        assert not rule.matches("file_write", {"path": "/src/main.py"})

    def test_path_rule_glob_pattern(self):
        """Path rule should support glob patterns."""
        rule = AutonomyRule("allow", "path", "/src/*")
        assert rule.matches("file_write", {"path": "/src/main.py"})
        assert rule.matches("file_write", {"path": "/src/utils.py"})
        assert not rule.matches("file_write", {"path": "/critical/data.txt"})

    def test_path_rule_tool_restriction(self):
        """Path rule with tool_name should only match that tool."""
        rule = AutonomyRule("block", "path", "/critical/*", tool_name="file_delete")
        assert rule.matches("file_delete", {"path": "/critical/data.txt"})
        assert not rule.matches("file_write", {"path": "/critical/data.txt"})

    def test_path_rule_no_path_param(self):
        """Path rule should not match if no path in params."""
        rule = AutonomyRule("allow", "path", "/src/*")
        assert not rule.matches("file_write", {})
        assert not rule.matches("file_write", {"content": "hello"})

    def test_to_dict(self):
        """Rule should serialize to dict."""
        rule = AutonomyRule("allow", "tool", "web_*", tool_name=None)
        d = rule.to_dict()
        assert d["rule_type"] == "allow"
        assert d["scope"] == "tool"
        assert d["pattern"] == "web_*"
        assert d["tool_name"] is None

    def test_from_dict(self):
        """Rule should deserialize from dict."""
        d = {
            "rule_type": "block",
            "scope": "path",
            "pattern": "/critical/*",
            "tool_name": "file_delete",
        }
        rule = AutonomyRule.from_dict(d)
        assert rule.rule_type == "block"
        assert rule.scope == "path"
        assert rule.pattern == "/critical/*"
        assert rule.tool_name == "file_delete"


class TestMatchesRules:
    """Test matches_rules function."""

    def test_empty_rules_returns_none(self):
        """No rules should return None (use autonomy level)."""
        result = matches_rules("any_tool", {}, [], [])
        assert result is None

    def test_allowlist_match_returns_true(self):
        """Matching allowlist rule should return True."""
        allowlist = [AutonomyRule("allow", "tool", "web_search")]
        result = matches_rules("web_search", {}, allowlist, [])
        assert result is True

    def test_blocklist_match_returns_false(self):
        """Matching blocklist rule should return False."""
        blocklist = [AutonomyRule("block", "tool", "file_delete")]
        result = matches_rules("file_delete", {}, [], blocklist)
        assert result is False

    def test_blocklist_priority_over_allowlist(self):
        """Blocklist should take priority when both match."""
        allowlist = [AutonomyRule("allow", "tool", "file_*")]
        blocklist = [AutonomyRule("block", "tool", "file_delete")]
        # file_delete matches both, but blocklist wins
        result = matches_rules("file_delete", {}, allowlist, blocklist)
        assert result is False

    def test_no_match_returns_none(self):
        """Non-matching rules should return None."""
        allowlist = [AutonomyRule("allow", "tool", "web_*")]
        blocklist = [AutonomyRule("block", "tool", "file_delete")]
        # code_execute doesn't match either
        result = matches_rules("code_execute", {}, allowlist, blocklist)
        assert result is None

    def test_path_rules_with_params(self):
        """Path rules should use params for matching."""
        allowlist = [AutonomyRule("allow", "path", "/src/*")]
        blocklist = [AutonomyRule("block", "path", "/src/secret/*")]

        # /src/main.py matches allowlist
        result = matches_rules("file_write", {"path": "/src/main.py"}, allowlist, blocklist)
        assert result is True

        # /src/secret/key.txt matches blocklist (priority)
        result = matches_rules("file_write", {"path": "/src/secret/key.txt"}, allowlist, blocklist)
        assert result is False

        # /other/file.txt matches neither
        result = matches_rules("file_write", {"path": "/other/file.txt"}, allowlist, blocklist)
        assert result is None
```
  </action>
  <verify>Tests pass: `python -m pytest tests/agent/safety/test_allowlist.py -v`</verify>
  <done>Allowlist rule unit tests are created and passing</done>
</task>

<task type="auto">
  <name>Task 3: Create classification integration tests</name>
  <files>tests/agent/safety/test_autonomy.py</files>
  <action>
Add integration tests to `tests/agent/safety/test_autonomy.py`:

```python
class TestClassifierWithAutonomy:
    """Test ActionClassifier with autonomy levels."""

    @pytest.fixture
    def service(self):
        """Create fresh service instance."""
        return AutonomyLevelService()

    def test_l1_all_require_approval(self, service):
        """L1 should require approval for all actions."""
        from src.agent.safety.classification import ActionClassifier

        project = str(Path(tempfile.mkdtemp()).resolve())
        service._current_levels[project] = "L1"

        classifier = ActionClassifier(autonomy_service=service)

        # Even safe actions require approval at L1
        result = classifier.classify("web_search", {}, project)
        assert result.requires_approval is True

        result = classifier.classify("file_read", {}, project)
        assert result.requires_approval is True

    def test_l2_safe_auto_executes(self, service):
        """L2 should auto-execute only safe actions."""
        from src.agent.safety.classification import ActionClassifier

        project = str(Path(tempfile.mkdtemp()).resolve())
        service._current_levels[project] = "L2"

        classifier = ActionClassifier(autonomy_service=service)

        # Safe auto-executes
        result = classifier.classify("web_search", {}, project)
        assert result.requires_approval is False

        # Moderate requires approval
        result = classifier.classify("browser", {"url": "http://test.com"}, project)
        assert result.requires_approval is True

        # Destructive requires approval
        result = classifier.classify("file_write", {"path": "/tmp/x"}, project)
        assert result.requires_approval is True

    def test_l3_moderate_auto_executes(self, service):
        """L3 should auto-execute safe and moderate actions."""
        from src.agent.safety.classification import ActionClassifier

        project = str(Path(tempfile.mkdtemp()).resolve())
        service._current_levels[project] = "L3"

        classifier = ActionClassifier(autonomy_service=service)

        # Safe auto-executes
        result = classifier.classify("web_search", {}, project)
        assert result.requires_approval is False

        # Moderate auto-executes
        result = classifier.classify("browser", {"url": "http://test.com"}, project)
        assert result.requires_approval is False

        # Destructive requires approval
        result = classifier.classify("file_write", {"path": "/tmp/x"}, project)
        assert result.requires_approval is True

    def test_l4_destructive_auto_executes(self, service):
        """L4 should auto-execute all except critical."""
        from src.agent.safety.classification import ActionClassifier

        project = str(Path(tempfile.mkdtemp()).resolve())
        service._current_levels[project] = "L4"

        classifier = ActionClassifier(autonomy_service=service)

        # Safe auto-executes
        result = classifier.classify("web_search", {}, project)
        assert result.requires_approval is False

        # Moderate auto-executes
        result = classifier.classify("browser", {"url": "http://test.com"}, project)
        assert result.requires_approval is False

        # Destructive auto-executes
        result = classifier.classify("file_write", {"path": "/tmp/x"}, project)
        assert result.requires_approval is False

        # Critical still requires approval
        result = classifier.classify("file_delete", {"path": "/tmp/x"}, project)
        assert result.requires_approval is True

    def test_allowlist_overrides_level(self, service):
        """Allowlist rule should override autonomy level."""
        from src.agent.safety.classification import ActionClassifier
        from src.agent.safety.allowlist import AutonomyRule

        project = str(Path(tempfile.mkdtemp()).resolve())
        service._current_levels[project] = "L1"  # All require approval

        classifier = ActionClassifier(autonomy_service=service)

        # Without rule: requires approval
        result = classifier.classify("file_write", {"path": "/src/main.py"}, project)
        assert result.requires_approval is True

        # Add allowlist rule
        settings = service.get_settings(project)
        settings.allowlist_rules = [AutonomyRule("allow", "path", "/src/*")]

        # Mock get_settings to return our modified settings
        original_get = service.get_settings
        service.get_settings = lambda p: settings if p == project else original_get(p)

        result = classifier.classify("file_write", {"path": "/src/main.py"}, project)
        assert result.requires_approval is False

    def test_blocklist_overrides_level(self, service):
        """Blocklist rule should override autonomy level."""
        from src.agent.safety.classification import ActionClassifier
        from src.agent.safety.allowlist import AutonomyRule

        project = str(Path(tempfile.mkdtemp()).resolve())
        service._current_levels[project] = "L4"  # Most auto-execute

        classifier = ActionClassifier(autonomy_service=service)

        # Without rule: destructive auto-executes at L4
        result = classifier.classify("file_write", {"path": "/tmp/x"}, project)
        assert result.requires_approval is False

        # Add blocklist rule
        settings = service.get_settings(project)
        settings.blocklist_rules = [AutonomyRule("block", "path", "/tmp/*")]

        # Mock get_settings to return our modified settings
        original_get = service.get_settings
        service.get_settings = lambda p: settings if p == project else original_get(p)

        result = classifier.classify("file_write", {"path": "/tmp/data.txt"}, project)
        assert result.requires_approval is True
```
  </action>
  <verify>All tests pass: `python -m pytest tests/agent/safety/test_autonomy.py -v`</verify>
  <done>Classification integration tests with autonomy levels are added and passing</done>
</task>

</tasks>

<verification>
- [ ] All autonomy threshold tests pass
- [ ] All AutonomySettings tests pass
- [ ] All AutonomyLevelService tests pass
- [ ] All AutonomyRule tests pass
- [ ] All matches_rules tests pass
- [ ] All classifier integration tests pass
- [ ] `python -m pytest tests/agent/safety/ -v` passes all tests
</verification>

<success_criteria>
1. >90% code coverage for autonomy.py and allowlist.py
2. All four autonomy levels tested for correct behavior
3. Rule matching edge cases covered (glob, priority, tool restriction)
4. Classifier integration verified at each level
5. Downgrade callback tested
6. All tests pass on Windows (gc.collect() cleanup)
</success_criteria>

<output>
After completion, create `.planning/phases/13-autonomy-levels/13-07-SUMMARY.md`
</output>
