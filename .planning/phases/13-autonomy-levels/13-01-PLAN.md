---
phase: 13-autonomy-levels
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/agent/safety/autonomy.py
autonomous: true

must_haves:
  truths:
    - "AutonomyLevel type defines L1, L2, L3, L4 levels"
    - "Each level maps to a set of risk levels that auto-execute"
    - "AutonomyLevelService manages current level per project"
  artifacts:
    - path: "src/agent/safety/autonomy.py"
      provides: "AutonomyLevel, AUTONOMY_THRESHOLDS, AutonomyLevelService"
      exports: ["AutonomyLevel", "AUTONOMY_THRESHOLDS", "AUTONOMY_LABELS", "AUTONOMY_COLORS", "AutonomySettings", "AutonomyLevelService", "get_autonomy_service"]
  key_links:
    - from: "src/agent/safety/autonomy.py"
      to: "src/agent/safety/classification.py"
      via: "imports RiskLevel"
      pattern: "from.*classification import.*RiskLevel"
---

<objective>
Create core autonomy level models and service

Purpose: Define the four autonomy levels (L1-L4) with their threshold mappings and provide a service to manage the current level per project path.

Output: `src/agent/safety/autonomy.py` with AutonomyLevel type, threshold constants, AutonomySettings dataclass, AutonomyLevelService, and module-level singleton getter.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-autonomy-levels/13-CONTEXT.md
@.planning/phases/13-autonomy-levels/13-RESEARCH.md
@src/agent/safety/classification.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create autonomy level types and constants</name>
  <files>src/agent/safety/autonomy.py</files>
  <action>
Create `src/agent/safety/autonomy.py` with:

1. **AutonomyLevel type** using Literal["L1", "L2", "L3", "L4"]

2. **AUTONOMY_THRESHOLDS** dict mapping level to set of RiskLevels that auto-execute:
   - L1: empty set (nothing auto-executes, agent suggests only)
   - L2: {"safe"} (only safe auto-executes)
   - L3: {"safe", "moderate"} (safe + moderate auto-execute)
   - L4: {"safe", "moderate", "destructive"} (only critical requires approval)

3. **AUTONOMY_LABELS** dict with human-readable names:
   - L1: "Assistant", L2: "Collaborator", L3: "Trusted", L4: "Expert"

4. **AUTONOMY_COLORS** dict with colors that harmonize with existing RISK_COLORS:
   - L1: "#3B82F6" (blue - most cautious)
   - L2: "#10B981" (emerald - collaborative)
   - L3: "#F59E0B" (amber - trusted)
   - L4: "#EF4444" (red - expert/high autonomy)

Import RiskLevel from classification module.
  </action>
  <verify>File exists, imports work: `python -c "from src.agent.safety.autonomy import AutonomyLevel, AUTONOMY_THRESHOLDS, AUTONOMY_LABELS, AUTONOMY_COLORS"`</verify>
  <done>AutonomyLevel type and threshold/label/color constants are defined and importable</done>
</task>

<task type="auto">
  <name>Task 2: Create AutonomySettings and AutonomyLevelService</name>
  <files>src/agent/safety/autonomy.py</files>
  <action>
Add to `src/agent/safety/autonomy.py`:

1. **AutonomySettings dataclass** with:
   - level: AutonomyLevel = "L2" (default to Collaborator)
   - allowlist_rules: list = field(default_factory=list) (placeholder for Plan 04)
   - blocklist_rules: list = field(default_factory=list) (placeholder for Plan 04)
   - Method `auto_executes(risk_level: RiskLevel) -> bool` that checks if given risk level auto-executes at current autonomy level
   - Method `check_rules(tool_name: str, params: dict) -> bool | None` (returns None for now - implemented in Plan 04)

2. **AutonomyLevelService class** with:
   - `_current_levels: dict[str, AutonomyLevel]` for in-memory project -> level cache
   - `_level_changed_callbacks: list[Callable]` for observers (mid-task level change)
   - `get_settings(project_path: str | None) -> AutonomySettings` - returns settings for project (or global default)
   - `set_level(project_path: str, level: AutonomyLevel)` - sets level with callback notification
   - `get_default_level() -> AutonomyLevel` - returns global default (L2 for now)
   - `on_level_changed(callback: Callable)` - register callback for level changes
   - `_is_downgrade(old: AutonomyLevel, new: AutonomyLevel) -> bool` - check if level change is more restrictive

3. **Module-level singleton**:
   - `_global_autonomy_service: Optional[AutonomyLevelService] = None`
   - `get_autonomy_service() -> AutonomyLevelService` - returns singleton

Use pathlib.Path.resolve() for project path normalization.
  </action>
  <verify>Service works: `python -c "from src.agent.safety.autonomy import get_autonomy_service; svc = get_autonomy_service(); settings = svc.get_settings(None); print(settings.level, settings.auto_executes('safe'))"`</verify>
  <done>AutonomySettings dataclass and AutonomyLevelService with singleton getter are implemented</done>
</task>

<task type="auto">
  <name>Task 3: Export from safety module</name>
  <files>src/agent/safety/__init__.py</files>
  <action>
Update `src/agent/safety/__init__.py` to export autonomy types:

Add imports:
```python
from src.agent.safety.autonomy import (
    AutonomyLevel,
    AutonomySettings,
    AutonomyLevelService,
    AUTONOMY_COLORS,
    AUTONOMY_LABELS,
    AUTONOMY_THRESHOLDS,
    get_autonomy_service,
)
```

Add to `__all__`:
- "AutonomyLevel"
- "AutonomySettings"
- "AutonomyLevelService"
- "AUTONOMY_COLORS"
- "AUTONOMY_LABELS"
- "AUTONOMY_THRESHOLDS"
- "get_autonomy_service"
  </action>
  <verify>Exports work: `python -c "from src.agent.safety import AutonomyLevel, get_autonomy_service, AUTONOMY_THRESHOLDS; print('OK')"`</verify>
  <done>Autonomy types are exported from the safety module</done>
</task>

</tasks>

<verification>
- [ ] `AutonomyLevel` is a Literal type with L1, L2, L3, L4
- [ ] `AUTONOMY_THRESHOLDS` maps each level to correct risk level sets
- [ ] `AutonomySettings.auto_executes()` returns correct bool for each level
- [ ] `AutonomyLevelService.get_settings()` returns valid AutonomySettings
- [ ] All types exportable from `src.agent.safety`
- [ ] No import errors when loading the module
</verification>

<success_criteria>
1. AutonomyLevel type defines L1-L4 levels
2. AUTONOMY_THRESHOLDS correctly maps each level to auto-execute risk sets
3. AutonomyLevelService manages current level with path normalization
4. Service singleton pattern matches existing codebase patterns
5. All exports added to safety module __init__.py
</success_criteria>

<output>
After completion, create `.planning/phases/13-autonomy-levels/13-01-SUMMARY.md`
</output>
