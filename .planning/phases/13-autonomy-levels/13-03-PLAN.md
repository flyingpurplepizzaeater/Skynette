---
phase: 13-autonomy-levels
plan: 03
type: execute
wave: 2
depends_on: ["13-01", "13-02"]
files_modified:
  - src/agent/safety/classification.py
  - src/agent/safety/autonomy.py
autonomous: true

must_haves:
  truths:
    - "ActionClassifier uses autonomy level to determine requires_approval"
    - "L1 requires approval for ALL actions (nothing auto-executes)"
    - "L2 auto-executes safe, requires approval for moderate/destructive/critical"
    - "L3 auto-executes safe+moderate, requires approval for destructive/critical"
    - "L4 auto-executes safe+moderate+destructive, requires approval for critical only"
  artifacts:
    - path: "src/agent/safety/classification.py"
      provides: "Autonomy-aware ActionClassifier.classify()"
      contains: "get_autonomy_service"
  key_links:
    - from: "src/agent/safety/classification.py"
      to: "src/agent/safety/autonomy.py"
      via: "imports AutonomyLevelService"
      pattern: "get_autonomy_service"
---

<objective>
Make ActionClassifier autonomy-aware

Purpose: Modify the classification system to determine approval requirements based on current autonomy level, not just static risk classification.

Output: `ActionClassifier.classify()` consults autonomy service to determine `requires_approval` dynamically based on project's autonomy level.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-autonomy-levels/13-CONTEXT.md
@.planning/phases/13-autonomy-levels/13-RESEARCH.md
@src/agent/safety/classification.py
@src/agent/safety/autonomy.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire AutonomyLevelService into AutonomySettings</name>
  <files>src/agent/safety/autonomy.py</files>
  <action>
Update `AutonomyLevelService` to integrate with storage (from Plan 02):

1. Add import at top: `from src.data.storage import get_storage`

2. Update `get_settings()` method to load from storage:

```python
def get_settings(self, project_path: str | None = None) -> AutonomySettings:
    """
    Get autonomy settings for a project.

    Args:
        project_path: Project directory path, or None for global default

    Returns:
        AutonomySettings for the project
    """
    if project_path is None:
        # Return global defaults
        return AutonomySettings(level=self.get_default_level())

    # Check in-memory cache first
    normalized = str(Path(project_path).resolve())
    if normalized in self._current_levels:
        cached_level = self._current_levels[normalized]
        # Load full settings from storage but use cached level
        storage = get_storage()
        data = storage.get_project_autonomy(normalized)
        return AutonomySettings(
            level=cached_level,
            allowlist_rules=data.get("allowlist", []),
            blocklist_rules=data.get("blocklist", []),
        )

    # Load from storage
    storage = get_storage()
    data = storage.get_project_autonomy(project_path)

    return AutonomySettings(
        level=data.get("level", self.get_default_level()),
        allowlist_rules=data.get("allowlist", []),
        blocklist_rules=data.get("blocklist", []),
    )
```

3. Update `set_level()` to persist to storage:

```python
def set_level(self, project_path: str, level: AutonomyLevel) -> None:
    """
    Set autonomy level for a project.

    Persists to storage and notifies callbacks on downgrade.

    Args:
        project_path: Project directory path
        level: New autonomy level
    """
    normalized = str(Path(project_path).resolve())
    old_level = self._current_levels.get(normalized, self.get_default_level())
    self._current_levels[normalized] = level

    # Persist to storage
    storage = get_storage()
    storage.set_project_autonomy(normalized, level)

    # Notify callbacks on downgrade
    if self._is_downgrade(old_level, level):
        for callback in self._level_changed_callbacks:
            callback(project_path, old_level, level, downgrade=True)
```

4. Update `get_default_level()` to read from storage:

```python
def get_default_level(self) -> AutonomyLevel:
    """Get the global default autonomy level."""
    storage = get_storage()
    level = storage.get_setting("default_autonomy_level", "L2")
    if level in ("L1", "L2", "L3", "L4"):
        return level  # type: ignore
    return "L2"
```
  </action>
  <verify>Service reads from storage: `python -c "from src.agent.safety.autonomy import get_autonomy_service; svc = get_autonomy_service(); settings = svc.get_settings('/tmp/test'); print(settings.level)"`</verify>
  <done>AutonomyLevelService integrates with storage for persistence</done>
</task>

<task type="auto">
  <name>Task 2: Make ActionClassifier autonomy-aware</name>
  <files>src/agent/safety/classification.py</files>
  <action>
Modify `ActionClassifier` to use autonomy level when determining `requires_approval`:

1. Add import at top:
```python
from src.agent.safety.autonomy import get_autonomy_service, AUTONOMY_THRESHOLDS
```

2. Update `__init__` to accept optional autonomy service:
```python
def __init__(self, autonomy_service=None):
    """
    Initialize classifier.

    Args:
        autonomy_service: Optional AutonomyLevelService (uses global if not provided)
    """
    self._autonomy_service = autonomy_service
```

3. Add property for lazy service access:
```python
@property
def autonomy_service(self):
    """Get autonomy service, using global singleton if not provided."""
    if self._autonomy_service is None:
        self._autonomy_service = get_autonomy_service()
    return self._autonomy_service
```

4. Update `classify()` method signature and implementation:
```python
def classify(
    self,
    tool_name: str,
    parameters: dict,
    project_path: str | None = None,
) -> ActionClassification:
    """
    Classify an action by tool name and parameters.

    Args:
        tool_name: Name of the tool being called
        parameters: Tool parameters
        project_path: Optional project path for autonomy level lookup

    Returns:
        ActionClassification with risk level and approval requirement
    """
    # Built-in tool classification
    if tool_name in self.TOOL_CLASSIFICATIONS:
        risk = self.TOOL_CLASSIFICATIONS[tool_name]
    else:
        # Unknown/MCP tools default to moderate
        risk = "moderate"

    # Get autonomy settings
    settings = self.autonomy_service.get_settings(project_path)

    # Check allowlist/blocklist rules first (override autonomy level)
    rule_result = settings.check_rules(tool_name, parameters)
    if rule_result is not None:
        # Rule explicitly allows or blocks
        requires_approval = not rule_result  # allow=True means no approval needed
        return ActionClassification(
            risk_level=risk,
            reason=self._get_reason(tool_name, risk, parameters),
            requires_approval=requires_approval,
            tool_name=tool_name,
            parameters=parameters,
        )

    # Apply autonomy threshold
    auto_execute_levels = AUTONOMY_THRESHOLDS[settings.level]
    requires_approval = risk not in auto_execute_levels

    return ActionClassification(
        risk_level=risk,
        reason=self._get_reason(tool_name, risk, parameters),
        requires_approval=requires_approval,
        tool_name=tool_name,
        parameters=parameters,
    )
```

5. Remove the static `APPROVAL_REQUIRED` dict (no longer needed - approval is dynamic based on autonomy level).
  </action>
  <verify>Classification respects autonomy: `python -c "
from src.agent.safety.classification import ActionClassifier
from src.agent.safety.autonomy import get_autonomy_service

svc = get_autonomy_service()
# Set L4 level (only critical needs approval)
svc._current_levels['/tmp/test'] = 'L4'

classifier = ActionClassifier()
# file_write is 'destructive' - should NOT require approval at L4
result = classifier.classify('file_write', {'path': '/tmp/x'}, '/tmp/test')
print(f'L4: file_write requires_approval={result.requires_approval}')  # Should be False

# Reset to L2 (only safe auto-executes)
svc._current_levels['/tmp/test'] = 'L2'
result = classifier.classify('file_write', {'path': '/tmp/x'}, '/tmp/test')
print(f'L2: file_write requires_approval={result.requires_approval}')  # Should be True
"`</verify>
  <done>ActionClassifier.classify() uses autonomy level to determine requires_approval dynamically</done>
</task>

</tasks>

<verification>
- [ ] L1 mode: ALL actions require approval (empty auto-execute set)
- [ ] L2 mode: Only "safe" actions auto-execute
- [ ] L3 mode: "safe" and "moderate" actions auto-execute
- [ ] L4 mode: Only "critical" actions require approval
- [ ] `project_path` parameter flows through classify() correctly
- [ ] No project_path defaults to global level
- [ ] Static APPROVAL_REQUIRED dict removed (approval is dynamic)
</verification>

<success_criteria>
1. ActionClassifier reads autonomy level from AutonomyLevelService
2. Approval requirement is calculated from AUTONOMY_THRESHOLDS, not static dict
3. Different projects can have different autonomy levels
4. Allowlist/blocklist rule check is called (returns None for now)
5. Backward compatible - classify() works without project_path
</success_criteria>

<output>
After completion, create `.planning/phases/13-autonomy-levels/13-03-SUMMARY.md`
</output>
