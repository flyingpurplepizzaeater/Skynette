---
phase: 09-mcp-integration
plan: 03
type: execute
wave: 3
depends_on: ["09-02"]
files_modified:
  - src/agent/mcp/adapter/__init__.py
  - src/agent/mcp/adapter/tool_adapter.py
  - src/agent/registry/tool_registry.py
autonomous: true

must_haves:
  truths:
    - "MCP tools appear in the agent tool registry alongside built-in tools"
    - "MCP tool calls route through MCPClientManager to the correct server"
    - "Tool names are namespaced to prevent conflicts (mcp_serverid_toolname)"
    - "Tool definitions include source server metadata for UI display"
  artifacts:
    - path: "src/agent/mcp/adapter/tool_adapter.py"
      provides: "MCPToolAdapter that wraps MCP tools as BaseTool"
      exports: ["MCPToolAdapter"]
    - path: "src/agent/registry/tool_registry.py"
      provides: "Extended ToolRegistry with MCP tool registration"
      contains: "register_mcp_tools"
  key_links:
    - from: "src/agent/mcp/adapter/tool_adapter.py"
      to: "src/agent/registry/base_tool.py"
      via: "inherits from BaseTool"
      pattern: "class MCPToolAdapter\\(BaseTool\\)"
    - from: "src/agent/mcp/adapter/tool_adapter.py"
      to: "src/agent/mcp/client/manager.py"
      via: "calls manager.call_tool for execution"
      pattern: "manager\\.call_tool"
    - from: "src/agent/registry/tool_registry.py"
      to: "src/agent/mcp/adapter/tool_adapter.py"
      via: "creates MCPToolAdapter instances"
      pattern: "MCPToolAdapter\\("
---

<objective>
Create the adapter that wraps MCP tools as BaseTool instances and integrate them into the existing ToolRegistry.

Purpose: Enable agent to use MCP tools exactly like built-in tools. Per 09-CONTEXT.md, tools should be organized by function (not source) with clear source attribution for UI.

Output: MCPToolAdapter class and enhanced ToolRegistry that can register/unregister MCP tools dynamically as servers connect/disconnect.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-mcp-integration/09-CONTEXT.md
@.planning/phases/09-mcp-integration/09-RESEARCH.md
@.planning/phases/09-mcp-integration/09-01-SUMMARY.md
@.planning/phases/09-mcp-integration/09-02-SUMMARY.md

# Key files to modify/reference
@src/agent/registry/base_tool.py
@src/agent/registry/tool_registry.py
@src/agent/models/tool.py
@src/agent/mcp/client/manager.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: MCP Tool Adapter</name>
  <files>
    src/agent/mcp/adapter/__init__.py
    src/agent/mcp/adapter/tool_adapter.py
  </files>
  <action>
Create the MCPToolAdapter that wraps an MCP tool as a BaseTool instance.

In `src/agent/mcp/adapter/tool_adapter.py`:

```python
"""MCP Tool Adapter - wraps MCP tools as BaseTool instances."""

import logging
from typing import Optional

from src.agent.registry.base_tool import BaseTool, AgentContext
from src.agent.models.tool import ToolDefinition, ToolResult
from src.agent.mcp.models.trust import TrustLevel

logger = logging.getLogger(__name__)


class MCPToolAdapter(BaseTool):
    """Adapter that wraps an MCP tool as a BaseTool for ToolRegistry integration."""

    def __init__(
        self,
        mcp_tool: dict,  # From MCP list_tools response
        server_id: str,
        server_name: str,
        trust_level: TrustLevel,
    ):
        """
        Initialize adapter for an MCP tool.

        Args:
            mcp_tool: Tool dict from MCP list_tools (name, description, inputSchema)
            server_id: ID of the server providing this tool
            server_name: Human-readable server name for display
            trust_level: Trust level of the source server
        """
        self._mcp_tool = mcp_tool
        self._server_id = server_id
        self._server_name = server_name
        self._trust_level = trust_level

        # BaseTool class attributes - namespaced to prevent conflicts
        self.name = f"mcp_{server_id[:8]}_{mcp_tool['name']}"
        self.description = self._build_description(mcp_tool)
        self.parameters_schema = mcp_tool.get('inputSchema', {
            "type": "object",
            "properties": {}
        })

        # MCP-specific metadata for UI
        self.source_server_id = server_id
        self.source_server_name = server_name
        self.original_name = mcp_tool['name']
        self.original_description = mcp_tool.get('description', '')

    def _build_description(self, mcp_tool: dict) -> str:
        """Build description with source attribution."""
        desc = mcp_tool.get('description', 'No description provided')
        return f"[{self._server_name}] {desc}"

    async def execute(self, params: dict, context: AgentContext) -> ToolResult:
        """Execute the MCP tool via MCPClientManager."""
        from src.agent.mcp.client.manager import get_mcp_client_manager

        manager = get_mcp_client_manager()

        try:
            result = await manager.call_tool(
                self._server_id,
                self.original_name,  # Use original name for MCP call
                params,
            )

            if result.get('success', True):
                # Extract text content for compatibility
                content = result.get('content', [])
                data = content[0].get('text', '') if content else result.get('structured')
                return ToolResult.success_result(
                    tool_call_id=context.session_id,
                    data=data,
                )
            else:
                error_content = result.get('content', [])
                error_msg = error_content[0].get('text', 'Unknown error') if error_content else 'Tool execution failed'
                return ToolResult.failure_result(
                    tool_call_id=context.session_id,
                    error=error_msg,
                )

        except Exception as e:
            logger.error(f"MCP tool execution failed: {e}")
            return ToolResult.failure_result(
                tool_call_id=context.session_id,
                error=str(e),
            )

    def get_definition(self) -> ToolDefinition:
        """Get tool definition with MCP metadata."""
        # Determine approval requirement based on trust level
        requires_approval = self._trust_level == TrustLevel.USER_ADDED

        return ToolDefinition(
            name=self.name,
            description=self.description,
            parameters=self.parameters_schema,
            category=f"mcp:{self._server_name.lower().replace(' ', '_')}",
            is_destructive=False,  # Conservative default, can be enhanced later
            requires_approval=requires_approval,
        )

    def get_mcp_metadata(self) -> dict:
        """Get MCP-specific metadata for UI display."""
        return {
            "server_id": self._server_id,
            "server_name": self._server_name,
            "original_name": self.original_name,
            "original_description": self.original_description,
            "trust_level": self._trust_level.value,
        }
```

In `src/agent/mcp/adapter/__init__.py`:
- Export MCPToolAdapter
  </action>
  <verify>
```bash
cd C:/Users/karlt/OneDrive/Desktop/Claude/skynette-repo
python -c "
from src.agent.mcp.adapter.tool_adapter import MCPToolAdapter
from src.agent.mcp.models.trust import TrustLevel

# Create a mock MCP tool
mcp_tool = {
    'name': 'read_file',
    'description': 'Read contents of a file',
    'inputSchema': {
        'type': 'object',
        'properties': {'path': {'type': 'string'}},
        'required': ['path']
    }
}

adapter = MCPToolAdapter(
    mcp_tool=mcp_tool,
    server_id='abc12345-test',
    server_name='Filesystem',
    trust_level=TrustLevel.VERIFIED,
)

print(f'Tool name: {adapter.name}')
print(f'Description: {adapter.description}')
print(f'Original: {adapter.original_name}')

defn = adapter.get_definition()
print(f'Category: {defn.category}')
print(f'Requires approval: {defn.requires_approval}')
"
```
  </verify>
  <done>
MCPToolAdapter wraps MCP tools with namespaced names, source attribution, and proper ToolDefinition generation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend ToolRegistry for MCP</name>
  <files>
    src/agent/registry/tool_registry.py
  </files>
  <action>
Extend the existing ToolRegistry to support dynamic registration of MCP tools.

Add to `src/agent/registry/tool_registry.py`:

1. Add new instance variable in __init__:
   - `self._mcp_tools: dict[str, BaseTool] = {}`  # name -> MCPToolAdapter instance

2. Add new methods:

```python
def register_mcp_tool(self, tool: "MCPToolAdapter") -> None:
    """Register an MCP tool adapter instance."""
    if tool.name in self._tools or tool.name in self._mcp_tools:
        logger.warning(f"Tool {tool.name} already registered, skipping")
        return
    self._mcp_tools[tool.name] = tool
    logger.debug(f"Registered MCP tool: {tool.name}")

def unregister_mcp_tool(self, tool_name: str) -> None:
    """Unregister an MCP tool."""
    if tool_name in self._mcp_tools:
        del self._mcp_tools[tool_name]
        logger.debug(f"Unregistered MCP tool: {tool_name}")

def register_mcp_tools_from_server(
    self,
    server_id: str,
    server_name: str,
    trust_level: "TrustLevel",
    tools: list[dict],
) -> int:
    """
    Register all tools from an MCP server.

    Returns number of tools registered.
    """
    from src.agent.mcp.adapter.tool_adapter import MCPToolAdapter

    count = 0
    for mcp_tool in tools:
        adapter = MCPToolAdapter(
            mcp_tool=mcp_tool,
            server_id=server_id,
            server_name=server_name,
            trust_level=trust_level,
        )
        self.register_mcp_tool(adapter)
        count += 1

    logger.info(f"Registered {count} MCP tools from {server_name}")
    return count

def unregister_mcp_tools_from_server(self, server_id: str) -> int:
    """
    Unregister all tools from a specific MCP server.

    Returns number of tools unregistered.
    """
    # Find tools from this server (by checking name prefix)
    prefix = f"mcp_{server_id[:8]}_"
    to_remove = [name for name in self._mcp_tools.keys() if name.startswith(prefix)]

    for name in to_remove:
        del self._mcp_tools[name]

    logger.info(f"Unregistered {len(to_remove)} MCP tools from server {server_id}")
    return len(to_remove)

def get_mcp_tools(self) -> list["MCPToolAdapter"]:
    """Get all registered MCP tools."""
    return list(self._mcp_tools.values())
```

3. Update existing methods to include MCP tools:

Update `get_tool(name)`:
```python
def get_tool(self, name: str) -> Optional[BaseTool]:
    """Get tool instance by name (includes MCP tools)."""
    # Check MCP tools first (instances, not classes)
    if name in self._mcp_tools:
        return self._mcp_tools[name]
    # Then check built-in tools (classes)
    tool_class = self._tools.get(name)
    return tool_class() if tool_class else None
```

Update `get_all_definitions()`:
```python
def get_all_definitions(self) -> list[ToolDefinition]:
    """Get all tool definitions for LLM context (includes MCP tools)."""
    definitions = [cls().get_definition() for cls in self._tools.values()]
    definitions.extend([tool.get_definition() for tool in self._mcp_tools.values()])
    return definitions
```

Update `tool_names` property:
```python
@property
def tool_names(self) -> list[str]:
    """Get all registered tool names (includes MCP tools)."""
    return list(self._tools.keys()) + list(self._mcp_tools.keys())
```

Add import at top:
```python
from typing import Optional, Type, TYPE_CHECKING

if TYPE_CHECKING:
    from src.agent.mcp.adapter.tool_adapter import MCPToolAdapter
    from src.agent.mcp.models.trust import TrustLevel
```
  </action>
  <verify>
```bash
cd C:/Users/karlt/OneDrive/Desktop/Claude/skynette-repo
python -c "
from src.agent.registry.tool_registry import get_tool_registry
from src.agent.mcp.models.trust import TrustLevel

registry = get_tool_registry()

# Register MCP tools
tools = [
    {'name': 'read_file', 'description': 'Read file', 'inputSchema': {}},
    {'name': 'write_file', 'description': 'Write file', 'inputSchema': {}},
]

count = registry.register_mcp_tools_from_server(
    server_id='test-server-123',
    server_name='Filesystem',
    trust_level=TrustLevel.VERIFIED,
    tools=tools,
)
print(f'Registered {count} tools')

# Check they appear
print(f'Tool names: {registry.tool_names}')
print(f'MCP tools: {len(registry.get_mcp_tools())}')

# Get a specific tool
tool = registry.get_tool('mcp_test-ser_read_file')
print(f'Got tool: {tool.name if tool else None}')

# Unregister
removed = registry.unregister_mcp_tools_from_server('test-server-123')
print(f'Removed {removed} tools')
print(f'Remaining MCP tools: {len(registry.get_mcp_tools())}')
"
```
  </verify>
  <done>
ToolRegistry supports dynamic MCP tool registration/unregistration. MCP tools appear alongside built-in tools in definitions and can be retrieved by name.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Adapter creates proper tool definitions:
```bash
python -c "
from src.agent.mcp.adapter.tool_adapter import MCPToolAdapter
from src.agent.mcp.models.trust import TrustLevel

adapter = MCPToolAdapter(
    mcp_tool={'name': 'search', 'description': 'Web search', 'inputSchema': {'type': 'object'}},
    server_id='fetch-server-abc',
    server_name='Fetch',
    trust_level=TrustLevel.USER_ADDED,
)

defn = adapter.get_definition()
assert defn.requires_approval == True  # USER_ADDED requires approval
print(f'Tool: {defn.name}')
print(f'OpenAI format: {defn.to_openai_format()}')
print('Adapter OK')
"
```

2. Registry integration works end-to-end:
```bash
python -c "
from src.agent.registry.tool_registry import ToolRegistry
from src.agent.mcp.models.trust import TrustLevel

# Fresh registry (not singleton for clean test)
class TestRegistry(ToolRegistry):
    _instance = None

registry = TestRegistry()
registry._tools = {}
registry._mcp_tools = {}

# Should have no MCP tools initially
assert len(registry.get_mcp_tools()) == 0

# Register from server
registry.register_mcp_tools_from_server(
    server_id='srv-001',
    server_name='Test Server',
    trust_level=TrustLevel.BUILTIN,
    tools=[{'name': 'tool1', 'description': 'Test', 'inputSchema': {}}],
)

assert len(registry.get_mcp_tools()) == 1
assert 'mcp_srv-001_tool1' in registry.tool_names

# Definitions include MCP tools
defs = registry.get_all_definitions()
mcp_defs = [d for d in defs if d.name.startswith('mcp_')]
assert len(mcp_defs) == 1

print('Registry integration OK')
"
```
</verification>

<success_criteria>
- MCPToolAdapter inherits from BaseTool and implements execute()
- Tool names are namespaced: mcp_{server_id_prefix}_{original_name}
- Descriptions include source attribution: [ServerName] description
- ToolRegistry.get_tool() returns MCP tools
- ToolRegistry.get_all_definitions() includes MCP tools
- Tools can be registered/unregistered per server
- USER_ADDED tools have requires_approval=True
</success_criteria>

<output>
After completion, create `.planning/phases/09-mcp-integration/09-03-SUMMARY.md`
</output>
