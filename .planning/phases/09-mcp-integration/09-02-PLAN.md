---
phase: 09-mcp-integration
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - src/agent/mcp/client/__init__.py
  - src/agent/mcp/client/connection.py
  - src/agent/mcp/client/manager.py
  - pyproject.toml
autonomous: true

must_haves:
  truths:
    - "MCPClientManager connects to local MCP servers via stdio transport"
    - "MCPClientManager connects to remote MCP servers via HTTP transport"
    - "No orphaned server processes remain after disconnect"
    - "Failed connections report errors without crashing the manager"
    - "Disconnected servers automatically attempt reconnection with backoff"
  artifacts:
    - path: "src/agent/mcp/client/connection.py"
      provides: "MCPConnection wrapper around ClientSession"
      exports: ["MCPConnection"]
    - path: "src/agent/mcp/client/manager.py"
      provides: "Singleton manager for all MCP connections"
      exports: ["MCPClientManager", "get_mcp_client_manager"]
    - path: "pyproject.toml"
      provides: "MCP SDK dependency"
      contains: "mcp"
  key_links:
    - from: "src/agent/mcp/client/manager.py"
      to: "src/agent/mcp/models/server.py"
      via: "uses MCPServerConfig for connection params"
      pattern: "MCPServerConfig"
    - from: "src/agent/mcp/client/manager.py"
      to: "mcp.client.stdio"
      via: "uses stdio_client for local servers"
      pattern: "from mcp.client.stdio import"
    - from: "src/agent/mcp/client/manager.py"
      to: "mcp.client.streamable_http"
      via: "uses streamablehttp_client for remote servers"
      pattern: "from mcp.client.streamable_http import"
---

<objective>
Implement the MCP client manager that connects to MCP servers via stdio and HTTP transports using the official MCP Python SDK.

Purpose: Enable Skynette to act as an MCP host, connecting to external MCP servers that provide tools. Per 09-CONTEXT.md, connections should be background/lazy with auto-reconnect on failure using exponential backoff.

Output: MCPClientManager singleton that manages connections to multiple MCP servers, with support for both local (stdio) and remote (HTTP/SSE) servers, including automatic reconnection with exponential backoff.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-mcp-integration/09-CONTEXT.md
@.planning/phases/09-mcp-integration/09-RESEARCH.md
@.planning/phases/09-mcp-integration/09-01-SUMMARY.md

# Existing patterns
@src/agent/registry/tool_registry.py
@src/agent/mcp/models/server.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add MCP SDK Dependency</name>
  <files>
    pyproject.toml
  </files>
  <action>
Add the official MCP Python SDK to project dependencies.

In `pyproject.toml`, add to [project.dependencies]:
- "mcp>=1.25.0"

The mcp package includes:
- ClientSession for managing MCP protocol
- stdio_client for local subprocess servers
- streamablehttp_client for remote HTTP servers
- All JSON-RPC 2.0 handling

Note: httpx is already in the stack (used by mcp SDK internally).
  </action>
  <verify>
```bash
cd C:/Users/karlt/OneDrive/Desktop/Claude/skynette-repo
pip install "mcp>=1.25.0" --quiet
python -c "from mcp import ClientSession; from mcp.client.stdio import stdio_client; from mcp.client.streamable_http import streamablehttp_client; print('MCP SDK installed correctly')"
```
  </verify>
  <done>
MCP SDK is added to dependencies and can be imported.
  </done>
</task>

<task type="auto">
  <name>Task 2: MCP Connection Wrapper</name>
  <files>
    src/agent/mcp/client/__init__.py
    src/agent/mcp/client/connection.py
  </files>
  <action>
Create the MCPConnection class that wraps an MCP ClientSession with connection metadata.

In `src/agent/mcp/client/connection.py`:

```python
class MCPConnection:
    """Wrapper around MCP ClientSession with connection metadata."""

    def __init__(
        self,
        server_id: str,
        session: ClientSession,
        config: MCPServerConfig,
    ):
        self.server_id = server_id
        self.session = session
        self.config = config
        self.connected_at: datetime = datetime.now(UTC)
        self.last_activity: datetime = self.connected_at
        self._tools_cache: Optional[list[dict]] = None

    async def list_tools(self) -> list[dict]:
        """List available tools from this server."""
        # Cache tools to avoid repeated calls
        if self._tools_cache is None:
            response = await self.session.list_tools()
            self._tools_cache = [
                {
                    "name": tool.name,
                    "description": tool.description or "",
                    "inputSchema": tool.inputSchema,
                }
                for tool in response.tools
            ]
        self.last_activity = datetime.now(UTC)
        return self._tools_cache

    async def call_tool(self, tool_name: str, arguments: dict) -> dict:
        """Call a tool on this server."""
        result = await self.session.call_tool(tool_name, arguments)
        self.last_activity = datetime.now(UTC)

        # Parse result content
        is_error = getattr(result, 'isError', False)
        content = []
        for item in result.content:
            if item.type == "text":
                content.append({"type": "text", "text": item.text})
            elif item.type == "image":
                content.append({
                    "type": "image",
                    "data": item.data,
                    "mimeType": item.mimeType,
                })

        return {
            "success": not is_error,
            "content": content,
            "structured": getattr(result, 'structuredContent', None),
        }

    def invalidate_cache(self) -> None:
        """Invalidate tools cache (call after server update)."""
        self._tools_cache = None

    def get_status(self) -> MCPServerStatus:
        """Get current connection status."""
        return MCPServerStatus(
            server_id=self.server_id,
            connected=True,
            connecting=False,
            tools_count=len(self._tools_cache) if self._tools_cache else 0,
            last_active=self.last_activity,
        )
```

Include proper imports for:
- mcp.ClientSession
- datetime, UTC
- MCPServerConfig, MCPServerStatus from models
- Optional, list, dict from typing
  </action>
  <verify>
```bash
cd C:/Users/karlt/OneDrive/Desktop/Claude/skynette-repo
python -c "from src.agent.mcp.client.connection import MCPConnection; print('MCPConnection imported successfully')"
```
  </verify>
  <done>
MCPConnection wraps ClientSession with tool caching, call_tool method, and status reporting.
  </done>
</task>

<task type="auto">
  <name>Task 3: MCP Client Manager with Auto-Reconnect</name>
  <files>
    src/agent/mcp/client/manager.py
  </files>
  <action>
Create the singleton MCPClientManager that manages all MCP server connections with auto-reconnect support.

In `src/agent/mcp/client/manager.py`:

```python
class MCPClientManager:
    """Singleton manager for all MCP server connections."""

    _instance: Optional["MCPClientManager"] = None
    _connections: dict[str, MCPConnection]
    _exit_stack: AsyncExitStack
    _initialized: bool
    _reconnect_tasks: dict[str, asyncio.Task]
    _server_configs: dict[str, MCPServerConfig]  # Store configs for reconnection

    # Reconnect settings
    RECONNECT_BASE_DELAY = 1.0  # Initial delay in seconds
    RECONNECT_MAX_DELAY = 60.0  # Maximum delay
    RECONNECT_MAX_ATTEMPTS = 5  # Max attempts before giving up

    def __new__(cls) -> "MCPClientManager":
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance._initialized = False
        return cls._instance

    async def initialize(self) -> None:
        """Initialize the manager (call once at startup)."""
        if self._initialized:
            return
        self._connections = {}
        self._exit_stack = AsyncExitStack()
        self._reconnect_tasks = {}
        self._server_configs = {}
        self._initialized = True
        logger.info("MCPClientManager initialized")

    async def connect(self, config: MCPServerConfig) -> MCPConnection:
        """Connect to an MCP server based on config."""
        if not self._initialized:
            await self.initialize()

        if config.id in self._connections:
            return self._connections[config.id]

        # Store config for potential reconnection
        self._server_configs[config.id] = config

        try:
            if config.transport == TransportType.STDIO:
                connection = await self._connect_stdio(config)
            else:  # HTTP
                connection = await self._connect_http(config)

            self._connections[config.id] = connection
            logger.info(f"Connected to MCP server: {config.name}")
            return connection

        except Exception as e:
            logger.error(f"Failed to connect to {config.name}: {e}")
            raise ConnectionError(f"Failed to connect to {config.name}: {e}")

    async def _connect_stdio(self, config: MCPServerConfig) -> MCPConnection:
        """Connect via stdio transport."""
        from mcp import ClientSession
        from mcp.client.stdio import stdio_client, StdioServerParameters

        server_params = StdioServerParameters(
            command=config.command,
            args=config.args,
            env=config.env or None,
        )

        transport = await self._exit_stack.enter_async_context(
            stdio_client(server_params)
        )
        read_stream, write_stream = transport

        session = await self._exit_stack.enter_async_context(
            ClientSession(read_stream, write_stream)
        )
        await session.initialize()

        return MCPConnection(
            server_id=config.id,
            session=session,
            config=config,
        )

    async def _connect_http(self, config: MCPServerConfig) -> MCPConnection:
        """Connect via Streamable HTTP transport."""
        from mcp import ClientSession
        from mcp.client.streamable_http import streamablehttp_client

        headers = config.headers or {}

        transport = await self._exit_stack.enter_async_context(
            streamablehttp_client(config.url, headers=headers)
        )
        read_stream, write_stream, _ = transport

        session = await self._exit_stack.enter_async_context(
            ClientSession(read_stream, write_stream)
        )
        await session.initialize()

        return MCPConnection(
            server_id=config.id,
            session=session,
            config=config,
        )

    def _schedule_reconnect(self, server_id: str, attempt: int = 1) -> None:
        """Schedule a reconnection attempt with exponential backoff.

        Per 09-CONTEXT.md: Auto-reconnect with exponential backoff if server
        disconnects mid-session.
        """
        if server_id not in self._server_configs:
            logger.warning(f"No config stored for server {server_id}, cannot reconnect")
            return

        if attempt > self.RECONNECT_MAX_ATTEMPTS:
            logger.error(f"Max reconnect attempts ({self.RECONNECT_MAX_ATTEMPTS}) reached for {server_id}")
            return

        # Cancel any existing reconnect task for this server
        if server_id in self._reconnect_tasks:
            self._reconnect_tasks[server_id].cancel()

        # Calculate delay with exponential backoff
        delay = min(
            self.RECONNECT_BASE_DELAY * (2 ** (attempt - 1)),
            self.RECONNECT_MAX_DELAY
        )

        async def _do_reconnect():
            await asyncio.sleep(delay)
            config = self._server_configs.get(server_id)
            if not config:
                return

            logger.info(f"Attempting reconnect to {config.name} (attempt {attempt})")
            try:
                await self.connect(config)
                logger.info(f"Reconnected to {config.name}")
                # Clear reconnect task on success
                self._reconnect_tasks.pop(server_id, None)
            except Exception as e:
                logger.warning(f"Reconnect attempt {attempt} failed for {config.name}: {e}")
                # Schedule next attempt
                self._schedule_reconnect(server_id, attempt + 1)

        task = asyncio.create_task(_do_reconnect())
        self._reconnect_tasks[server_id] = task
        logger.info(f"Scheduled reconnect for {server_id} in {delay:.1f}s (attempt {attempt})")

    async def handle_connection_lost(self, server_id: str) -> None:
        """Handle unexpected connection loss - trigger reconnect.

        Call this when a connection error is detected during operation.
        """
        if server_id in self._connections:
            del self._connections[server_id]

        config = self._server_configs.get(server_id)
        if config and config.enabled:
            logger.info(f"Connection lost to {config.name}, scheduling reconnect")
            self._schedule_reconnect(server_id)

    async def disconnect(self, server_id: str) -> None:
        """Disconnect from a specific server."""
        # Cancel any pending reconnect
        if server_id in self._reconnect_tasks:
            self._reconnect_tasks[server_id].cancel()
            del self._reconnect_tasks[server_id]

        if server_id in self._connections:
            # Note: AsyncExitStack handles cleanup
            del self._connections[server_id]
            logger.info(f"Disconnected from server: {server_id}")

        # Remove stored config to prevent auto-reconnect
        self._server_configs.pop(server_id, None)

    async def disconnect_all(self) -> None:
        """Disconnect from all servers and cleanup."""
        # Cancel all reconnect tasks
        for task in self._reconnect_tasks.values():
            task.cancel()
        self._reconnect_tasks.clear()

        self._connections.clear()
        self._server_configs.clear()
        await self._exit_stack.aclose()
        self._exit_stack = AsyncExitStack()
        logger.info("Disconnected from all MCP servers")

    def get_connection(self, server_id: str) -> Optional[MCPConnection]:
        """Get an existing connection by server ID."""
        return self._connections.get(server_id)

    def list_connections(self) -> list[MCPConnection]:
        """List all active connections."""
        return list(self._connections.values())

    def get_all_status(self) -> dict[str, MCPServerStatus]:
        """Get status for all connections."""
        return {
            server_id: conn.get_status()
            for server_id, conn in self._connections.items()
        }

    def is_reconnecting(self, server_id: str) -> bool:
        """Check if a server is currently attempting to reconnect."""
        return server_id in self._reconnect_tasks

    async def list_tools(self, server_id: str) -> list[dict]:
        """List tools from a specific server."""
        conn = self._connections.get(server_id)
        if not conn:
            raise ValueError(f"Server {server_id} not connected")
        return await conn.list_tools()

    async def call_tool(
        self, server_id: str, tool_name: str, arguments: dict
    ) -> dict:
        """Call a tool on a specific server."""
        conn = self._connections.get(server_id)
        if not conn:
            raise ValueError(f"Server {server_id} not connected")
        try:
            return await conn.call_tool(tool_name, arguments)
        except Exception as e:
            # Connection might be broken - trigger reconnect
            logger.error(f"Tool call failed, connection may be lost: {e}")
            await self.handle_connection_lost(server_id)
            raise


# Module-level singleton accessor
_manager: Optional[MCPClientManager] = None

def get_mcp_client_manager() -> MCPClientManager:
    """Get the global MCP client manager instance."""
    global _manager
    if _manager is None:
        _manager = MCPClientManager()
    return _manager
```

Include proper imports:
- asyncio, AsyncExitStack from contextlib
- logging
- Optional, dict, list from typing
- MCPConnection from .connection
- MCPServerConfig, MCPServerStatus, TransportType from ..models.server
  </action>
  <verify>
```bash
cd C:/Users/karlt/OneDrive/Desktop/Claude/skynette-repo
python -c "
from src.agent.mcp.client.manager import MCPClientManager, get_mcp_client_manager
manager = get_mcp_client_manager()
print(f'Manager singleton: {manager is get_mcp_client_manager()}')
print(f'Has _schedule_reconnect: {hasattr(manager, \"_schedule_reconnect\")}')
print(f'Has handle_connection_lost: {hasattr(manager, \"handle_connection_lost\")}')
print(f'Has is_reconnecting: {hasattr(manager, \"is_reconnecting\")}')
print(f'RECONNECT_MAX_ATTEMPTS: {MCPClientManager.RECONNECT_MAX_ATTEMPTS}')
"
```
  </verify>
  <done>
MCPClientManager is a singleton that can connect to servers via stdio or HTTP transport, manages connection lifecycle, provides tool listing/calling methods, and includes auto-reconnect with exponential backoff (1s, 2s, 4s, 8s... up to 60s max, 5 attempts max).
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. SDK available:
```bash
python -c "from mcp import ClientSession; print('MCP SDK OK')"
```

2. Manager can be instantiated with reconnect support:
```bash
python -c "
import asyncio
from src.agent.mcp.client.manager import get_mcp_client_manager, MCPClientManager

async def test():
    manager = get_mcp_client_manager()
    await manager.initialize()
    print(f'Manager initialized, connections: {len(manager.list_connections())}')

    # Verify reconnect methods exist
    assert hasattr(manager, '_schedule_reconnect')
    assert hasattr(manager, 'handle_connection_lost')
    assert hasattr(manager, 'is_reconnecting')
    print(f'Reconnect base delay: {MCPClientManager.RECONNECT_BASE_DELAY}s')
    print(f'Reconnect max delay: {MCPClientManager.RECONNECT_MAX_DELAY}s')
    print(f'Max attempts: {MCPClientManager.RECONNECT_MAX_ATTEMPTS}')

    await manager.disconnect_all()
    print('Cleanup complete')

asyncio.run(test())
"
```

3. Connection to a real MCP server (requires npx):
```bash
# This test is optional - only run if npx is available
python -c "
import asyncio
import shutil
from src.agent.mcp.client.manager import get_mcp_client_manager
from src.agent.mcp.models.server import MCPServerConfig, TransportType

async def test():
    if not shutil.which('npx'):
        print('npx not available, skipping real connection test')
        return

    manager = get_mcp_client_manager()
    await manager.initialize()

    # Test with fetch server (lightweight)
    config = MCPServerConfig(
        name='Test Fetch',
        transport=TransportType.STDIO,
        command='npx',
        args=['-y', '@modelcontextprotocol/server-fetch'],
    )

    try:
        conn = await manager.connect(config)
        tools = await conn.list_tools()
        print(f'Connected! Found {len(tools)} tools')
        for t in tools[:3]:
            print(f'  - {t[\"name\"]}: {t[\"description\"][:50]}...')
    except Exception as e:
        print(f'Connection test failed (expected if no npx): {e}')
    finally:
        await manager.disconnect_all()

asyncio.run(test())
"
```
</verification>

<success_criteria>
- MCP SDK (mcp>=1.25.0) is added to pyproject.toml dependencies
- MCPClientManager singleton can be initialized
- connect() method handles both stdio and HTTP transports
- Connection lifecycle is managed through AsyncExitStack
- list_tools() and call_tool() methods work on active connections
- Errors are logged and raised as ConnectionError
- Auto-reconnect with exponential backoff (1s base, 60s max, 5 attempts)
- handle_connection_lost() triggers reconnection
- is_reconnecting() reports reconnect status
- No orphaned processes after disconnect_all()
</success_criteria>

<output>
After completion, create `.planning/phases/09-mcp-integration/09-02-SUMMARY.md`
</output>
