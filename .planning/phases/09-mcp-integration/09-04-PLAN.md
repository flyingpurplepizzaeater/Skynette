---
phase: 09-mcp-integration
plan: 04
type: execute
wave: 3
depends_on: ["09-02"]
files_modified:
  - src/agent/mcp/sandbox/__init__.py
  - src/agent/mcp/sandbox/docker_sandbox.py
  - src/agent/mcp/sandbox/policy.py
  - src/agent/mcp/client/manager.py
autonomous: true

must_haves:
  truths:
    - "Untrusted MCP servers run in Docker containers with resource limits"
    - "Sandboxed servers have network access restricted based on config"
    - "Sandbox falls back gracefully when Docker is unavailable"
    - "MCPClientManager uses sandbox for USER_ADDED servers with sandbox_enabled=True"
  artifacts:
    - path: "src/agent/mcp/sandbox/docker_sandbox.py"
      provides: "DockerSandbox class for running servers in containers"
      exports: ["DockerSandbox"]
    - path: "src/agent/mcp/sandbox/policy.py"
      provides: "Security policies and resource limits"
      exports: ["SandboxPolicy", "DEFAULT_POLICY"]
  key_links:
    - from: "src/agent/mcp/client/manager.py"
      to: "src/agent/mcp/sandbox/docker_sandbox.py"
      via: "uses sandbox for untrusted servers"
      pattern: "DockerSandbox"
    - from: "src/agent/mcp/sandbox/docker_sandbox.py"
      to: "docker"
      via: "uses docker SDK for container management"
      pattern: "import docker"
---

<objective>
Implement Docker-based sandboxing for untrusted MCP servers to provide process isolation and network restrictions.

Purpose: Per 09-CONTEXT.md, untrusted (USER_ADDED) servers need both process isolation AND network restrictions. This plan implements the sandbox that wraps stdio servers in Docker containers.

Output: DockerSandbox class that runs MCP servers in isolated containers, with configurable resource limits and network policies.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-mcp-integration/09-CONTEXT.md
@.planning/phases/09-mcp-integration/09-RESEARCH.md
@.planning/phases/09-mcp-integration/09-02-SUMMARY.md

# Key files to reference
@src/agent/mcp/models/server.py
@src/agent/mcp/client/manager.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Sandbox Policy Configuration</name>
  <files>
    src/agent/mcp/sandbox/__init__.py
    src/agent/mcp/sandbox/policy.py
  </files>
  <action>
Create the sandbox policy configuration that defines resource limits and security settings.

In `src/agent/mcp/sandbox/policy.py`:

```python
"""Security policies and resource limits for MCP sandboxing."""

from dataclasses import dataclass, field
from typing import Optional


@dataclass
class SandboxPolicy:
    """Configuration for sandbox security and resource limits."""

    # Resource limits
    memory_limit: str = "512m"  # Docker memory limit format
    cpu_quota: int = 50000  # 50% of one CPU (100000 = 100%)
    cpu_period: int = 100000  # microseconds

    # Network settings
    network_enabled: bool = False  # Default to no network for untrusted
    allowed_hosts: list[str] = field(default_factory=list)  # Whitelist for network

    # Filesystem settings
    read_only_root: bool = True  # Read-only container filesystem
    temp_dir_size: str = "100m"  # Size of /tmp

    # Process limits
    pids_limit: int = 50  # Max processes in container

    # Timeout
    startup_timeout_seconds: int = 30
    execution_timeout_seconds: int = 300  # 5 min max per tool call

    # Container settings
    auto_remove: bool = True  # Remove container after stop
    privileged: bool = False  # Never run privileged


# Default policy for USER_ADDED servers
DEFAULT_POLICY = SandboxPolicy(
    memory_limit="512m",
    cpu_quota=50000,
    network_enabled=False,
    read_only_root=True,
)

# Relaxed policy for VERIFIED servers that need network (optional)
VERIFIED_POLICY = SandboxPolicy(
    memory_limit="1g",
    cpu_quota=100000,
    network_enabled=True,
    read_only_root=True,
)


def get_policy_for_trust_level(trust_level: str) -> SandboxPolicy:
    """Get appropriate policy based on trust level."""
    if trust_level == "builtin":
        # Built-in servers don't use sandbox
        return SandboxPolicy(network_enabled=True, read_only_root=False)
    elif trust_level == "verified":
        return VERIFIED_POLICY
    else:  # user_added
        return DEFAULT_POLICY
```

In `src/agent/mcp/sandbox/__init__.py`:
- Export SandboxPolicy, DEFAULT_POLICY, VERIFIED_POLICY, get_policy_for_trust_level
  </action>
  <verify>
```bash
cd C:/Users/karlt/OneDrive/Desktop/Claude/skynette-repo
python -c "
from src.agent.mcp.sandbox.policy import SandboxPolicy, DEFAULT_POLICY, get_policy_for_trust_level

print(f'Default memory: {DEFAULT_POLICY.memory_limit}')
print(f'Default network: {DEFAULT_POLICY.network_enabled}')

user_policy = get_policy_for_trust_level('user_added')
print(f'User-added network enabled: {user_policy.network_enabled}')

verified_policy = get_policy_for_trust_level('verified')
print(f'Verified network enabled: {verified_policy.network_enabled}')
"
```
  </verify>
  <done>
SandboxPolicy dataclass defines resource limits. DEFAULT_POLICY has network disabled. get_policy_for_trust_level returns appropriate policy.
  </done>
</task>

<task type="auto">
  <name>Task 2: Docker Sandbox Implementation</name>
  <files>
    src/agent/mcp/sandbox/docker_sandbox.py
    pyproject.toml
  </files>
  <action>
Create the DockerSandbox class that runs MCP servers in isolated containers.

First, add docker to pyproject.toml dependencies:
- "docker>=7.0.0"

In `src/agent/mcp/sandbox/docker_sandbox.py`:

```python
"""Docker container sandbox for untrusted MCP servers."""

import asyncio
import logging
import shutil
from typing import Optional, Tuple

from src.agent.mcp.models.server import MCPServerConfig
from src.agent.mcp.sandbox.policy import SandboxPolicy, DEFAULT_POLICY

logger = logging.getLogger(__name__)

# Check if Docker is available
DOCKER_AVAILABLE = False
try:
    import docker
    from docker.models.containers import Container
    DOCKER_AVAILABLE = True
except ImportError:
    logger.warning("docker package not installed, sandboxing unavailable")
    Container = None  # type: ignore


class DockerSandbox:
    """
    Docker container sandbox for running untrusted MCP servers.

    Provides process isolation and network restrictions for USER_ADDED servers.
    """

    def __init__(
        self,
        config: MCPServerConfig,
        policy: Optional[SandboxPolicy] = None,
    ):
        """
        Initialize sandbox for an MCP server.

        Args:
            config: Server configuration
            policy: Security policy (defaults to DEFAULT_POLICY)
        """
        self.config = config
        self.policy = policy or DEFAULT_POLICY
        self.container: Optional["Container"] = None
        self._client = None

    @property
    def is_available(self) -> bool:
        """Check if Docker sandboxing is available."""
        if not DOCKER_AVAILABLE:
            return False

        # Check if Docker daemon is running
        try:
            client = docker.from_env()
            client.ping()
            return True
        except Exception:
            return False

    async def start(self) -> Tuple[asyncio.StreamReader, asyncio.StreamWriter]:
        """
        Start the sandboxed server and return stdio streams.

        Returns:
            Tuple of (reader, writer) for communicating with the server.

        Raises:
            RuntimeError: If Docker is unavailable or container fails to start.
        """
        if not self.is_available:
            raise RuntimeError(
                "Docker is not available. Install Docker Desktop or disable sandboxing."
            )

        self._client = docker.from_env()

        # Determine the base image based on server command
        image = self._select_image()

        # Build the command
        cmd = self._build_command()

        logger.info(f"Starting sandboxed container for {self.config.name}")
        logger.debug(f"Image: {image}, Command: {cmd}")

        try:
            # Create container with security restrictions
            self.container = self._client.containers.create(
                image=image,
                command=cmd,
                stdin_open=True,
                tty=False,
                detach=True,
                # Resource limits
                mem_limit=self.policy.memory_limit,
                cpu_quota=self.policy.cpu_quota,
                cpu_period=self.policy.cpu_period,
                pids_limit=self.policy.pids_limit,
                # Network isolation
                network_disabled=not self.policy.network_enabled,
                # Filesystem isolation
                read_only=self.policy.read_only_root,
                # Temp directory
                tmpfs={"/tmp": f"size={self.policy.temp_dir_size}"},
                # Security
                privileged=False,
                cap_drop=["ALL"],  # Drop all capabilities
                security_opt=["no-new-privileges:true"],
                # Environment
                environment=self.config.env,
                # Cleanup
                auto_remove=self.policy.auto_remove,
            )

            # Start the container
            self.container.start()

            # Attach to container stdio
            socket = self.container.attach_socket(
                params={
                    "stdin": True,
                    "stdout": True,
                    "stderr": True,
                    "stream": True,
                }
            )

            # Wrap socket as asyncio streams
            reader, writer = await self._wrap_socket_as_streams(socket)
            return reader, writer

        except Exception as e:
            logger.error(f"Failed to start sandboxed container: {e}")
            await self.stop()
            raise RuntimeError(f"Container startup failed: {e}")

    async def stop(self) -> None:
        """Stop and remove the container."""
        if self.container:
            try:
                self.container.stop(timeout=5)
            except Exception as e:
                logger.warning(f"Error stopping container: {e}")
            try:
                if not self.policy.auto_remove:
                    self.container.remove(force=True)
            except Exception:
                pass  # May already be removed
            self.container = None

    def _select_image(self) -> str:
        """Select Docker image based on server command."""
        cmd = self.config.command or ""

        if cmd in ("node", "npx"):
            return "node:20-slim"
        elif cmd in ("python", "python3", "uvx"):
            return "python:3.11-slim"
        elif cmd in ("deno"):
            return "denoland/deno:latest"
        else:
            # Generic image with common tools
            return "ubuntu:22.04"

    def _build_command(self) -> list[str]:
        """Build the container command."""
        cmd = [self.config.command] if self.config.command else []
        cmd.extend(self.config.args)
        return cmd

    async def _wrap_socket_as_streams(
        self,
        socket,
    ) -> Tuple[asyncio.StreamReader, asyncio.StreamWriter]:
        """Wrap Docker socket as asyncio streams."""
        # Get the raw socket file descriptor
        raw_socket = socket._sock

        loop = asyncio.get_event_loop()

        # Create reader
        reader = asyncio.StreamReader()
        protocol = asyncio.StreamReaderProtocol(reader)

        # Create transport and protocol
        transport, _ = await loop.create_connection(
            lambda: protocol,
            sock=raw_socket,
        )

        # Create writer
        writer = asyncio.StreamWriter(transport, protocol, reader, loop)

        return reader, writer


def is_docker_available() -> bool:
    """Check if Docker is available for sandboxing."""
    if not DOCKER_AVAILABLE:
        return False
    try:
        client = docker.from_env()
        client.ping()
        return True
    except Exception:
        return False
```

Export from __init__.py:
- DockerSandbox, is_docker_available
  </action>
  <verify>
```bash
cd C:/Users/karlt/OneDrive/Desktop/Claude/skynette-repo
pip install "docker>=7.0.0" --quiet 2>/dev/null || echo "Docker package install attempted"
python -c "
from src.agent.mcp.sandbox.docker_sandbox import DockerSandbox, is_docker_available
from src.agent.mcp.models.server import MCPServerConfig, TransportType

# Check if Docker is available (won't fail if not)
available = is_docker_available()
print(f'Docker available: {available}')

# Create sandbox (doesn't start it)
config = MCPServerConfig(
    name='Test',
    transport=TransportType.STDIO,
    command='npx',
    args=['-y', '@modelcontextprotocol/server-fetch'],
)
sandbox = DockerSandbox(config)
print(f'Sandbox created, is_available: {sandbox.is_available}')
print(f'Selected image: {sandbox._select_image()}')
"
```
  </verify>
  <done>
DockerSandbox runs MCP servers in isolated containers with resource limits. Graceful fallback when Docker unavailable. Network disabled by default for untrusted servers.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate Sandbox with Client Manager</name>
  <files>
    src/agent/mcp/client/manager.py
  </files>
  <action>
Update MCPClientManager to use DockerSandbox for untrusted servers.

Add to `src/agent/mcp/client/manager.py`:

1. Add new instance variable in __init__/initialize:
   - `self._sandboxes: dict[str, DockerSandbox] = {}`

2. Update `_connect_stdio` to check for sandbox requirement:

```python
async def _connect_stdio(self, config: MCPServerConfig) -> MCPConnection:
    """Connect via stdio transport, using sandbox for untrusted servers."""
    from mcp import ClientSession
    from mcp.client.stdio import stdio_client, StdioServerParameters
    from src.agent.mcp.sandbox.docker_sandbox import DockerSandbox, is_docker_available
    from src.agent.mcp.sandbox.policy import get_policy_for_trust_level
    from src.agent.mcp.models.trust import TrustLevel

    # Check if sandbox is needed
    use_sandbox = (
        config.sandbox_enabled
        and config.trust_level == TrustLevel.USER_ADDED
    )

    if use_sandbox:
        if not is_docker_available():
            logger.warning(
                f"Docker not available for sandboxing {config.name}. "
                "Running without sandbox (less secure)."
            )
            use_sandbox = False

    if use_sandbox:
        # Start sandboxed server
        policy = get_policy_for_trust_level(config.trust_level.value)
        sandbox = DockerSandbox(config, policy)
        read_stream, write_stream = await sandbox.start()
        self._sandboxes[config.id] = sandbox

        session = await self._exit_stack.enter_async_context(
            ClientSession(read_stream, write_stream)
        )
    else:
        # Direct stdio connection
        server_params = StdioServerParameters(
            command=config.command,
            args=config.args,
            env=config.env or None,
        )

        transport = await self._exit_stack.enter_async_context(
            stdio_client(server_params)
        )
        read_stream, write_stream = transport

        session = await self._exit_stack.enter_async_context(
            ClientSession(read_stream, write_stream)
        )

    await session.initialize()

    return MCPConnection(
        server_id=config.id,
        session=session,
        config=config,
    )
```

3. Update `disconnect` to cleanup sandbox:

```python
async def disconnect(self, server_id: str) -> None:
    """Disconnect from a specific server."""
    # Cleanup sandbox if exists
    if server_id in self._sandboxes:
        await self._sandboxes[server_id].stop()
        del self._sandboxes[server_id]

    if server_id in self._connections:
        del self._connections[server_id]
        logger.info(f"Disconnected from server: {server_id}")
```

4. Update `disconnect_all` to cleanup all sandboxes:

```python
async def disconnect_all(self) -> None:
    """Disconnect from all servers and cleanup."""
    # Stop all sandboxes
    for sandbox in self._sandboxes.values():
        await sandbox.stop()
    self._sandboxes.clear()

    self._connections.clear()
    await self._exit_stack.aclose()
    self._exit_stack = AsyncExitStack()
    logger.info("Disconnected from all MCP servers")
```

5. Add helper method to check sandbox status:

```python
def is_sandboxed(self, server_id: str) -> bool:
    """Check if a server is running in a sandbox."""
    return server_id in self._sandboxes
```
  </action>
  <verify>
```bash
cd C:/Users/karlt/OneDrive/Desktop/Claude/skynette-repo
python -c "
import asyncio
from src.agent.mcp.client.manager import get_mcp_client_manager
from src.agent.mcp.models.server import MCPServerConfig, TransportType
from src.agent.mcp.models.trust import TrustLevel

async def test():
    manager = get_mcp_client_manager()
    await manager.initialize()

    # Create an untrusted server config
    config = MCPServerConfig(
        name='Untrusted Test',
        transport=TransportType.STDIO,
        command='echo',
        args=['test'],
        trust_level=TrustLevel.USER_ADDED,
        sandbox_enabled=True,
    )

    # Don't actually connect (would fail), just verify the code path exists
    print(f'Manager has _sandboxes attr: {hasattr(manager, \"_sandboxes\")}')
    print(f'is_sandboxed method exists: {hasattr(manager, \"is_sandboxed\")}')

    await manager.disconnect_all()
    print('Sandbox integration OK')

asyncio.run(test())
"
```
  </verify>
  <done>
MCPClientManager uses DockerSandbox for USER_ADDED servers with sandbox_enabled=True. Falls back gracefully when Docker unavailable. Sandbox cleanup on disconnect.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Policy configuration works:
```bash
python -c "
from src.agent.mcp.sandbox import SandboxPolicy, DEFAULT_POLICY
from src.agent.mcp.sandbox.policy import get_policy_for_trust_level

assert DEFAULT_POLICY.network_enabled == False
assert get_policy_for_trust_level('user_added').network_enabled == False
assert get_policy_for_trust_level('verified').network_enabled == True
print('Policy configuration OK')
"
```

2. DockerSandbox can be instantiated:
```bash
python -c "
from src.agent.mcp.sandbox import DockerSandbox, is_docker_available
from src.agent.mcp.models.server import MCPServerConfig, TransportType

config = MCPServerConfig(
    name='Test',
    transport=TransportType.STDIO,
    command='node',
    args=['test.js'],
)
sandbox = DockerSandbox(config)
print(f'Image selected: {sandbox._select_image()}')
print(f'Docker available: {is_docker_available()}')
print('DockerSandbox OK')
"
```

3. Manager integration compiles:
```bash
python -c "
import asyncio
from src.agent.mcp.client.manager import MCPClientManager

# Check sandbox methods exist
manager = MCPClientManager()
assert hasattr(manager, 'is_sandboxed')
print('Manager integration OK')
"
```
</verification>

<success_criteria>
- SandboxPolicy defines memory, CPU, network, and filesystem limits
- DEFAULT_POLICY has network disabled for untrusted servers
- DockerSandbox runs MCP servers in containers with restrictions
- is_docker_available() checks Docker daemon status
- MCPClientManager uses sandbox for USER_ADDED + sandbox_enabled=True
- Graceful fallback (warning, no crash) when Docker unavailable
- Sandbox containers are cleaned up on disconnect
</success_criteria>

<output>
After completion, create `.planning/phases/09-mcp-integration/09-04-SUMMARY.md`
</output>
