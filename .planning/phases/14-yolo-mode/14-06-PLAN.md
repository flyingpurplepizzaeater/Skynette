---
phase: 14-yolo-mode
plan: 06
type: execute
wave: 4
depends_on: ["14-01", "14-02", "14-03", "14-04", "14-05"]
files_modified:
  - tests/agent/safety/test_yolo.py
  - tests/agent/safety/test_sandbox.py
autonomous: true

must_haves:
  truths:
    - "Tests verify L5 bypasses all approval requirements"
    - "Tests verify session-only L5 behavior"
    - "Tests verify sandbox detection for common environments"
    - "Tests verify YOLO audit logging enhancements"
  artifacts:
    - path: "tests/agent/safety/test_yolo.py"
      provides: "YOLO mode tests"
      min_lines: 100
    - path: "tests/agent/safety/test_sandbox.py"
      provides: "Sandbox detection tests"
      min_lines: 50
  key_links:
    - from: "tests/agent/safety/test_yolo.py"
      to: "src/agent/safety/classification.py"
      via: "L5 bypass tests"
      pattern: "classify.*L5"
---

<objective>
Create comprehensive tests for YOLO mode functionality.

Purpose: Tests ensure L5 bypass works correctly, session-only behavior prevents accidental persistence, sandbox detection identifies isolated environments, and audit logging captures YOLO context.

Output: Test files covering YOLO classification, session behavior, sandbox detection, and audit enhancements.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/14-yolo-mode/14-RESEARCH.md
@.planning/phases/14-yolo-mode/14-01-SUMMARY.md
@.planning/phases/14-yolo-mode/14-03-SUMMARY.md
@.planning/phases/14-yolo-mode/14-04-SUMMARY.md
@tests/agent/safety/test_autonomy.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create sandbox detection tests</name>
  <files>tests/agent/safety/test_sandbox.py</files>
  <action>
    Create tests for SandboxDetector:

    ```python
    """
    Tests for sandbox detection.
    """

    import os
    from pathlib import Path
    from unittest.mock import patch, MagicMock

    import pytest

    from src.agent.safety.sandbox import SandboxDetector, SandboxInfo


    class TestSandboxDetector:
        """Tests for SandboxDetector.detect()."""

        def test_detect_returns_sandbox_info(self):
            """detect() returns SandboxInfo dataclass."""
            result = SandboxDetector.detect()
            assert isinstance(result, SandboxInfo)
            assert isinstance(result.is_sandboxed, bool)
            assert result.confidence in ("high", "medium", "low")

        def test_detect_docker_via_dockerenv(self):
            """Detects Docker when /.dockerenv exists."""
            with patch.object(Path, "exists", return_value=True):
                # Need to be more specific about which Path.exists
                with patch("src.agent.safety.sandbox.Path") as mock_path:
                    mock_dockerenv = MagicMock()
                    mock_dockerenv.exists.return_value = True
                    mock_path.return_value = mock_dockerenv

                    result = SandboxDetector.detect()
                    assert result.is_sandboxed is True
                    assert result.environment == "docker"
                    assert result.confidence == "high"

        def test_detect_codespaces_env_var(self):
            """Detects GitHub Codespaces via environment variable."""
            with patch.dict(os.environ, {"CODESPACES": "true"}):
                # Mock file checks to return False first
                with patch("src.agent.safety.sandbox.Path") as mock_path:
                    mock_instance = MagicMock()
                    mock_instance.exists.return_value = False
                    mock_path.return_value = mock_instance

                    result = SandboxDetector.detect()
                    assert result.is_sandboxed is True
                    assert result.environment == "codespaces"

        def test_detect_gitpod_env_var(self):
            """Detects Gitpod via GITPOD_WORKSPACE_ID."""
            with patch.dict(os.environ, {"GITPOD_WORKSPACE_ID": "workspace-123"}, clear=False):
                with patch("src.agent.safety.sandbox.Path") as mock_path:
                    mock_instance = MagicMock()
                    mock_instance.exists.return_value = False
                    mock_path.return_value = mock_instance

                    result = SandboxDetector.detect()
                    assert result.is_sandboxed is True
                    assert result.environment == "gitpod"

        def test_detect_devcontainer_env_var(self):
            """Detects VS Code devcontainer via REMOTE_CONTAINERS."""
            with patch.dict(os.environ, {"REMOTE_CONTAINERS": "true"}, clear=False):
                with patch("src.agent.safety.sandbox.Path") as mock_path:
                    mock_instance = MagicMock()
                    mock_instance.exists.return_value = False
                    mock_path.return_value = mock_instance

                    result = SandboxDetector.detect()
                    assert result.is_sandboxed is True
                    assert result.environment == "devcontainer"

        def test_detect_not_sandboxed(self):
            """Returns not sandboxed when no indicators found."""
            # Clear all sandbox env vars
            clean_env = {k: v for k, v in os.environ.items()
                        if k not in ("CODESPACES", "GITPOD_WORKSPACE_ID", "REMOTE_CONTAINERS")}

            with patch.dict(os.environ, clean_env, clear=True):
                with patch("src.agent.safety.sandbox.Path") as mock_path:
                    mock_instance = MagicMock()
                    mock_instance.exists.return_value = False
                    mock_path.return_value = mock_instance

                    with patch("platform.machine", return_value="x86_64"):
                        result = SandboxDetector.detect()
                        assert result.is_sandboxed is False
                        assert result.environment is None
                        assert result.confidence == "high"

        def test_detect_handles_permission_error(self):
            """Gracefully handles PermissionError when reading /proc files."""
            with patch("src.agent.safety.sandbox.Path") as mock_path:
                mock_instance = MagicMock()
                mock_instance.exists.return_value = True
                mock_instance.read_text.side_effect = PermissionError("Access denied")
                mock_path.return_value = mock_instance

                # Should not raise, should continue checking
                result = SandboxDetector.detect()
                assert isinstance(result, SandboxInfo)
    ```
  </action>
  <verify>
    Run: `python -m pytest tests/agent/safety/test_sandbox.py -v --tb=short`
    Expected: All tests pass
  </verify>
  <done>Sandbox detection tests cover Docker, Codespaces, Gitpod, devcontainer scenarios</done>
</task>

<task type="auto">
  <name>Task 2: Create YOLO mode tests</name>
  <files>tests/agent/safety/test_yolo.py</files>
  <action>
    Create comprehensive tests for YOLO (L5) mode:

    ```python
    """
    Tests for YOLO (L5) mode functionality.
    """

    import gc
    import json
    import tempfile
    from pathlib import Path

    import pytest

    from src.agent.safety.autonomy import (
        AutonomyLevel,
        AutonomyLevelService,
        AutonomySettings,
        AUTONOMY_THRESHOLDS,
        AUTONOMY_LABELS,
        AUTONOMY_COLORS,
    )
    from src.agent.safety.classification import ActionClassifier
    from src.agent.safety.audit import AuditStore, AuditEntry


    class TestL5AutonomyLevel:
        """Tests for L5 autonomy level types and constants."""

        def test_l5_in_thresholds(self):
            """L5 exists in AUTONOMY_THRESHOLDS."""
            assert "L5" in AUTONOMY_THRESHOLDS

        def test_l5_auto_executes_all_risk_levels(self):
            """L5 threshold includes all risk levels."""
            l5_threshold = AUTONOMY_THRESHOLDS["L5"]
            assert "safe" in l5_threshold
            assert "moderate" in l5_threshold
            assert "destructive" in l5_threshold
            assert "critical" in l5_threshold

        def test_l5_has_yolo_label(self):
            """L5 has 'YOLO' label."""
            assert AUTONOMY_LABELS["L5"] == "YOLO"

        def test_l5_has_purple_color(self):
            """L5 has purple color (#8B5CF6)."""
            assert AUTONOMY_COLORS["L5"] == "#8B5CF6"

        def test_autonomy_settings_l5_auto_executes(self):
            """AutonomySettings with L5 auto-executes all risk levels."""
            settings = AutonomySettings(level="L5")
            assert settings.auto_executes("safe") is True
            assert settings.auto_executes("moderate") is True
            assert settings.auto_executes("destructive") is True
            assert settings.auto_executes("critical") is True


    class TestL5Classification:
        """Tests for L5 classification bypass."""

        def test_l5_bypasses_approval_for_safe(self):
            """L5 does not require approval for safe actions."""
            class MockService:
                def get_settings(self, p): return AutonomySettings(level="L5")

            classifier = ActionClassifier(autonomy_service=MockService())
            result = classifier.classify("web_search", {})
            assert result.requires_approval is False

        def test_l5_bypasses_approval_for_moderate(self):
            """L5 does not require approval for moderate actions."""
            class MockService:
                def get_settings(self, p): return AutonomySettings(level="L5")

            classifier = ActionClassifier(autonomy_service=MockService())
            result = classifier.classify("browser", {"url": "http://test.com"})
            assert result.requires_approval is False

        def test_l5_bypasses_approval_for_destructive(self):
            """L5 does not require approval for destructive actions."""
            class MockService:
                def get_settings(self, p): return AutonomySettings(level="L5")

            classifier = ActionClassifier(autonomy_service=MockService())
            result = classifier.classify("file_write", {"path": "/tmp/test"})
            assert result.requires_approval is False

        def test_l5_bypasses_approval_for_critical(self):
            """L5 does not require approval for critical actions."""
            class MockService:
                def get_settings(self, p): return AutonomySettings(level="L5")

            classifier = ActionClassifier(autonomy_service=MockService())
            result = classifier.classify("file_delete", {"path": "/important"})
            assert result.requires_approval is False

        def test_l5_bypasses_blocklist_rules(self):
            """L5 ignores blocklist rules (true YOLO)."""
            class MockService:
                def get_settings(self, p):
                    return AutonomySettings(
                        level="L5",
                        blocklist_rules=[{"tools": ["*"], "paths": ["*"]}]
                    )

            classifier = ActionClassifier(autonomy_service=MockService())
            result = classifier.classify("file_delete", {"path": "/blocked"})
            # L5 should bypass the blocklist
            assert result.requires_approval is False


    class TestL5SessionBehavior:
        """Tests for session-only L5 behavior."""

        def test_l5_tracked_in_session(self):
            """L5 is tracked in session projects set."""
            svc = AutonomyLevelService()
            path = tempfile.mkdtemp()

            svc.set_level(path, "L5")
            assert svc.is_yolo_active(path) is True

        def test_l5_returns_l5_settings(self):
            """get_settings returns L5 for session YOLO projects."""
            svc = AutonomyLevelService()
            path = tempfile.mkdtemp()

            svc.set_level(path, "L5")
            settings = svc.get_settings(path)
            assert settings.level == "L5"

        def test_downgrade_from_l5_clears_session(self):
            """Downgrading from L5 removes session tracking."""
            svc = AutonomyLevelService()
            path = tempfile.mkdtemp()

            svc.set_level(path, "L5")
            assert svc.is_yolo_active(path) is True

            svc.set_level(path, "L2")
            assert svc.is_yolo_active(path) is False

        def test_is_yolo_active_returns_false_for_none_path(self):
            """is_yolo_active returns False for None path."""
            svc = AutonomyLevelService()
            assert svc.is_yolo_active(None) is False

        def test_l4_is_not_yolo(self):
            """L4 is not tracked as YOLO."""
            svc = AutonomyLevelService()
            path = tempfile.mkdtemp()

            svc.set_level(path, "L4")
            assert svc.is_yolo_active(path) is False


    class TestYoloAuditLogging:
        """Tests for YOLO audit logging enhancements."""

        def setup_method(self):
            """Create temp database for each test."""
            self.db_file = tempfile.NamedTemporaryFile(suffix=".db", delete=False)
            self.db_path = self.db_file.name
            self.db_file.close()
            self.store = AuditStore(db_path=self.db_path)

        def teardown_method(self):
            """Clean up temp database."""
            del self.store
            gc.collect()
            try:
                Path(self.db_path).unlink()
            except PermissionError:
                pass  # Windows cleanup handling

        def test_audit_entry_has_yolo_mode_field(self):
            """AuditEntry has yolo_mode field."""
            entry = AuditEntry(
                session_id="test",
                step_id="step1",
                tool_name="test",
                risk_level="safe",
                yolo_mode=True,
            )
            assert entry.yolo_mode is True

        def test_yolo_entry_stored_with_flag(self):
            """YOLO entries persist yolo_mode flag."""
            entry = AuditEntry(
                session_id="yolo-session",
                step_id="step1",
                tool_name="file_delete",
                risk_level="critical",
                yolo_mode=True,
                parameters={"path": "/test"},
            )
            self.store.log(entry)

            entries = self.store.query(session_id="yolo-session")
            assert len(entries) == 1
            assert entries[0].yolo_mode is True

        def test_yolo_entry_stores_full_parameters(self):
            """YOLO entries store full_parameters without truncation."""
            # Create large parameters that would normally be truncated
            large_content = "x" * 10000  # 10KB, larger than 4KB limit
            entry = AuditEntry(
                session_id="yolo-full",
                step_id="step1",
                tool_name="file_write",
                risk_level="destructive",
                yolo_mode=True,
                parameters={"path": "/test", "content": large_content},
            )
            self.store.log(entry)

            entries = self.store.query(session_id="yolo-full")
            assert len(entries) == 1
            assert entries[0].full_parameters is not None
            # Full parameters should contain the full content
            full_params = json.loads(entries[0].full_parameters)
            assert len(full_params.get("content", "")) == 10000

        def test_non_yolo_entry_no_full_parameters(self):
            """Non-YOLO entries don't store full_parameters."""
            entry = AuditEntry(
                session_id="normal-session",
                step_id="step1",
                tool_name="file_write",
                risk_level="destructive",
                yolo_mode=False,
                parameters={"path": "/test"},
            )
            self.store.log(entry)

            entries = self.store.query(session_id="normal-session")
            assert len(entries) == 1
            assert entries[0].full_parameters is None

        def test_yolo_retention_constant_exists(self):
            """AuditStore has YOLO_RETENTION_DAYS constant."""
            assert hasattr(AuditStore, "YOLO_RETENTION_DAYS")
            assert AuditStore.YOLO_RETENTION_DAYS > AuditStore.DEFAULT_RETENTION_DAYS
    ```
  </action>
  <verify>
    Run: `python -m pytest tests/agent/safety/test_yolo.py -v --tb=short`
    Expected: All tests pass
  </verify>
  <done>YOLO tests cover L5 classification bypass, session behavior, and audit enhancements</done>
</task>

</tasks>

<verification>
- `python -m pytest tests/agent/safety/test_sandbox.py -v` passes
- `python -m pytest tests/agent/safety/test_yolo.py -v` passes
- Tests cover L5 threshold (all risk levels auto-execute)
- Tests cover L5 classification bypass (no approvals)
- Tests cover session-only behavior (is_yolo_active)
- Tests cover audit yolo_mode and full_parameters
- Tests cover sandbox detection for various environments
</verification>

<success_criteria>
- All tests pass without errors
- Tests verify L5 auto-executes all risk levels
- Tests verify L5 bypasses blocklist rules
- Tests verify session-only behavior
- Tests verify YOLO audit enhancements
- Tests verify sandbox detection heuristics
</success_criteria>

<output>
After completion, create `.planning/phases/14-yolo-mode/14-06-SUMMARY.md`
</output>
