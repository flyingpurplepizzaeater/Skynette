---
phase: 15-approval-flow-wiring
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/agent/safety/approval.py
  - tests/agent/test_safety_e2e.py
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "ApprovalManager has resolve() method callable from UI"
    - "resolve('approved', ...) completes approval flow without error"
    - "resolve('rejected', ...) completes rejection flow without error"
    - "resolve('timeout', ...) handles timeout gracefully"
  artifacts:
    - path: "src/agent/safety/approval.py"
      provides: "ApprovalManager with resolve() method"
      contains: "def resolve(self, request_id: str, decision: str"
    - path: "tests/agent/test_safety_e2e.py"
      provides: "E2E test for resolve() method"
      contains: "test_resolve_method_routes_decisions"
  key_links:
    - from: "src/ui/views/agents.py"
      to: "ApprovalManager.resolve()"
      via: "callback functions in approval UI"
      pattern: "approval_manager\\.resolve\\("
    - from: "ApprovalManager.resolve()"
      to: "ApprovalManager.approve()/reject()"
      via: "decision routing"
      pattern: "self\\.approve\\(|self\\.reject\\("
---

<objective>
Add the missing resolve() method to ApprovalManager and verify the approval flow works end-to-end.

Purpose: The UI code in agents.py calls approval_manager.resolve() to complete approval decisions, but this method does not exist. This breaks the human-in-the-loop approval workflow (SAFE-02). Adding resolve() as a router to approve()/reject() closes this integration gap.

Output: ApprovalManager with working resolve() method, E2E test confirming the flow works.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/v3.0-MILESTONE-AUDIT.md
@src/agent/safety/approval.py
@src/ui/views/agents.py (lines 380-420 for resolve() calls)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add resolve() method to ApprovalManager</name>
  <files>src/agent/safety/approval.py</files>
  <action>
    Add the resolve() method to ApprovalManager class (after the reject() method, around line 195):

    ```python
    def resolve(self, request_id: str, decision: str, approve_similar: bool = False) -> None:
        """
        Resolve an approval request with a decision.

        This is the primary method called by UI callbacks to complete the approval flow.
        Routes to approve() or reject() based on decision string.

        Args:
            request_id: ID of the request to resolve
            decision: One of "approved", "rejected", or "timeout"
            approve_similar: If True and approved, auto-approve similar future actions
        """
        if decision == "approved":
            self.approve(request_id, approve_similar)
        elif decision == "rejected":
            self.reject(request_id)
        elif decision == "timeout":
            # Timeout is treated as rejection - user didn't approve
            self.reject(request_id)
        else:
            logger.warning(f"Unknown approval decision '{decision}' for request {request_id}")
    ```

    Note: The method signature matches exactly what agents.py expects:
    - Line 387: `approval_manager.resolve(request.id, decision="approved", approve_similar=approve_similar)`
    - Line 396: `approval_manager.resolve(request.id, decision="rejected")`
    - Line 420: `approval_manager.resolve(request.id, decision="timeout")`
  </action>
  <verify>
    Run: `python -c "from src.agent.safety.approval import ApprovalManager; m = ApprovalManager(); print(hasattr(m, 'resolve')); print(callable(m.resolve))"`
    Expected: True, True
  </verify>
  <done>ApprovalManager.resolve() method exists and is callable</done>
</task>

<task type="auto">
  <name>Task 2: Add E2E test for resolve() method</name>
  <files>tests/agent/test_safety_e2e.py</files>
  <action>
    Add a new test to the TestApprovalFlowE2E class in tests/agent/test_safety_e2e.py.
    Insert after the test_rejection_stops_action method (around line 208):

    ```python
    @pytest.mark.asyncio
    async def test_resolve_method_routes_decisions(self):
        """Test that resolve() correctly routes to approve/reject."""
        manager = ApprovalManager()
        manager.start_session("test-session")

        # Test 1: resolve with "approved" decision
        c1 = ActionClassification(
            risk_level="destructive",
            reason="Test approval",
            requires_approval=True,
            tool_name="file_write",
            parameters={"path": "/tmp/test1.txt"},
        )

        async def resolve_approved():
            await asyncio.sleep(0.1)
            pending = manager.get_pending()
            assert len(pending) == 1
            # Use resolve() instead of approve() directly
            manager.resolve(pending[0].id, decision="approved", approve_similar=False)

        task = asyncio.create_task(resolve_approved())
        result1 = await manager.request_approval(c1, "step-1", timeout=5.0)
        await task

        assert result1.decision == "approved"

        # Test 2: resolve with "rejected" decision
        manager.start_session("test-session-2")  # Fresh session
        c2 = ActionClassification(
            risk_level="critical",
            reason="Test rejection",
            requires_approval=True,
            tool_name="file_delete",
            parameters={"path": "/tmp/test2.txt"},
        )

        async def resolve_rejected():
            await asyncio.sleep(0.1)
            pending = manager.get_pending()
            manager.resolve(pending[0].id, decision="rejected")

        task = asyncio.create_task(resolve_rejected())
        result2 = await manager.request_approval(c2, "step-2", timeout=5.0)
        await task

        assert result2.decision == "rejected"

        # Test 3: resolve with "timeout" decision (should be treated as rejection)
        manager.start_session("test-session-3")
        c3 = ActionClassification(
            risk_level="destructive",
            reason="Test timeout",
            requires_approval=True,
            tool_name="file_write",
            parameters={"path": "/tmp/test3.txt"},
        )

        async def resolve_timeout():
            await asyncio.sleep(0.1)
            pending = manager.get_pending()
            manager.resolve(pending[0].id, decision="timeout")

        task = asyncio.create_task(resolve_timeout())
        result3 = await manager.request_approval(c3, "step-3", timeout=5.0)
        await task

        assert result3.decision == "rejected"  # timeout routes to reject

    @pytest.mark.asyncio
    async def test_resolve_with_approve_similar(self):
        """Test that resolve() with approve_similar enables similarity caching."""
        manager = ApprovalManager()
        manager.start_session("test-session")

        # First action - resolve with approve_similar=True
        c1 = ActionClassification(
            risk_level="destructive",
            reason="Write file",
            requires_approval=True,
            tool_name="file_write",
            parameters={"path": "/src/test1.py"},
        )

        async def resolve_with_similar():
            await asyncio.sleep(0.1)
            pending = manager.get_pending()
            manager.resolve(pending[0].id, decision="approved", approve_similar=True)

        task = asyncio.create_task(resolve_with_similar())
        result1 = await manager.request_approval(c1, "step-1", timeout=5.0)
        await task

        assert result1.decision == "approved"
        assert result1.approve_similar == True

        # Second similar action - should auto-approve via similarity cache
        c2 = ActionClassification(
            risk_level="destructive",
            reason="Write file",
            requires_approval=True,
            tool_name="file_write",
            parameters={"path": "/src/test2.py"},  # Same parent directory
        )

        result2 = await manager.request_approval(c2, "step-2", timeout=1.0)
        assert result2.decision == "approved"
        assert result2.decided_by == "similar_match"
    ```

    This tests:
    1. resolve("approved") correctly approves the request
    2. resolve("rejected") correctly rejects the request
    3. resolve("timeout") routes to rejection
    4. resolve() with approve_similar=True enables similarity caching
  </action>
  <verify>
    Run: `python -m pytest tests/agent/test_safety_e2e.py::TestApprovalFlowE2E::test_resolve_method_routes_decisions tests/agent/test_safety_e2e.py::TestApprovalFlowE2E::test_resolve_with_approve_similar -v`
    Expected: Both tests pass
  </verify>
  <done>E2E tests confirm resolve() routes decisions correctly and similarity caching works</done>
</task>

<task type="auto">
  <name>Task 3: Verify full approval flow works</name>
  <files>src/ui/views/agents.py, src/agent/safety/approval.py</files>
  <action>
    Verify the integration by checking that:
    1. agents.py imports can resolve ApprovalManager
    2. The resolve() signature matches all call sites

    Run a quick integration verification:
    ```python
    # Verify the actual call patterns in agents.py work
    from src.agent.safety.approval import ApprovalManager
    from src.agent.safety.classification import ActionClassification

    # Simulate what agents.py does
    manager = ApprovalManager()
    manager.start_session("test")

    # Create a mock pending request
    classification = ActionClassification(
        risk_level="destructive",
        reason="Test",
        requires_approval=True,
        tool_name="file_write",
        parameters={}
    )

    import asyncio

    async def test_flow():
        # Start request in background
        async def make_request():
            return await manager.request_approval(classification, "step-1", timeout=2.0)

        task = asyncio.create_task(make_request())
        await asyncio.sleep(0.1)

        # Get pending and resolve (mimics agents.py callback)
        pending = manager.get_pending()
        request = pending[0]

        # These are the exact patterns from agents.py
        manager.resolve(request.id, decision="approved", approve_similar=False)

        result = await task
        print(f"Flow completed: {result.decision}")
        return result.decision == "approved"

    success = asyncio.run(test_flow())
    print(f"Integration verified: {success}")
    ```
  </action>
  <verify>
    Run: `python -m pytest tests/agent/test_safety_e2e.py -v --tb=short`
    Expected: All tests pass, no AttributeError for resolve()
  </verify>
  <done>Full approval flow works without AttributeError</done>
</task>

</tasks>

<verification>
- `python -c "from src.agent.safety.approval import ApprovalManager; m = ApprovalManager(); m.resolve"` succeeds (method exists)
- `python -m pytest tests/agent/test_safety_e2e.py::TestApprovalFlowE2E -v` passes (all approval tests pass)
- `python -c "from src.ui.views.agents import AgentsView"` succeeds (no import errors)
- No AttributeError when calling resolve() from UI callbacks
</verification>

<success_criteria>
- ApprovalManager.resolve() method exists and routes to approve()/reject()
- resolve("approved", ...) completes without error
- resolve("rejected", ...) completes without error
- resolve("timeout", ...) is handled (routes to rejection)
- E2E test confirms the approval flow works end-to-end
- agents.py approval callbacks can complete successfully
</success_criteria>

<output>
After completion, create `.planning/phases/15-approval-flow-wiring/15-01-SUMMARY.md`
</output>
