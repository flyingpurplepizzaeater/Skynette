---
phase: 03-code-editor-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/__init__.py
  - src/services/editor/__init__.py
  - src/services/editor/highlighter.py
  - src/services/editor/file_service.py
  - src/services/editor/file_icons.py
autonomous: true

must_haves:
  truths:
    - "Code can be tokenized and colored by language"
    - "Files can be read and written asynchronously"
    - "File extensions map to appropriate icons"
  artifacts:
    - path: "src/services/editor/highlighter.py"
      provides: "PygmentsHighlighter service"
      exports: ["PygmentsHighlighter"]
    - path: "src/services/editor/file_service.py"
      provides: "Async file I/O operations"
      exports: ["FileService"]
    - path: "src/services/editor/file_icons.py"
      provides: "Extension to icon mapping"
      exports: ["get_file_icon", "LANGUAGE_ICONS"]
  key_links:
    - from: "src/services/editor/highlighter.py"
      to: "pygments"
      via: "lexer lookup and tokenization"
      pattern: "get_lexer_by_name|get_lexer_for_filename"
    - from: "src/services/editor/file_service.py"
      to: "aiofiles"
      via: "async file operations"
      pattern: "aiofiles\\.open"
---

<objective>
Create core editor services: Pygments-based syntax highlighting, async file I/O, and file icon mapping.

Purpose: Establish the foundational services that all editor UI components will depend on. These are pure Python services with no Flet dependencies, enabling easy testing and reuse.

Output: Three service modules under `src/services/editor/` ready for use by UI components.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-code-editor-core/03-RESEARCH.md

# Existing patterns
@src/ui/views/ai_hub/state.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PygmentsHighlighter service</name>
  <files>
    - src/services/__init__.py
    - src/services/editor/__init__.py
    - src/services/editor/highlighter.py
  </files>
  <action>
Create the services directory structure and PygmentsHighlighter service.

1. Create `src/services/__init__.py` (empty, for package recognition)
2. Create `src/services/editor/__init__.py` with exports
3. Create `src/services/editor/highlighter.py`:

```python
class PygmentsHighlighter:
    """Convert code to Flet TextSpans with syntax highlighting."""

    # GitHub Dark theme color mapping
    TOKEN_COLORS = {
        Token.Keyword: "#ff7b72",
        Token.Keyword.Constant: "#79c0ff",
        Token.Name.Function: "#d2a8ff",
        Token.Name.Class: "#f0883e",
        Token.String: "#a5d6ff",
        Token.Comment: "#8b949e",
        Token.Number: "#79c0ff",
        Token.Operator: "#ff7b72",
        Token.Punctuation: "#c9d1d9",
        Token.Name.Builtin: "#ffa657",
    }
    DEFAULT_COLOR = "#c9d1d9"

    def highlight(self, code: str, language: str) -> list[ft.TextSpan]:
        """Convert code to list of styled TextSpans."""

    def get_language_from_filename(self, filename: str) -> str:
        """Detect language from filename extension."""

    def _get_color_for_token(self, token_type) -> str:
        """Get color for token type, checking parent types."""
```

Use `pygments.lexers.get_lexer_by_name()` and `get_lexer_for_filename()` for lexer lookup.
Use `pygments.lex()` for tokenization.
Handle unknown languages gracefully by returning unstyled text.
  </action>
  <verify>
```bash
python -c "from src.services.editor import PygmentsHighlighter; h = PygmentsHighlighter(); spans = h.highlight('def foo(): pass', 'python'); print(f'Generated {len(spans)} spans')"
```
Should output "Generated N spans" where N > 1.
  </verify>
  <done>PygmentsHighlighter can tokenize Python code and return Flet TextSpans with colors</done>
</task>

<task type="auto">
  <name>Task 2: Create FileService for async I/O</name>
  <files>src/services/editor/file_service.py</files>
  <action>
Create async file service using aiofiles and pathlib.

```python
import aiofiles
from pathlib import Path
from dataclasses import dataclass

@dataclass
class FileInfo:
    path: str
    name: str
    is_dir: bool
    size: int
    extension: str

class FileService:
    """Async file operations for the code editor."""

    MAX_FILE_SIZE = 500_000  # 500KB limit
    WARN_FILE_SIZE = 50_000   # 50KB warning threshold

    async def read_file(self, path: str) -> str:
        """Read file content. Raises ValueError if too large."""

    async def write_file(self, path: str, content: str) -> None:
        """Write content to file."""

    async def create_file(self, path: str, content: str = "") -> None:
        """Create new file. Raises FileExistsError if exists."""

    async def delete_file(self, path: str) -> None:
        """Delete file."""

    def list_directory(self, path: str) -> list[FileInfo]:
        """List directory contents sorted (folders first, then by name)."""

    def get_file_size(self, path: str) -> int:
        """Get file size in bytes."""

    def file_exists(self, path: str) -> bool:
        """Check if file exists."""
```

Include docstrings explaining the file size limits.
Use pathlib.Path for all path operations.
Sort directory listings: directories first, then files, both alphabetically.
  </action>
  <verify>
```bash
python -c "import asyncio; from src.services.editor import FileService; fs = FileService(); print(f'Exists: {fs.file_exists(\"src/main.py\")}')"
```
Should output "Exists: True".
  </verify>
  <done>FileService provides async read/write/create/delete and sync directory listing</done>
</task>

<task type="auto">
  <name>Task 3: Create file icons mapping</name>
  <files>src/services/editor/file_icons.py</files>
  <action>
Create file extension to Flet icon mapping.

```python
import flet as ft

# Map file extensions to Flet icons
LANGUAGE_ICONS: dict[str, str] = {
    # Python
    ".py": ft.Icons.CODE,
    ".pyw": ft.Icons.CODE,
    ".pyi": ft.Icons.CODE,

    # JavaScript/TypeScript
    ".js": ft.Icons.JAVASCRIPT,
    ".jsx": ft.Icons.JAVASCRIPT,
    ".ts": ft.Icons.JAVASCRIPT,
    ".tsx": ft.Icons.JAVASCRIPT,

    # Web
    ".html": ft.Icons.HTML,
    ".htm": ft.Icons.HTML,
    ".css": ft.Icons.CSS,

    # Data
    ".json": ft.Icons.DATA_OBJECT,
    ".yaml": ft.Icons.DATA_OBJECT,
    ".yml": ft.Icons.DATA_OBJECT,
    ".xml": ft.Icons.DATA_OBJECT,
    ".toml": ft.Icons.DATA_OBJECT,

    # Markdown/Text
    ".md": ft.Icons.DESCRIPTION,
    ".txt": ft.Icons.DESCRIPTION,
    ".rst": ft.Icons.DESCRIPTION,

    # Config
    ".ini": ft.Icons.SETTINGS,
    ".cfg": ft.Icons.SETTINGS,
    ".conf": ft.Icons.SETTINGS,
    ".env": ft.Icons.SETTINGS,

    # Shell
    ".sh": ft.Icons.TERMINAL,
    ".bash": ft.Icons.TERMINAL,
    ".zsh": ft.Icons.TERMINAL,
    ".ps1": ft.Icons.TERMINAL,
    ".bat": ft.Icons.TERMINAL,
    ".cmd": ft.Icons.TERMINAL,

    # Images
    ".png": ft.Icons.IMAGE,
    ".jpg": ft.Icons.IMAGE,
    ".jpeg": ft.Icons.IMAGE,
    ".gif": ft.Icons.IMAGE,
    ".svg": ft.Icons.IMAGE,
    ".ico": ft.Icons.IMAGE,
}

DEFAULT_FILE_ICON = ft.Icons.INSERT_DRIVE_FILE
FOLDER_ICON = ft.Icons.FOLDER
FOLDER_OPEN_ICON = ft.Icons.FOLDER_OPEN

def get_file_icon(filename: str, is_dir: bool = False, is_expanded: bool = False) -> str:
    """Get appropriate icon for file or folder."""
```

Cover common programming languages, data formats, and config files.
Use Flet's built-in icon constants (ft.Icons.*).
  </action>
  <verify>
```bash
python -c "from src.services.editor import get_file_icon; print(get_file_icon('test.py')); print(get_file_icon('folder', is_dir=True))"
```
Should output two icon names (non-empty strings).
  </verify>
  <done>File icons module maps 30+ extensions to appropriate icons with folder support</done>
</task>

</tasks>

<verification>
All three services import correctly:
```bash
python -c "from src.services.editor import PygmentsHighlighter, FileService, get_file_icon; print('All imports successful')"
```

Highlighter produces colored output:
```bash
python -c "from src.services.editor import PygmentsHighlighter; h = PygmentsHighlighter(); spans = h.highlight('x = 1', 'python'); colors = set(s.style.color for s in spans if s.style); print(f'Colors: {len(colors)} distinct')"
```
Should show multiple distinct colors.
</verification>

<success_criteria>
- PygmentsHighlighter tokenizes code and returns Flet TextSpans with syntax colors
- FileService provides async file operations with size limits
- File icons mapping covers common extensions
- All services are importable from `src.services.editor`
- No Flet UI rendering required (pure Python services)
</success_criteria>

<output>
After completion, create `.planning/phases/03-code-editor-core/03-01-SUMMARY.md`
</output>
