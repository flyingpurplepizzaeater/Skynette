---
phase: 03-code-editor-core
plan: 05
type: execute
wave: 4
depends_on: ["03-04"]
files_modified:
  - src/ui/views/code_editor/state.py
  - src/ui/views/code_editor/editor.py
  - src/ui/views/code_editor/file_tree.py
  - src/ui/views/code_editor/__init__.py
  - tests/unit/test_editor_services.py
  - tests/unit/test_editor_state.py
  - tests/unit/test_editor_components.py
autonomous: true

must_haves:
  truths:
    - "Components have dispose methods that clean up resources"
    - "State listeners are removed when components are destroyed"
    - "Unit tests cover highlighter, file service, and state"
    - "Tests pass without launching Flet UI"
  artifacts:
    - path: "tests/unit/test_editor_services.py"
      provides: "Tests for highlighter and file service"
      contains: "test_"
    - path: "tests/unit/test_editor_state.py"
      provides: "Tests for EditorState"
      contains: "test_"
    - path: "tests/unit/test_editor_components.py"
      provides: "Tests for component construction"
      contains: "test_"
  key_links:
    - from: "src/ui/views/code_editor/__init__.py"
      to: "dispose pattern"
      via: "dispose method removes listeners"
      pattern: "def dispose.*remove_listener"
    - from: "tests/unit/test_editor_services.py"
      to: "src/services/editor/highlighter.py"
      via: "import and test"
      pattern: "from src.services.editor import"
---

<objective>
Add resource disposal to all editor components and create comprehensive unit tests.

Purpose: Ensure memory leaks are prevented when tabs are closed and the view is navigated away from. Unit tests verify service logic and state management without requiring Flet UI.

Output: Dispose methods on all components, 30+ unit tests covering services and state.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-code-editor-core/03-RESEARCH.md
@.planning/phases/03-code-editor-core/03-04-SUMMARY.md

# Existing test patterns
@tests/unit/test_ai_hub_refactor.py

# Components to update
@src/ui/views/code_editor/__init__.py
@src/ui/views/code_editor/state.py
@src/ui/views/code_editor/editor.py
@src/ui/views/code_editor/file_tree.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dispose methods to all editor components</name>
  <files>
    - src/ui/views/code_editor/state.py
    - src/ui/views/code_editor/editor.py
    - src/ui/views/code_editor/file_tree.py
    - src/ui/views/code_editor/__init__.py
  </files>
  <action>
Add dispose() methods to clean up resources when components are destroyed.

**1. Update `EditorState` in state.py:**

Add method:
```python
def dispose(self) -> None:
    """Clear all state and listeners."""
    self._listeners.clear()
    self.open_files.clear()
    self.active_file_index = -1
```

**2. Update `CodeEditor` in editor.py:**

Add method:
```python
def dispose(self) -> None:
    """Clean up editor resources."""
    self._text_field = None
    self._line_numbers = None
    self._highlighted_text = None
```

**3. Update `FileTree` in file_tree.py:**

Add method:
```python
def dispose(self) -> None:
    """Clean up file tree resources."""
    self.items.clear()
    self.expanded_paths.clear()
```

**4. Update `CodeEditorView` in __init__.py:**

Ensure dispose() is called on navigation away. Update the existing dispose method:
```python
def dispose(self) -> None:
    """Clean up all resources when view is destroyed."""
    # Remove state listener
    self.state.remove_listener(self._on_state_change)

    # Dispose child components
    if self._editor:
        self._editor.dispose()
    if self._file_tree:
        self._file_tree.dispose()

    # Clear state
    self.state.dispose()

    # Clear component references
    self._toolbar = None
    self._tab_bar = None
    self._file_tree = None
    self._editor = None
    self._split_panel = None
```

Also add lifecycle hook in app.py navigation to call dispose on view switch:
```python
# In _navigate_to(), before switching views:
if hasattr(self.content_area.content, 'dispose'):
    self.content_area.content.dispose()
```
  </action>
  <verify>
```bash
python -c "
from src.ui.views.code_editor.state import EditorState
state = EditorState()
state.add_listener(lambda: None)
print(f'Listeners before: {len(state._listeners)}')
state.dispose()
print(f'Listeners after: {len(state._listeners)}')
"
```
Should output "Listeners before: 1" then "Listeners after: 0".
  </verify>
  <done>All editor components have dispose() methods that clean up resources</done>
</task>

<task type="auto">
  <name>Task 2: Create unit tests for editor services</name>
  <files>tests/unit/test_editor_services.py</files>
  <action>
Create tests for PygmentsHighlighter and FileService.

```python
"""Unit tests for code editor services."""

import pytest
import tempfile
import os
from pathlib import Path

from src.services.editor import (
    PygmentsHighlighter,
    FileService,
    get_file_icon,
    LANGUAGE_ICONS,
    FOLDER_ICON,
)


class TestPygmentsHighlighter:
    """Tests for syntax highlighting service."""

    def setup_method(self):
        self.highlighter = PygmentsHighlighter()

    def test_highlight_python_returns_spans(self):
        """Highlighting Python code returns multiple TextSpans."""
        code = "def hello():\n    print('world')"
        spans = self.highlighter.highlight(code, "python")
        assert len(spans) > 1
        assert all(hasattr(s, 'text') for s in spans)

    def test_highlight_unknown_language_returns_unstyled(self):
        """Unknown language returns single unstyled span."""
        code = "some random text"
        spans = self.highlighter.highlight(code, "not_a_language")
        assert len(spans) == 1
        assert spans[0].text == code

    def test_highlight_empty_string(self):
        """Empty string returns empty list or single empty span."""
        spans = self.highlighter.highlight("", "python")
        # Should handle gracefully
        assert isinstance(spans, list)

    def test_highlight_javascript(self):
        """JavaScript code is highlighted."""
        code = "const x = () => { return 42; };"
        spans = self.highlighter.highlight(code, "javascript")
        assert len(spans) > 1

    def test_get_language_from_filename_python(self):
        """Python files detected correctly."""
        assert self.highlighter.get_language_from_filename("test.py") == "python"

    def test_get_language_from_filename_javascript(self):
        """JavaScript files detected correctly."""
        lang = self.highlighter.get_language_from_filename("app.js")
        assert lang in ("javascript", "js")

    def test_get_language_from_filename_unknown(self):
        """Unknown extension returns text."""
        lang = self.highlighter.get_language_from_filename("file.xyz123")
        assert lang == "text"

    def test_token_colors_are_hex(self):
        """Token colors are valid hex color codes."""
        for token, color in PygmentsHighlighter.TOKEN_COLORS.items():
            assert color.startswith("#")
            assert len(color) == 7  # #RRGGBB


class TestFileService:
    """Tests for file I/O service."""

    def setup_method(self):
        self.service = FileService()

    def test_file_exists_true(self):
        """Existing file returns True."""
        # Use this test file itself
        assert self.service.file_exists(__file__)

    def test_file_exists_false(self):
        """Non-existent file returns False."""
        assert not self.service.file_exists("/nonexistent/path/file.txt")

    def test_get_file_size(self):
        """File size returns positive integer for existing file."""
        size = self.service.get_file_size(__file__)
        assert size > 0

    def test_list_directory_returns_fileinfo(self):
        """List directory returns FileInfo objects."""
        entries = self.service.list_directory(os.path.dirname(__file__))
        assert len(entries) > 0
        assert all(hasattr(e, 'name') for e in entries)
        assert all(hasattr(e, 'is_dir') for e in entries)

    def test_list_directory_sorts_folders_first(self):
        """Directories appear before files."""
        with tempfile.TemporaryDirectory() as tmpdir:
            # Create a file and a folder
            Path(tmpdir, "aaa_file.txt").touch()
            Path(tmpdir, "zzz_folder").mkdir()

            entries = self.service.list_directory(tmpdir)
            # Folder should come first despite alphabetical order
            assert entries[0].is_dir
            assert entries[0].name == "zzz_folder"

    @pytest.mark.asyncio
    async def test_read_file(self):
        """Read file returns content."""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False) as f:
            f.write("test content")
            f.flush()
            path = f.name

        try:
            content = await self.service.read_file(path)
            assert content == "test content"
        finally:
            os.unlink(path)

    @pytest.mark.asyncio
    async def test_write_file(self):
        """Write file creates/updates content."""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False) as f:
            path = f.name

        try:
            await self.service.write_file(path, "new content")
            content = await self.service.read_file(path)
            assert content == "new content"
        finally:
            os.unlink(path)

    @pytest.mark.asyncio
    async def test_read_large_file_raises(self):
        """Reading file over size limit raises ValueError."""
        # Create a file larger than MAX_FILE_SIZE
        with tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False) as f:
            # Write more than 500KB
            f.write("x" * (FileService.MAX_FILE_SIZE + 1000))
            path = f.name

        try:
            with pytest.raises(ValueError, match="too large"):
                await self.service.read_file(path)
        finally:
            os.unlink(path)


class TestFileIcons:
    """Tests for file icon mapping."""

    def test_python_icon(self):
        """Python files get code icon."""
        icon = get_file_icon("test.py")
        assert icon is not None

    def test_folder_icon(self):
        """Folders get folder icon."""
        icon = get_file_icon("folder", is_dir=True)
        assert icon == FOLDER_ICON

    def test_expanded_folder_icon(self):
        """Expanded folders get different icon."""
        icon = get_file_icon("folder", is_dir=True, is_expanded=True)
        assert icon != FOLDER_ICON

    def test_unknown_extension_gets_default(self):
        """Unknown extensions get default file icon."""
        icon = get_file_icon("file.xyz123abc")
        assert icon is not None

    def test_common_extensions_mapped(self):
        """Common file types are mapped."""
        test_cases = [".py", ".js", ".json", ".md", ".html", ".css"]
        for ext in test_cases:
            icon = get_file_icon(f"file{ext}")
            assert icon is not None, f"No icon for {ext}"
```
  </action>
  <verify>
```bash
cd "C:\Users\karlt\OneDrive\Desktop\Claude\skynette-repo" && python -m pytest tests/unit/test_editor_services.py -v --tb=short
```
All tests should pass.
  </verify>
  <done>Unit tests cover highlighter, file service, and file icons (18+ tests)</done>
</task>

<task type="auto">
  <name>Task 3: Create unit tests for EditorState</name>
  <files>tests/unit/test_editor_state.py</files>
  <action>
Create tests for EditorState and OpenFile.

```python
"""Unit tests for code editor state management."""

import pytest
from src.ui.views.code_editor.state import EditorState, OpenFile


class TestOpenFile:
    """Tests for OpenFile dataclass."""

    def test_defaults(self):
        """OpenFile has sensible defaults."""
        f = OpenFile(path="/test.py", content="x = 1", language="python")
        assert f.is_dirty == False
        assert f.scroll_position == 0
        assert f.cursor_position == 0

    def test_dirty_flag(self):
        """Dirty flag can be set."""
        f = OpenFile(path="/test.py", content="", language="python", is_dirty=True)
        assert f.is_dirty == True


class TestEditorState:
    """Tests for EditorState container."""

    def setup_method(self):
        self.state = EditorState()
        self.listener_called = False

    def _listener(self):
        self.listener_called = True

    def test_initial_state(self):
        """Initial state has no open files."""
        assert len(self.state.open_files) == 0
        assert self.state.active_file_index == -1
        assert self.state.active_file is None

    def test_add_listener(self):
        """Listener is added and notified."""
        self.state.add_listener(self._listener)
        self.state.notify()
        assert self.listener_called

    def test_remove_listener(self):
        """Listener can be removed."""
        self.state.add_listener(self._listener)
        self.state.remove_listener(self._listener)
        self.state.notify()
        assert not self.listener_called

    def test_open_file_adds_to_list(self):
        """Opening file adds to open_files."""
        self.state.open_file("/test.py", "content", "python")
        assert len(self.state.open_files) == 1
        assert self.state.open_files[0].path == "/test.py"

    def test_open_file_sets_active(self):
        """Opening file sets it as active."""
        self.state.open_file("/test.py", "content", "python")
        assert self.state.active_file_index == 0
        assert self.state.active_file.path == "/test.py"

    def test_open_same_file_focuses_existing(self):
        """Opening already-open file focuses it instead of duplicating."""
        self.state.open_file("/test.py", "content", "python")
        self.state.open_file("/other.py", "other", "python")
        self.state.open_file("/test.py", "content", "python")

        assert len(self.state.open_files) == 2
        assert self.state.active_file_index == 0

    def test_close_file(self):
        """Closing file removes from list."""
        self.state.open_file("/test.py", "content", "python")
        result = self.state.close_file(0)
        assert len(self.state.open_files) == 0
        assert result == False  # Was not dirty

    def test_close_dirty_file_returns_true(self):
        """Closing dirty file returns True."""
        self.state.open_file("/test.py", "content", "python")
        self.state.set_content(0, "new content")
        result = self.state.close_file(0)
        assert result == True  # Was dirty

    def test_set_content_marks_dirty(self):
        """Setting content marks file as dirty."""
        self.state.open_file("/test.py", "content", "python")
        self.state.set_content(0, "new content")
        assert self.state.open_files[0].is_dirty == True
        assert self.state.open_files[0].content == "new content"

    def test_mark_saved_clears_dirty(self):
        """Marking saved clears dirty flag."""
        self.state.open_file("/test.py", "content", "python")
        self.state.set_content(0, "new content")
        self.state.mark_saved(0)
        assert self.state.open_files[0].is_dirty == False

    def test_set_active(self):
        """Can set active file by index."""
        self.state.open_file("/a.py", "a", "python")
        self.state.open_file("/b.py", "b", "python")
        self.state.set_active(0)
        assert self.state.active_file_index == 0

    def test_toggle_sidebar(self):
        """Sidebar visibility can be toggled."""
        assert self.state.sidebar_visible == True
        self.state.toggle_sidebar()
        assert self.state.sidebar_visible == False
        self.state.toggle_sidebar()
        assert self.state.sidebar_visible == True

    def test_set_sidebar_width(self):
        """Sidebar width can be set."""
        self.state.set_sidebar_width(300)
        assert self.state.sidebar_width == 300

    def test_set_file_tree_root(self):
        """File tree root can be set."""
        self.state.set_file_tree_root("/projects")
        assert self.state.file_tree_root == "/projects"

    def test_dispose_clears_everything(self):
        """Dispose clears state and listeners."""
        self.state.add_listener(self._listener)
        self.state.open_file("/test.py", "content", "python")
        self.state.dispose()

        assert len(self.state._listeners) == 0
        assert len(self.state.open_files) == 0
        assert self.state.active_file_index == -1

    def test_operations_notify_listeners(self):
        """State-changing operations notify listeners."""
        self.state.add_listener(self._listener)

        operations = [
            lambda: self.state.open_file("/t.py", "x", "python"),
            lambda: self.state.set_content(0, "y"),
            lambda: self.state.set_active(0),
            lambda: self.state.toggle_sidebar(),
            lambda: self.state.set_sidebar_width(200),
        ]

        for op in operations:
            self.listener_called = False
            op()
            assert self.listener_called, f"Listener not called for {op}"
```
  </action>
  <verify>
```bash
cd "C:\Users\karlt\OneDrive\Desktop\Claude\skynette-repo" && python -m pytest tests/unit/test_editor_state.py -v --tb=short
```
All tests should pass.
  </verify>
  <done>Unit tests cover EditorState operations and listener pattern (18+ tests)</done>
</task>

</tasks>

<verification>
All tests pass:
```bash
cd "C:\Users\karlt\OneDrive\Desktop\Claude\skynette-repo" && python -m pytest tests/unit/test_editor_*.py -v --tb=short
```

Dispose methods work:
```bash
python -c "
from src.ui.views.code_editor.state import EditorState
state = EditorState()
state.open_file('test.py', 'x', 'python')
state.add_listener(lambda: None)
print(f'Before: files={len(state.open_files)}, listeners={len(state._listeners)}')
state.dispose()
print(f'After: files={len(state.open_files)}, listeners={len(state._listeners)}')
"
```
Should show 0 files and 0 listeners after dispose.
</verification>

<success_criteria>
- All components have dispose() methods
- EditorState.dispose() clears listeners and files
- CodeEditorView.dispose() calls dispose on children
- App navigation calls dispose when switching views
- 35+ unit tests covering services and state
- All tests pass without launching Flet UI
- QUAL-02 requirement satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/03-code-editor-core/03-05-SUMMARY.md`
</output>
