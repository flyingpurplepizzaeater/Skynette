---
phase: 04-ai-assisted-editing
plan: 05
type: execute
wave: 3
depends_on: ["04-02", "04-03", "04-04"]
files_modified:
  - src/ui/views/code_editor/__init__.py
  - src/ui/views/code_editor/editor.py
  - src/ui/views/code_editor/toolbar.py
  - src/ui/views/code_editor/ai_panel/chat_panel.py
autonomous: true

must_haves:
  truths:
    - "User can toggle AI panel with toolbar button or keyboard shortcut"
    - "User sees ghost text suggestions after typing pause"
    - "User can press Tab to accept inline suggestion"
    - "User can view diff preview when AI suggests code changes"
    - "Provider dropdown shows all configured providers from gateway.providers"
    - "Provider selection persists across chat sessions in ChatState"
  artifacts:
    - path: "src/ui/views/code_editor/__init__.py"
      provides: "CodeEditorView with AI panel integration"
      contains: "ChatPanel"
      min_lines: 350
  key_links:
    - from: "CodeEditorView"
      to: "ChatPanel"
      via: "ResizableSplitPanel right side"
      pattern: "ChatPanel"
    - from: "CodeEditor"
      to: "GhostTextOverlay"
      via: "Stack overlay"
      pattern: "GhostTextOverlay"
    - from: "CodeEditorView"
      to: "page.on_keyboard_event"
      via: "keyboard shortcut registration"
      pattern: "on_keyboard_event"
    - from: "ChatPanel provider dropdown"
      to: "gateway.providers"
      via: "dropdown population"
      pattern: "gateway\\.providers"
---

<objective>
Integrate all AI assistance components into CodeEditorView: add AI chat panel toggle, wire ghost text to the editor, implement keyboard shortcuts, and connect diff preview to AI responses.

Purpose: This plan assembles the pieces built in Plans 02-04 into a cohesive user experience. Without integration, the components exist but users cannot access them.

Output: Fully functional AI-assisted code editor with chat panel, inline suggestions, and diff preview.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-ai-assisted-editing/04-CONTEXT.md
@.planning/phases/04-ai-assisted-editing/04-02-SUMMARY.md
@.planning/phases/04-ai-assisted-editing/04-03-SUMMARY.md
@.planning/phases/04-ai-assisted-editing/04-04-SUMMARY.md

# Files to modify
@src/ui/views/code_editor/__init__.py (CodeEditorView)
@src/ui/views/code_editor/editor.py (CodeEditor)
@src/ui/views/code_editor/toolbar.py (EditorToolbar)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add AI panel to CodeEditorView with toggle and provider dropdown</name>
  <files>
    src/ui/views/code_editor/__init__.py
    src/ui/views/code_editor/toolbar.py
    src/ui/views/code_editor/ai_panel/chat_panel.py
  </files>
  <action>
    Integrate ChatPanel into CodeEditorView with provider selection:

    1. **Update imports in __init__.py:**
    ```python
    from src.ui.views.code_editor.ai_panel import (
        ChatPanel, ChatState, DiffPreview, GhostTextOverlay, Suggestion
    )
    from src.ai.gateway import get_gateway
    from src.ai.completions import CompletionService
    ```

    2. **Add AI state to CodeEditorView.__init__:**
    ```python
    def __init__(self, page: ft.Page):
        # ... existing code ...

        # AI assistance state
        self.chat_state = ChatState()
        self._ai_panel_visible = False
        self._ai_panel_width = 350  # Default width
        self._gateway = get_gateway()
        self._completion_service = CompletionService(self._gateway)

        # AI component references
        self._chat_panel: ChatPanel | None = None
        self._ai_split_panel: ResizableSplitPanel | None = None
    ```

    3. **Modify build() to include AI panel:**
    ```python
    def build(self) -> None:
        # ... existing toolbar, file_tree, tab_bar, editor_content ...

        # Chat panel (initially hidden)
        self._chat_panel = ChatPanel(
            page=self._page_ref,
            state=self.chat_state,
            gateway=self._gateway,
            on_include_code=self._get_selected_code,
        )

        # Wrap editor area with AI panel split
        editor_with_ai = ResizableSplitPanel(
            left=self._editor_area,
            right=ft.Container(
                content=self._chat_panel,
                visible=self._ai_panel_visible,
                width=self._ai_panel_width,
            ),
            initial_width=None,  # No initial split - full editor
            on_resize=self._on_ai_panel_resize,
        )

        # Main split: file tree | (editor + AI panel)
        self._split_panel = ResizableSplitPanel(
            left=self._file_tree,
            right=editor_with_ai,
            initial_width=self.state.sidebar_width,
            on_resize=self._on_sidebar_resize,
        )

        self.controls = [self._toolbar, self._split_panel]
    ```

    4. **Add toggle method:**
    ```python
    def toggle_ai_panel(self) -> None:
        """Toggle AI chat panel visibility."""
        self._ai_panel_visible = not self._ai_panel_visible
        if self._chat_panel:
            self._chat_panel.visible = self._ai_panel_visible
            self._toolbar.ai_panel_visible = self._ai_panel_visible
            self.update()
    ```

    5. **Add get_selected_code helper:**
    ```python
    def _get_selected_code(self) -> str:
        """Get selected code from editor for context."""
        if self._editor and self.state.active_file:
            # For now, return entire file content
            # TODO: Get actual selection when TextField supports it
            return self.state.active_file.content
        return ""
    ```

    6. **Update EditorToolbar** to add AI panel toggle button:
    ```python
    # In toolbar.py, add to __init__:
    self.on_toggle_ai: Callable[[], None] | None = None
    self.ai_panel_visible: bool = False

    # In build(), add button:
    ft.IconButton(
        icon=ft.Icons.SMART_TOY_OUTLINED if not self.ai_panel_visible else ft.Icons.SMART_TOY,
        tooltip="Toggle AI Assistant (Ctrl+Shift+A)",
        on_click=lambda e: self.on_toggle_ai() if self.on_toggle_ai else None,
    ),
    ```

    7. **Wire toolbar in CodeEditorView:**
    ```python
    self._toolbar = EditorToolbar(
        on_save=self._save_current,
        on_save_all=self._save_all,
        on_toggle_sidebar=self._toggle_sidebar,
        on_open_folder=self._open_folder,
        on_toggle_ai=self.toggle_ai_panel,  # New
        sidebar_visible=self.state.sidebar_visible,
        ai_panel_visible=self._ai_panel_visible,  # New
    )
    ```

    8. **Ensure ChatPanel provider dropdown populates from gateway.providers:**
    In ChatPanel.build(), the header row should include:
    ```python
    # Provider dropdown populated from gateway
    provider_options = [
        ft.dropdown.Option(name) for name in self.gateway.providers.keys()
    ]
    self._provider_dropdown = ft.Dropdown(
        options=provider_options,
        value=self.state.selected_provider or (provider_options[0].key if provider_options else None),
        width=120,
        on_change=self._on_provider_change,
    )

    def _on_provider_change(self, e: ft.ControlEvent) -> None:
        """Handle provider selection change."""
        self.state.set_provider(e.control.value)
    ```
  </action>
  <verify>
    ```bash
    python -c "
from src.ui.views.code_editor import CodeEditorView
from src.ai.gateway import AIGateway
import inspect

# Verify toggle_ai_panel method exists
sig = inspect.signature(CodeEditorView.toggle_ai_panel)
print('toggle_ai_panel method exists')

# Verify AIGateway has providers attribute
gateway = AIGateway()
assert hasattr(gateway, 'providers'), 'AIGateway must have providers dict'
print(f'AIGateway.providers is a {type(gateway.providers).__name__}')
"
    ```
  </verify>
  <done>AI chat panel integrated with toggle button in toolbar, panel appears on right side of editor, provider dropdown populated from gateway.providers</done>
</task>

<task type="auto">
  <name>Task 2: Wire ghost text to editor and keyboard shortcuts</name>
  <files>
    src/ui/views/code_editor/__init__.py
    src/ui/views/code_editor/editor.py
  </files>
  <action>
    Add ghost text overlay to CodeEditor and register keyboard shortcuts:

    1. **Update CodeEditor to include ghost text overlay:**
    ```python
    # In editor.py __init__:
    from src.ui.views.code_editor.ai_panel import GhostTextOverlay, Suggestion

    def __init__(self, ..., on_request_completion: Callable[[str, str], None] | None = None):
        # ... existing code ...
        self._on_request_completion = on_request_completion
        self._ghost_overlay: GhostTextOverlay | None = None
        self._completion_timer: asyncio.Task | None = None

    def _build_ui(self) -> None:
        # ... existing TextField and highlighted text setup ...

        # Ghost text overlay
        self._ghost_overlay = GhostTextOverlay(
            on_accept=self._accept_suggestion,
            on_dismiss=self._dismiss_suggestion,
        )

        # Stack: highlighted text, TextField, ghost overlay (top)
        editor_stack = ft.Stack(
            controls=[
                ft.Container(content=self._highlighted_text, padding=ft.padding.all(8)),
                ft.Container(content=self._text_field, padding=ft.padding.all(8)),
                self._ghost_overlay,  # On top for visual display
            ],
            expand=True,
        )
    ```

    2. **Add completion trigger on typing pause:**
    ```python
    def _handle_change(self, e: ft.ControlEvent) -> None:
        # ... existing highlighting update ...

        # Trigger completion after typing pause
        self._schedule_completion()

    def _schedule_completion(self) -> None:
        """Schedule completion request after debounce delay."""
        if self._completion_timer:
            self._completion_timer.cancel()

        async def request_after_delay():
            await asyncio.sleep(0.5)  # 500ms debounce
            if self._on_request_completion:
                self._on_request_completion(self._code_content, self.language)

        self._completion_timer = asyncio.create_task(request_after_delay())

    def show_suggestion(self, suggestion: str) -> None:
        """Show inline suggestion as ghost text."""
        if self._ghost_overlay:
            self._ghost_overlay.show_suggestion(
                Suggestion(text=suggestion, position=len(self._code_content)),
                self._code_content
            )

    def _accept_suggestion(self, text: str) -> None:
        """Accept suggestion - append to content."""
        self._code_content += text
        if self._text_field:
            self._text_field.value = self._code_content
            self._text_field.update()
        self._handle_change(None)  # Trigger re-highlight

    def _dismiss_suggestion(self) -> None:
        """Dismiss suggestion."""
        pass  # Ghost overlay handles hide
    ```

    3. **Register keyboard shortcuts in CodeEditorView:**
    ```python
    def __init__(self, page: ft.Page):
        # ... existing code ...

        # Register keyboard shortcuts
        self._setup_keyboard_shortcuts()

    def _setup_keyboard_shortcuts(self) -> None:
        """Register keyboard shortcuts for AI features."""
        original_handler = self._page_ref.on_keyboard_event

        def on_keyboard(e: ft.KeyboardEvent):
            # Ctrl+Shift+A: Toggle AI panel
            if e.ctrl and e.shift and e.key == "A":
                self.toggle_ai_panel()
                return

            # Tab: Accept suggestion (when ghost text visible)
            if e.key == "Tab" and self._editor and self._editor._ghost_overlay:
                if self._editor._ghost_overlay.has_suggestion():
                    self._editor._ghost_overlay.accept()
                    return  # Don't let Tab propagate

            # Escape: Dismiss suggestion
            if e.key == "Escape" and self._editor and self._editor._ghost_overlay:
                if self._editor._ghost_overlay.has_suggestion():
                    self._editor._ghost_overlay.dismiss()
                    return

            # Ctrl+Shift+D: Show diff preview for last AI response
            if e.ctrl and e.shift and e.key == "D":
                self._show_diff_preview()
                return

            # Call original handler if any
            if original_handler:
                original_handler(e)

        self._page_ref.on_keyboard_event = on_keyboard

    def _cleanup_keyboard_shortcuts(self) -> None:
        """Remove keyboard shortcut handlers."""
        self._page_ref.on_keyboard_event = None
    ```

    4. **Wire completion service:**
    ```python
    def _build_editor_content(self) -> ft.Control:
        # ... existing code ...
        self._editor = CodeEditor(
            content=active.content,
            language=active.language,
            on_change=self._on_content_change,
            on_request_completion=self._handle_completion_request,  # New
        )

    async def _handle_completion_request(self, code: str, language: str) -> None:
        """Handle completion request from editor."""
        from src.ai.completions import CompletionRequest

        request = CompletionRequest(
            code_before=code,
            code_after="",
            language=language,
            provider=self.chat_state.selected_provider,
        )

        suggestion = await self._completion_service.get_completion(request)
        if suggestion and self._editor:
            self._editor.show_suggestion(suggestion)
    ```
  </action>
  <verify>
    ```bash
    python -c "
from src.ui.views.code_editor.editor import CodeEditor
import inspect

# Check for ghost overlay attribute
source = inspect.getsource(CodeEditor.__init__)
assert '_ghost_overlay' in source or 'ghost' in source.lower()
print('CodeEditor has ghost text integration')
"
    ```
  </verify>
  <done>Ghost text appears after typing pause, Tab accepts, Escape dismisses, Ctrl+Shift+A toggles AI panel</done>
</task>

<task type="auto">
  <name>Task 3: Wire diff preview to AI responses</name>
  <files>src/ui/views/code_editor/__init__.py</files>
  <action>
    Add diff preview functionality for AI-suggested code changes:

    1. **Add diff preview state:**
    ```python
    def __init__(self, page: ft.Page):
        # ... existing code ...
        self._pending_diff: tuple[str, str] | None = None  # (original, modified)
        self._diff_dialog: ft.AlertDialog | None = None
    ```

    2. **Add method to show diff from chat response:**
    ```python
    def show_diff_from_ai(self, modified_code: str) -> None:
        """Show diff preview for AI-suggested changes.

        Called when AI response contains code that differs from current file.

        Args:
            modified_code: The modified code suggested by AI.
        """
        if not self.state.active_file:
            return

        original = self.state.active_file.content
        if original == modified_code:
            return  # No changes

        self._pending_diff = (original, modified_code)
        self._show_diff_preview()

    def _show_diff_preview(self) -> None:
        """Show diff preview dialog."""
        if not self._pending_diff:
            return

        original, modified = self._pending_diff

        diff_preview = DiffPreview(
            original=original,
            modified=modified,
            filename=self.state.active_file.path if self.state.active_file else "file",
            on_accept=self._apply_diff,
            on_reject=self._cancel_diff,
        )

        self._diff_dialog = ft.AlertDialog(
            title=ft.Text("Review Changes"),
            content=ft.Container(
                content=diff_preview,
                width=700,
                height=500,
            ),
            actions=[],  # DiffPreview has its own buttons
            modal=True,
        )

        self._page_ref.overlay.append(self._diff_dialog)
        self._diff_dialog.open = True
        self._page_ref.update()

    def _apply_diff(self, content: str) -> None:
        """Apply diff changes to active file."""
        if self.state.active_file_index >= 0:
            self.state.set_content(self.state.active_file_index, content)
            if self._editor:
                self._editor.set_content(content)

        self._close_diff_dialog()
        self._pending_diff = None

    def _cancel_diff(self) -> None:
        """Cancel diff preview."""
        self._close_diff_dialog()
        self._pending_diff = None

    def _close_diff_dialog(self) -> None:
        """Close diff dialog."""
        if self._diff_dialog:
            self._diff_dialog.open = False
            self._page_ref.update()
    ```

    3. **Hook into ChatPanel to detect code responses:**
    Modify ChatPanel initialization to pass callback:
    ```python
    self._chat_panel = ChatPanel(
        page=self._page_ref,
        state=self.chat_state,
        gateway=self._gateway,
        on_include_code=self._get_selected_code,
        on_code_suggestion=self.show_diff_from_ai,  # New callback
    )
    ```

    This requires updating ChatPanel to detect code blocks in responses
    and call the callback. Add to ChatPanel:
    ```python
    def _detect_code_in_response(self, content: str) -> str | None:
        """Extract code from AI response if present."""
        import re
        # Match ```language\ncode\n```
        match = re.search(r'```\w*\n(.*?)```', content, re.DOTALL)
        if match:
            return match.group(1).strip()
        return None
    ```

    4. **Update dispose to clean up:**
    ```python
    def dispose(self) -> None:
        # ... existing cleanup ...
        self._cleanup_keyboard_shortcuts()
        self.chat_state.dispose()
        self._completion_service.cancel_pending()
    ```
  </action>
  <verify>
    ```bash
    python -c "
from src.ui.views.code_editor import CodeEditorView
import inspect

# Check for diff preview methods
source = inspect.getsource(CodeEditorView)
assert 'show_diff_from_ai' in source or 'diff_preview' in source.lower()
print('CodeEditorView has diff preview integration')
"
    ```
  </verify>
  <done>AI code suggestions trigger diff preview dialog, user can accept/reject changes before applying</done>
</task>

</tasks>

<verification>
Full integration functional:

```bash
python -c "
from src.ui.views.code_editor import CodeEditorView
from src.ui.views.code_editor.ai_panel import ChatPanel, ChatState, DiffPreview, GhostTextOverlay
from src.ai.completions import CompletionService
from src.ai.gateway import AIGateway

# Verify provider dropdown can be populated
gateway = AIGateway()
print(f'Gateway providers: {list(gateway.providers.keys())}')

# Verify ChatState persists provider selection
state = ChatState()
state.set_provider('test_provider')
assert state.selected_provider == 'test_provider', 'Provider selection should persist'
print('Provider selection persists in ChatState')

print('All AI-assisted editing components integrated')
print('- ChatPanel: AI chat with streaming')
print('- GhostTextOverlay: Inline suggestions')
print('- DiffPreview: Change review')
print('- Keyboard shortcuts: Ctrl+Shift+A, Tab, Escape')
print('- Provider dropdown: populated from gateway.providers')
"
```
</verification>

<success_criteria>
1. Ctrl+Shift+A toggles AI panel visibility
2. Tab accepts ghost text suggestion when visible
3. Escape dismisses ghost text suggestion
4. Toolbar has AI panel toggle button
5. Diff preview dialog shows when AI suggests code changes
6. Accept in diff preview applies changes to editor
7. Provider dropdown shows all configured providers from gateway.providers
8. Provider selection persists in ChatState across chat sessions
9. All components properly disposed on view cleanup
</success_criteria>

<output>
After completion, create `.planning/phases/04-ai-assisted-editing/04-05-SUMMARY.md`
</output>
