---
phase: 01-stability-audit
plan: 04
type: execute
wave: 2
depends_on: ["01-01", "01-02", "01-03"]
files_modified:
  - src/ui/views/ai_hub.py
  - src/ui/views/ai_hub/__init__.py
  - src/ui/views/ai_hub/wizard.py
  - src/ui/views/ai_hub/providers.py
  - src/ui/views/ai_hub/model_library.py
  - src/ui/views/ai_hub/state.py
  - tests/unit/test_ai_hub_refactor.py
autonomous: false

must_haves:
  truths:
    - "All existing AIHubView functionality preserved (wizard, providers, models, usage, knowledge bases)"
    - "State changes in one component propagate correctly to others"
    - "Components are independently testable"
    - "Large conversation histories handled without UI degradation"
  artifacts:
    - path: "src/ui/views/ai_hub/__init__.py"
      provides: "Refactored AIHubView coordinator"
      max_lines: 200
    - path: "src/ui/views/ai_hub/wizard.py"
      provides: "Extracted Setup Wizard component"
      min_lines: 100
    - path: "src/ui/views/ai_hub/state.py"
      provides: "Centralized state container"
      min_lines: 30
    - path: "tests/unit/test_ai_hub_refactor.py"
      provides: "Tests for refactored components"
      min_lines: 80
  key_links:
    - from: "src/ui/views/ai_hub/__init__.py"
      to: "src/ui/views/ai_hub/wizard.py"
      via: "import and instantiation"
      pattern: "from .wizard import|SetupWizard\\("
    - from: "src/ui/views/ai_hub/wizard.py"
      to: "src/ui/views/ai_hub/state.py"
      via: "state container reference"
      pattern: "AIHubState|self\\.state"
---

<objective>
Refactor AIHubView state management to improve testability, maintainability, and performance at scale.

Purpose: The 1669-line AIHubView violates single responsibility principle and will become harder to maintain as features grow. Decompose into focused, testable modules using feature-based decomposition and state container pattern.
Output: Modular AIHubView with extracted components and centralized state management.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-stability-audit/01-RESEARCH.md
@.planning/phases/01-stability-audit/01-CONTEXT.md

# Audit findings from prior plans
@.planning/phases/01-stability-audit/01-01-SUMMARY.md
@.planning/phases/01-stability-audit/01-02-SUMMARY.md
@.planning/phases/01-stability-audit/01-03-SUMMARY.md

# Source files to refactor
@src/ui/views/ai_hub.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create module structure and state container</name>
  <files>
    - src/ui/views/ai_hub/__init__.py (create)
    - src/ui/views/ai_hub/state.py (create)
  </files>
  <action>
Create the new modular structure for AIHubView:

1. Create directory: `src/ui/views/ai_hub/`

2. Create state container (`state.py`):
```python
# src/ui/views/ai_hub/state.py
"""Centralized state for AI Hub components."""

from dataclasses import dataclass, field
from typing import Callable, Any

@dataclass
class AIHubState:
    """Centralized state for AI Hub components."""

    # Wizard state
    wizard_step: int = 0
    selected_providers: list[str] = field(default_factory=list)
    provider_configs: dict[str, Any] = field(default_factory=dict)

    # Ollama status
    ollama_connected: bool = False
    ollama_models: list[str] = field(default_factory=list)

    # Listeners for reactive updates
    _listeners: list[Callable[[], None]] = field(default_factory=list, repr=False)

    def add_listener(self, callback: Callable[[], None]) -> None:
        """Register a callback to be notified of state changes."""
        self._listeners.append(callback)

    def remove_listener(self, callback: Callable[[], None]) -> None:
        """Unregister a callback."""
        if callback in self._listeners:
            self._listeners.remove(callback)

    def notify(self) -> None:
        """Notify all listeners of state change."""
        for listener in self._listeners:
            listener()

    # State mutation methods
    def set_wizard_step(self, step: int) -> None:
        self.wizard_step = step
        self.notify()

    def toggle_provider(self, provider: str) -> None:
        if provider in self.selected_providers:
            self.selected_providers.remove(provider)
        else:
            self.selected_providers.append(provider)
        self.notify()

    def set_provider_config(self, provider: str, config: dict) -> None:
        self.provider_configs[provider] = config
        self.notify()
```

3. Create thin coordinator (`__init__.py`):
```python
# src/ui/views/ai_hub/__init__.py
"""AI Hub view - Modular model management."""

import flet as ft
from src.ui.theme import Theme
from .state import AIHubState

# Import extracted components (will be created in Task 2)
# from .wizard import SetupWizard
# from .providers import ProvidersTab
# from .model_library import ModelLibraryTab

class AIHubView(ft.Column):
    """AI Model Hub - coordinates tabs, delegates to specialized components."""

    def __init__(self, page: ft.Page = None):
        super().__init__()
        self._page = page
        self.expand = True
        self.state = AIHubState()

        # Components will be instantiated in build()
        self._wizard = None
        self._providers = None
        self._library = None

    def build(self):
        # Placeholder - will delegate to extracted components
        # For now, import and use original implementation
        from src.ui.views.ai_hub_legacy import AIHubViewLegacy
        legacy = AIHubViewLegacy(page=self._page)
        return legacy.build()
```

4. Rename original file temporarily:
   - `src/ui/views/ai_hub.py` -> `src/ui/views/ai_hub_legacy.py`
   - Update class name to `AIHubViewLegacy`
   - This allows incremental migration

5. Update imports in app.py to use new module:
```python
# Should now import from: src.ui.views.ai_hub
from src.ui.views.ai_hub import AIHubView
```

Verify the app still works with the legacy shim.
  </action>
  <verify>
- Directory `src/ui/views/ai_hub/` exists with `__init__.py` and `state.py`
- Original `ai_hub.py` renamed to `ai_hub_legacy.py`
- App imports AIHubView from new module location
- Run app: `python -m src.main` - AIHubView still renders correctly
- Run tests: `pytest tests/e2e/test_ai_hub*.py -v --tb=short` - existing tests pass
  </verify>
  <done>
Module structure created. State container implemented. Legacy shim working.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extract wizard and tabs to separate modules</name>
  <files>
    - src/ui/views/ai_hub/wizard.py (create)
    - src/ui/views/ai_hub/providers.py (create)
    - src/ui/views/ai_hub/model_library.py (create)
    - src/ui/views/ai_hub/__init__.py (update)
    - src/ui/views/ai_hub_legacy.py (delete after migration)
  </files>
  <action>
Extract components one by one from ai_hub_legacy.py:

1. **Extract SetupWizard** (`wizard.py`):
   - Move `_build_wizard_tab()` and related methods
   - Move wizard step builders: `_build_wizard_step1_*`, `_build_wizard_step2_*`, `_build_wizard_step3_*`
   - Move `_wizard_next_step()`, `_wizard_prev_step()`, `_wizard_complete()`
   - Use state container for wizard_step, selected_providers, provider_configs
   - Accept `state: AIHubState` in constructor

2. **Extract ProvidersTab** (`providers.py`):
   - Move `_build_providers_tab()` and related methods
   - Move provider card builders
   - Move provider configuration methods
   - Use state container for provider_configs

3. **Extract ModelLibraryTab** (`model_library.py`):
   - Move `_build_model_library_tab()` and related methods
   - Move sub-tabs: My Models, HuggingFace, Ollama, Import
   - Move download/install methods
   - Use hub from `src.ai.models.hub`

4. **Update coordinator** (`__init__.py`):
   - Import extracted components
   - Instantiate with shared state
   - Wire up tabs
   - Remove legacy shim

5. **Delete legacy file** once all tests pass

Pattern for extracted components:
```python
# src/ui/views/ai_hub/wizard.py
import flet as ft
from src.ui.theme import Theme
from .state import AIHubState

class SetupWizard(ft.Column):
    """AI Provider setup wizard."""

    def __init__(self, page: ft.Page, state: AIHubState, on_complete=None):
        super().__init__()
        self._page = page
        self.state = state
        self.on_complete = on_complete

        # Listen for state changes
        self.state.add_listener(self._on_state_change)

    def _on_state_change(self):
        """Rebuild when state changes."""
        if self._page:
            self._page.update()

    def build(self):
        # Build current step based on state.wizard_step
        pass
```

Run tests after each extraction to catch regressions early.
  </action>
  <verify>
- `src/ui/views/ai_hub/wizard.py` exists and contains wizard logic
- `src/ui/views/ai_hub/providers.py` exists and contains provider tab
- `src/ui/views/ai_hub/model_library.py` exists and contains model library
- `src/ui/views/ai_hub/__init__.py` coordinates all tabs
- `src/ui/views/ai_hub_legacy.py` deleted
- App runs: `python -m src.main` - all tabs functional
- Tests pass: `pytest tests/e2e/test_ai_hub*.py -v --tb=short`
  </verify>
  <done>
AIHubView decomposed into modules. All functionality preserved. Legacy file removed.
  </done>
</task>

<task type="auto">
  <name>Task 3: Write tests for refactored components</name>
  <files>
    - tests/unit/test_ai_hub_refactor.py (create)
  </files>
  <action>
Create tests for the refactored AIHubView components:

```python
# tests/unit/test_ai_hub_refactor.py
"""Tests for refactored AIHubView components."""

import pytest
from unittest.mock import MagicMock

from src.ui.views.ai_hub.state import AIHubState
from src.ui.views.ai_hub.wizard import SetupWizard
from src.ui.views.ai_hub.providers import ProvidersTab
from src.ui.views.ai_hub.model_library import ModelLibraryTab


class TestAIHubState:
    """Tests for centralized state container."""

    def test_initial_state(self):
        state = AIHubState()
        assert state.wizard_step == 0
        assert state.selected_providers == []
        assert state.provider_configs == {}

    def test_wizard_step_mutation_notifies_listeners(self):
        state = AIHubState()
        listener = MagicMock()
        state.add_listener(listener)

        state.set_wizard_step(1)

        assert state.wizard_step == 1
        listener.assert_called_once()

    def test_toggle_provider(self):
        state = AIHubState()

        state.toggle_provider("openai")
        assert "openai" in state.selected_providers

        state.toggle_provider("openai")
        assert "openai" not in state.selected_providers

    def test_remove_listener(self):
        state = AIHubState()
        listener = MagicMock()
        state.add_listener(listener)
        state.remove_listener(listener)

        state.set_wizard_step(1)

        listener.assert_not_called()


class TestSetupWizard:
    """Tests for extracted SetupWizard component."""

    @pytest.fixture
    def mock_page(self):
        page = MagicMock()
        page.update = MagicMock()
        return page

    @pytest.fixture
    def wizard(self, mock_page):
        state = AIHubState()
        return SetupWizard(page=mock_page, state=state)

    def test_wizard_builds_step_based_on_state(self, wizard):
        # Initial step is 0
        assert wizard.state.wizard_step == 0

    def test_wizard_state_preserved_on_back(self, wizard):
        wizard.state.toggle_provider("openai")
        wizard.state.set_wizard_step(1)
        wizard.state.set_wizard_step(0)

        assert "openai" in wizard.state.selected_providers


class TestProvidersTab:
    """Tests for extracted ProvidersTab component."""

    @pytest.fixture
    def mock_page(self):
        return MagicMock()

    def test_providers_tab_uses_state_config(self, mock_page):
        state = AIHubState()
        state.set_provider_config("openai", {"api_key": "test"})

        tab = ProvidersTab(page=mock_page, state=state)
        # Verify config is accessible
        assert state.provider_configs["openai"]["api_key"] == "test"


class TestModelLibraryTab:
    """Tests for extracted ModelLibraryTab component."""

    @pytest.fixture
    def mock_page(self):
        return MagicMock()

    def test_model_library_initializes(self, mock_page):
        tab = ModelLibraryTab(page=mock_page)
        assert tab is not None
```

Run tests:
```bash
pytest tests/unit/test_ai_hub_refactor.py -v
```
  </action>
  <verify>
- `tests/unit/test_ai_hub_refactor.py` exists
- All tests pass: `pytest tests/unit/test_ai_hub_refactor.py -v`
- State container tested (mutations, listeners)
- Each extracted component has at least one test
  </verify>
  <done>
Refactored components tested. State management verified correct.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Refactored AIHubView from 1669-line monolith into modular components:
- `ai_hub/__init__.py` - Thin coordinator (~100-200 lines)
- `ai_hub/state.py` - Centralized state container
- `ai_hub/wizard.py` - Setup wizard component
- `ai_hub/providers.py` - Provider management tab
- `ai_hub/model_library.py` - Model library with sub-tabs
  </what-built>
  <how-to-verify>
1. Run the app: `python -m src.main`
2. Navigate to AI Hub
3. Test Setup Wizard:
   - Complete all 3 steps
   - Use back button to verify state preserved
4. Test My Providers tab:
   - View configured providers
   - Add/remove a provider
5. Test Model Library:
   - Browse My Models
   - Check Ollama status
   - Try downloading a model (if Ollama available)
6. Test Usage tab - should still work
7. Test Knowledge Bases tab - should still work
  </how-to-verify>
  <resume-signal>Type "approved" if all functionality works, or describe issues found</resume-signal>
</task>

</tasks>

<verification>
```bash
# All unit tests pass
pytest tests/unit/test_ai_hub_refactor.py -v

# All existing AI Hub tests pass
pytest tests/e2e/test_ai_hub*.py -v --tb=short

# Full test suite passes
pytest tests/ -v --tb=short

# Static analysis clean
ruff check src/ui/views/ai_hub/
mypy src/ui/views/ai_hub/
```
</verification>

<success_criteria>
- AIHubView decomposed from 1669 lines to coordinator < 200 lines
- State container centralizes wizard and provider state
- Each component independently testable
- All existing functionality preserved
- All tests pass
- Human verification confirms correct behavior
- STAB-04 requirement satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/01-stability-audit/01-04-SUMMARY.md`
</output>
