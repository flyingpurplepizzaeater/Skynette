---
phase: 10-built-in-tools
plan: 04
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - src/agent/tools/code_execution.py
  - src/agent/tools/__init__.py
  - src/agent/registry/tool_registry.py
autonomous: true

must_haves:
  truths:
    - "Agent can execute code snippets and return output (TOOL-04)"
    - "Execution has configurable timeout (default 5 minutes)"
    - "Output includes exit code, stdout, stderr, and duration"
    - "Multiple languages supported (Python, Node.js, shell)"
  artifacts:
    - path: "src/agent/tools/code_execution.py"
      provides: "CodeExecutionTool with multi-language support"
      exports: ["CodeExecutionTool"]
    - path: "src/agent/registry/tool_registry.py"
      provides: "CodeExecutionTool registration"
      contains: "CodeExecutionTool"
  key_links:
    - from: "src/agent/tools/code_execution.py"
      to: "asyncio.create_subprocess_exec"
      via: "async subprocess execution"
      pattern: "create_subprocess_exec"
    - from: "CodeExecutionTool.execute"
      to: "asyncio.wait_for"
      via: "timeout enforcement"
      pattern: "wait_for.*timeout"
---

<objective>
Implement code execution tool supporting Python, Node.js, and shell commands with timeout and output capture.

Purpose: Enables agent to run code snippets - essential for data processing, testing, and automation tasks. Satisfies TOOL-04.

Output: `CodeExecutionTool` registered in ToolRegistry with multi-language support.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-built-in-tools/10-CONTEXT.md
@.planning/phases/10-built-in-tools/10-RESEARCH.md

# Existing execution patterns
@src/core/nodes/coding/execution.py

# Tool patterns
@src/agent/registry/base_tool.py
@src/agent/models/tool.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement CodeExecutionTool</name>
  <files>
    src/agent/tools/code_execution.py
  </files>
  <action>
Create `src/agent/tools/code_execution.py`:

**ExecutionResult dataclass:**
```python
@dataclass
class ExecutionResult:
    exit_code: int
    stdout: str
    stderr: str
    duration_seconds: float
    timed_out: bool
    language: str
```

**Language detection helper:**
```python
LANGUAGE_CONFIG = {
    "python": {"cmd": ["python", "-c"], "file_ext": ".py"},
    "python3": {"cmd": ["python3", "-c"], "file_ext": ".py"},
    "node": {"cmd": ["node", "-e"], "file_ext": ".js"},
    "javascript": {"cmd": ["node", "-e"], "file_ext": ".js"},
    "bash": {"cmd": ["bash", "-c"], "file_ext": ".sh"},
    "shell": {"cmd": ["bash", "-c"], "file_ext": ".sh"},
    "powershell": {"cmd": ["powershell", "-Command"], "file_ext": ".ps1"},
}
```

**CodeExecutionTool:**
```python
class CodeExecutionTool(BaseTool):
    name = "code_execute"
    description = "Execute code in Python, Node.js, or shell. Returns stdout, stderr, exit code, and execution time."
    parameters_schema = {
        "type": "object",
        "properties": {
            "code": {"type": "string", "description": "Code to execute"},
            "language": {
                "type": "string",
                "enum": ["python", "python3", "node", "javascript", "bash", "shell", "powershell"],
                "description": "Programming language (default: python)",
                "default": "python"
            },
            "timeout": {
                "type": "integer",
                "description": "Timeout in seconds (default: 300 = 5 minutes)",
                "default": 300
            },
            "working_dir": {
                "type": "string",
                "description": "Working directory for execution"
            }
        },
        "required": ["code"]
    }
    is_destructive = True  # Code execution can have side effects
```

**Execute method implementation:**

1. Get language config from LANGUAGE_CONFIG dict
2. For short code (< 1000 chars), use direct command execution with `-c` or `-e` flag
3. For longer code, create temp file with appropriate extension
4. Use `asyncio.create_subprocess_exec()` for async execution:
```python
async def _run_code(
    self,
    code: str,
    language: str,
    timeout: int,
    working_dir: str | None,
) -> ExecutionResult:
    start = time.perf_counter()
    config = LANGUAGE_CONFIG.get(language, LANGUAGE_CONFIG["python"])

    # Build command
    if len(code) < 1000:
        cmd = config["cmd"] + [code]
        temp_file = None
    else:
        # Create temp file for longer code
        import tempfile
        fd, temp_file = tempfile.mkstemp(suffix=config["file_ext"])
        with os.fdopen(fd, "w") as f:
            f.write(code)
        # Adjust command for file execution
        cmd = [config["cmd"][0], temp_file]

    try:
        proc = await asyncio.create_subprocess_exec(
            *cmd,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
            cwd=working_dir,
        )

        try:
            stdout, stderr = await asyncio.wait_for(
                proc.communicate(),
                timeout=timeout
            )
            duration = time.perf_counter() - start
            return ExecutionResult(
                exit_code=proc.returncode or 0,
                stdout=stdout.decode("utf-8", errors="replace"),
                stderr=stderr.decode("utf-8", errors="replace"),
                duration_seconds=duration,
                timed_out=False,
                language=language,
            )
        except asyncio.TimeoutError:
            proc.kill()
            await proc.wait()
            duration = time.perf_counter() - start
            return ExecutionResult(
                exit_code=-1,
                stdout="",
                stderr=f"Execution timed out after {timeout} seconds",
                duration_seconds=duration,
                timed_out=True,
                language=language,
            )
    finally:
        if temp_file and os.path.exists(temp_file):
            os.unlink(temp_file)
```

Convert ExecutionResult to dict for ToolResult.success_result():
```python
return ToolResult.success_result(
    tool_call_id=context.session_id,
    data={
        "exit_code": result.exit_code,
        "stdout": result.stdout,
        "stderr": result.stderr,
        "duration_seconds": result.duration_seconds,
        "timed_out": result.timed_out,
        "language": result.language,
        "success": result.exit_code == 0 and not result.timed_out,
    },
    duration_ms=(time.perf_counter() - start) * 1000
)
```
  </action>
  <verify>
```python
import asyncio
from src.agent.tools.code_execution import CodeExecutionTool
from src.agent.registry.base_tool import AgentContext

tool = CodeExecutionTool()
ctx = AgentContext(session_id="test")

# Test Python
result = asyncio.run(tool.execute({"code": "print('hello world')", "language": "python"}, ctx))
assert result.success
assert result.data["stdout"].strip() == "hello world"
assert result.data["exit_code"] == 0

# Test timeout
result = asyncio.run(tool.execute({"code": "import time; time.sleep(10)", "timeout": 1}, ctx))
assert result.data["timed_out"] == True

print("Code execution tool works!")
```
  </verify>
  <done>CodeExecutionTool executes code in multiple languages with timeout enforcement and full output capture.</done>
</task>

<task type="auto">
  <name>Task 2: Register CodeExecutionTool in ToolRegistry</name>
  <files>
    src/agent/tools/__init__.py
    src/agent/registry/tool_registry.py
  </files>
  <action>
1. Update `src/agent/tools/__init__.py` to include CodeExecutionTool:
```python
from src.agent.tools.base import FileSystemValidator, backup_before_modify, cleanup_old_backups
from src.agent.tools.web_search import WebSearchTool
from src.agent.tools.filesystem import FileReadTool, FileWriteTool, FileDeleteTool, FileListTool
from src.agent.tools.code_execution import CodeExecutionTool

__all__ = [
    # Base utilities
    "FileSystemValidator",
    "backup_before_modify",
    "cleanup_old_backups",
    # Tools
    "WebSearchTool",
    "FileReadTool",
    "FileWriteTool",
    "FileDeleteTool",
    "FileListTool",
    "CodeExecutionTool",
]
```

2. Update `_load_builtin_tools()` in ToolRegistry:
```python
def _load_builtin_tools(self) -> None:
    """Load built-in tools."""
    # Testing tool
    from src.agent.registry.mock_tool import MockTool
    self.register(MockTool)

    # Built-in tools
    from src.agent.tools import (
        WebSearchTool,
        FileReadTool,
        FileWriteTool,
        FileDeleteTool,
        FileListTool,
        CodeExecutionTool,
    )
    self.register(WebSearchTool)
    self.register(FileReadTool)
    self.register(FileWriteTool)
    self.register(FileDeleteTool)
    self.register(FileListTool)
    self.register(CodeExecutionTool)

    logger.info(f"Loaded {len(self._tools)} built-in tools")
```
  </action>
  <verify>
```python
from src.agent.registry import get_tool_registry
registry = get_tool_registry()
assert 'code_execute' in registry.tool_names
tool = registry.get_tool('code_execute')
assert tool is not None
print(f"code_execute tool registered")
```
  </verify>
  <done>CodeExecutionTool registered in ToolRegistry as 'code_execute'.</done>
</task>

</tasks>

<verification>
1. CodeExecutionTool executes Python code correctly
2. Node.js execution works (if node installed)
3. Timeout enforcement works
4. Output capture includes stdout, stderr, exit_code, duration
5. Tool registered in ToolRegistry

```bash
python -c "
import asyncio
from src.agent.registry import get_tool_registry
from src.agent.registry.base_tool import AgentContext

registry = get_tool_registry()
tool = registry.get_tool('code_execute')
ctx = AgentContext(session_id='test')

# Execute Python
result = asyncio.run(tool.execute({'code': 'print(2+2)', 'language': 'python'}, ctx))
print(f'Python: exit={result.data[\"exit_code\"]}, stdout={result.data[\"stdout\"].strip()}')

# Test error handling
result = asyncio.run(tool.execute({'code': 'raise ValueError(\"test\")', 'language': 'python'}, ctx))
print(f'Error test: exit={result.data[\"exit_code\"]}, has_stderr={bool(result.data[\"stderr\"])}')
"
```
</verification>

<success_criteria>
- [ ] CodeExecutionTool executes Python code and captures output
- [ ] Node.js/JavaScript execution supported
- [ ] Shell/bash execution supported
- [ ] Timeout enforcement works (kills process after timeout)
- [ ] Long code (> 1000 chars) uses temp file approach
- [ ] Output includes exit_code, stdout, stderr, duration_seconds, timed_out
- [ ] Tool marked as destructive (is_destructive = True)
- [ ] Tool registered in ToolRegistry as 'code_execute'
</success_criteria>

<output>
After completion, create `.planning/phases/10-built-in-tools/10-04-SUMMARY.md`
</output>
