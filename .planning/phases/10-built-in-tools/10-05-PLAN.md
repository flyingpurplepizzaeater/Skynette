---
phase: 10-built-in-tools
plan: 05
type: execute
wave: 3
depends_on: ["10-01"]
files_modified:
  - src/agent/tools/browser.py
  - src/agent/tools/github.py
  - src/agent/tools/__init__.py
  - src/agent/registry/tool_registry.py
autonomous: true

must_haves:
  truths:
    - "Agent can navigate a website, fill forms, and extract data (TOOL-02)"
    - "Agent can create GitHub repository and push code (TOOL-05)"
    - "Browser automation uses stealth to avoid detection"
    - "Screenshots captured on key actions for debugging"
  artifacts:
    - path: "src/agent/tools/browser.py"
      provides: "BrowserTool with navigation, form filling, data extraction"
      exports: ["BrowserTool"]
    - path: "src/agent/tools/github.py"
      provides: "GitHubTool for repo creation, file management, PRs"
      exports: ["GitHubTool"]
    - path: "src/agent/registry/tool_registry.py"
      provides: "Browser and GitHub tools registration"
      contains: "BrowserTool"
  key_links:
    - from: "src/agent/tools/browser.py"
      to: "playwright.async_api"
      via: "async_playwright context manager"
      pattern: "async_playwright"
    - from: "src/agent/tools/browser.py"
      to: "playwright_stealth.Stealth"
      via: "stealth application to context"
      pattern: "apply_stealth_async"
    - from: "src/agent/tools/github.py"
      to: "github.Github"
      via: "PyGithub client"
      pattern: "from github import"
---

<objective>
Implement browser automation tool with Playwright/stealth and GitHub integration tool with PyGithub.

Purpose: Browser enables web scraping and form automation. GitHub enables code repository management. Satisfies TOOL-02 and TOOL-05.

Output: `BrowserTool` and `GitHubTool` registered in ToolRegistry.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-built-in-tools/10-CONTEXT.md
@.planning/phases/10-built-in-tools/10-RESEARCH.md

# Tool patterns
@src/agent/registry/base_tool.py
@src/agent/models/tool.py

# Existing GitHub patterns
@src/core/nodes/apps/github.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement BrowserTool with Playwright</name>
  <files>
    src/agent/tools/browser.py
  </files>
  <action>
Create `src/agent/tools/browser.py`:

**BrowserManager singleton (handles browser lifecycle):**
```python
class BrowserManager:
    """Manages shared browser instance for efficiency."""
    _instance: Optional["BrowserManager"] = None
    _browser: Optional[Browser] = None
    _playwright: Optional[Playwright] = None

    def __new__(cls) -> "BrowserManager":
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

    async def get_browser(self, headless: bool = True) -> Browser:
        """Get or create browser instance."""
        if self._browser is None or not self._browser.is_connected():
            from playwright.async_api import async_playwright
            self._playwright = await async_playwright().start()
            self._browser = await self._playwright.chromium.launch(
                headless=headless,
                args=["--disable-blink-features=AutomationControlled"]
            )
        return self._browser

    async def close(self):
        """Close browser and playwright."""
        if self._browser:
            await self._browser.close()
            self._browser = None
        if self._playwright:
            await self._playwright.stop()
            self._playwright = None
```

**BrowserTool:**
```python
class BrowserTool(BaseTool):
    name = "browser"
    description = "Navigate websites, fill forms, click elements, and extract data. Uses headless browser with stealth."
    parameters_schema = {
        "type": "object",
        "properties": {
            "action": {
                "type": "string",
                "enum": ["navigate", "click", "fill", "extract", "screenshot", "get_text"],
                "description": "Browser action to perform"
            },
            "url": {"type": "string", "description": "URL to navigate to (for navigate action)"},
            "selector": {"type": "string", "description": "CSS selector for element"},
            "value": {"type": "string", "description": "Value for fill action"},
            "timeout": {"type": "integer", "description": "Timeout in ms (default: 30000)", "default": 30000},
            "headless": {"type": "boolean", "description": "Run headless (default: true)", "default": True}
        },
        "required": ["action"]
    }
```

**Execute method - handle actions:**

1. **navigate:** Go to URL, return page title and URL
```python
if action == "navigate":
    await page.goto(url, timeout=timeout)
    # Auto screenshot on navigation per CONTEXT.md
    screenshot = await page.screenshot()
    return {"title": await page.title(), "url": page.url, "screenshot_b64": base64.b64encode(screenshot).decode()}
```

2. **click:** Click element by selector
```python
if action == "click":
    await page.click(selector, timeout=timeout)
    return {"clicked": selector}
```

3. **fill:** Fill form field
```python
if action == "fill":
    await page.fill(selector, value, timeout=timeout)
    return {"filled": selector, "value": value}
```

4. **extract:** Extract element content (text or attribute)
```python
if action == "extract":
    element = await page.query_selector(selector)
    if element:
        text = await element.text_content()
        html = await element.inner_html()
        return {"text": text, "html": html}
```

5. **screenshot:** Take screenshot
```python
if action == "screenshot":
    screenshot = await page.screenshot(full_page=True)
    return {"screenshot_b64": base64.b64encode(screenshot).decode()}
```

6. **get_text:** Get all visible text from page
```python
if action == "get_text":
    text = await page.text_content("body")
    return {"text": text}
```

**Important implementation details:**
- Create new context per operation (with stealth applied)
- Apply playwright-stealth: `await stealth.apply_stealth_async(context)`
- Use try/finally to close context even on errors
- Store page reference in AgentContext.variables for multi-step operations
- Log actions for debugging

**Page persistence for multi-step operations:**
Track active pages in a module-level dict keyed by session_id. Allow "close" action to clean up.
  </action>
  <verify>
```python
import asyncio
from src.agent.tools.browser import BrowserTool
from src.agent.registry.base_tool import AgentContext

tool = BrowserTool()
ctx = AgentContext(session_id="test")

# Test navigation (requires playwright install chromium)
try:
    result = asyncio.run(tool.execute({
        "action": "navigate",
        "url": "https://example.com"
    }, ctx))
    assert result.success
    assert "title" in result.data
    print(f"Navigated to: {result.data['title']}")
except Exception as e:
    print(f"Browser test skipped (install playwright chromium): {e}")
```
  </verify>
  <done>BrowserTool can navigate, fill forms, click elements, and extract data with stealth enabled.</done>
</task>

<task type="auto">
  <name>Task 2: Implement GitHubTool with PyGithub</name>
  <files>
    src/agent/tools/github.py
  </files>
  <action>
Create `src/agent/tools/github.py`:

**GitHubTool:**
```python
class GitHubTool(BaseTool):
    name = "github"
    description = "Interact with GitHub: create repos, manage files, create issues/PRs. Requires GITHUB_TOKEN env var or token parameter."
    parameters_schema = {
        "type": "object",
        "properties": {
            "action": {
                "type": "string",
                "enum": ["create_repo", "list_repos", "create_file", "update_file", "get_file", "create_issue", "create_pr"],
                "description": "GitHub action to perform"
            },
            "token": {"type": "string", "description": "GitHub PAT (or use GITHUB_TOKEN env var)"},
            "owner": {"type": "string", "description": "Repository owner (user or org)"},
            "repo": {"type": "string", "description": "Repository name"},
            "name": {"type": "string", "description": "Name for new repo or file path"},
            "content": {"type": "string", "description": "File content or issue/PR body"},
            "message": {"type": "string", "description": "Commit message"},
            "title": {"type": "string", "description": "Issue or PR title"},
            "branch": {"type": "string", "description": "Branch name (default: main)"},
            "private": {"type": "boolean", "description": "Make repo private", "default": False},
            "head": {"type": "string", "description": "Head branch for PR"},
            "base": {"type": "string", "description": "Base branch for PR", "default": "main"}
        },
        "required": ["action"]
    }
    is_destructive = True  # Can modify repos
```

**Execute method - handle actions:**

Use PyGithub with `asyncio.to_thread()` since PyGithub is synchronous.

1. **create_repo:**
```python
def _create_repo():
    g = Github(auth=Auth.Token(token))
    user = g.get_user()
    repo = user.create_repo(
        name=params["name"],
        description=params.get("content", ""),
        private=params.get("private", False),
        auto_init=True
    )
    return {"name": repo.name, "url": repo.html_url, "clone_url": repo.clone_url}
return await asyncio.to_thread(_create_repo)
```

2. **list_repos:**
```python
def _list_repos():
    g = Github(auth=Auth.Token(token))
    user = g.get_user()
    repos = list(user.get_repos())[:30]  # Limit to 30
    return [{"name": r.name, "url": r.html_url, "private": r.private} for r in repos]
```

3. **create_file:**
```python
def _create_file():
    g = Github(auth=Auth.Token(token))
    repo = g.get_repo(f"{owner}/{repo_name}")
    result = repo.create_file(
        path=params["name"],
        message=params.get("message", f"Create {params['name']}"),
        content=params["content"],
        branch=params.get("branch", "main")
    )
    return {"path": params["name"], "sha": result["commit"].sha}
```

4. **update_file:**
```python
def _update_file():
    g = Github(auth=Auth.Token(token))
    repo = g.get_repo(f"{owner}/{repo_name}")
    file = repo.get_contents(params["name"], ref=params.get("branch", "main"))
    result = repo.update_file(
        path=params["name"],
        message=params.get("message", f"Update {params['name']}"),
        content=params["content"],
        sha=file.sha,
        branch=params.get("branch", "main")
    )
    return {"path": params["name"], "sha": result["commit"].sha}
```

5. **get_file:**
```python
def _get_file():
    g = Github(auth=Auth.Token(token))
    repo = g.get_repo(f"{owner}/{repo_name}")
    file = repo.get_contents(params["name"], ref=params.get("branch", "main"))
    content = base64.b64decode(file.content).decode("utf-8")
    return {"path": file.path, "content": content, "sha": file.sha}
```

6. **create_issue:**
```python
def _create_issue():
    g = Github(auth=Auth.Token(token))
    repo = g.get_repo(f"{owner}/{repo_name}")
    issue = repo.create_issue(
        title=params["title"],
        body=params.get("content", "")
    )
    return {"number": issue.number, "url": issue.html_url}
```

7. **create_pr:**
```python
def _create_pr():
    g = Github(auth=Auth.Token(token))
    repo = g.get_repo(f"{owner}/{repo_name}")
    pr = repo.create_pull(
        title=params["title"],
        body=params.get("content", ""),
        head=params["head"],
        base=params.get("base", "main")
    )
    return {"number": pr.number, "url": pr.html_url}
```

**Token resolution:**
```python
token = params.get("token") or os.environ.get("GITHUB_TOKEN")
if not token:
    return ToolResult.failure_result(
        tool_call_id=context.session_id,
        error="GitHub token required: provide 'token' parameter or set GITHUB_TOKEN env var"
    )
```

Handle GithubException errors gracefully with descriptive error messages.
  </action>
  <verify>
```python
import asyncio
import os
from src.agent.tools.github import GitHubTool
from src.agent.registry.base_tool import AgentContext

tool = GitHubTool()
ctx = AgentContext(session_id="test")

# Test list repos (requires GITHUB_TOKEN)
if os.environ.get("GITHUB_TOKEN"):
    result = asyncio.run(tool.execute({"action": "list_repos"}, ctx))
    print(f"GitHub tool: {result.success}, repos: {len(result.data) if result.data else 0}")
else:
    print("GitHub test skipped (no GITHUB_TOKEN)")

# Test error handling without token
os.environ.pop("GITHUB_TOKEN", None)
result = asyncio.run(tool.execute({"action": "list_repos"}, ctx))
assert not result.success
assert "token required" in result.error.lower()
print("GitHub token validation works")
```
  </verify>
  <done>GitHubTool supports repo creation, file management, issues, and PRs via PyGithub.</done>
</task>

<task type="auto">
  <name>Task 3: Register Browser and GitHub tools</name>
  <files>
    src/agent/tools/__init__.py
    src/agent/registry/tool_registry.py
  </files>
  <action>
1. Update `src/agent/tools/__init__.py`:
```python
from src.agent.tools.base import FileSystemValidator, backup_before_modify, cleanup_old_backups
from src.agent.tools.web_search import WebSearchTool
from src.agent.tools.filesystem import FileReadTool, FileWriteTool, FileDeleteTool, FileListTool
from src.agent.tools.code_execution import CodeExecutionTool
from src.agent.tools.browser import BrowserTool
from src.agent.tools.github import GitHubTool

__all__ = [
    # Base utilities
    "FileSystemValidator",
    "backup_before_modify",
    "cleanup_old_backups",
    # Tools
    "WebSearchTool",
    "FileReadTool",
    "FileWriteTool",
    "FileDeleteTool",
    "FileListTool",
    "CodeExecutionTool",
    "BrowserTool",
    "GitHubTool",
]
```

2. Update `_load_builtin_tools()` in ToolRegistry:
```python
def _load_builtin_tools(self) -> None:
    """Load built-in tools."""
    # Testing tool
    from src.agent.registry.mock_tool import MockTool
    self.register(MockTool)

    # Built-in tools
    from src.agent.tools import (
        WebSearchTool,
        FileReadTool,
        FileWriteTool,
        FileDeleteTool,
        FileListTool,
        CodeExecutionTool,
        BrowserTool,
        GitHubTool,
    )
    self.register(WebSearchTool)
    self.register(FileReadTool)
    self.register(FileWriteTool)
    self.register(FileDeleteTool)
    self.register(FileListTool)
    self.register(CodeExecutionTool)
    self.register(BrowserTool)
    self.register(GitHubTool)

    logger.info(f"Loaded {len(self._tools)} built-in tools")
```
  </action>
  <verify>
```python
from src.agent.registry import get_tool_registry
registry = get_tool_registry()
assert 'browser' in registry.tool_names
assert 'github' in registry.tool_names
print(f"All tools registered: {registry.tool_names}")
```
  </verify>
  <done>BrowserTool and GitHubTool registered in ToolRegistry.</done>
</task>

</tasks>

<verification>
1. BrowserTool can navigate to URLs (requires playwright install)
2. GitHubTool requires token and handles missing token gracefully
3. Both tools registered in ToolRegistry
4. Browser uses stealth to avoid detection

```bash
python -c "
from src.agent.registry import get_tool_registry
registry = get_tool_registry()
print('Tools:', registry.tool_names)
assert 'browser' in registry.tool_names
assert 'github' in registry.tool_names
print('Browser and GitHub tools registered!')
"
```
</verification>

<success_criteria>
- [ ] BrowserTool handles navigate, click, fill, extract, screenshot, get_text actions
- [ ] BrowserTool applies playwright-stealth to contexts
- [ ] BrowserTool takes screenshots on navigation
- [ ] BrowserTool uses 30s default timeout per CONTEXT.md
- [ ] GitHubTool handles create_repo, list_repos, create_file, update_file, get_file, create_issue, create_pr
- [ ] GitHubTool uses GITHUB_TOKEN env var or token parameter
- [ ] Both tools marked as destructive where appropriate
- [ ] Both tools registered in ToolRegistry
</success_criteria>

<output>
After completion, create `.planning/phases/10-built-in-tools/10-05-SUMMARY.md`
</output>
