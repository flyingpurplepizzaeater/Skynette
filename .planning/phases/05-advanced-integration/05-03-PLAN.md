---
phase: 05-advanced-integration
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/core/nodes/execution/__init__.py
  - src/core/nodes/execution/code_runner.py
  - src/core/nodes/registry.py
  - tests/unit/test_code_execution_node.py
autonomous: true

must_haves:
  truths:
    - "User can add a code execution node to workflows"
    - "Code execution runs with configurable timeout"
    - "Workflow variables are accessible in executed code"
    - "Execution output (stdout, stderr, return_code) is captured"
    - "Timeout prevents runaway processes"
  artifacts:
    - path: "src/core/nodes/execution/code_runner.py"
      provides: "Code execution node for workflows"
      exports: ["CodeExecutionNode"]
    - path: "src/core/nodes/execution/__init__.py"
      provides: "Execution nodes package"
      exports: ["EXECUTION_NODES"]
  key_links:
    - from: "src/core/nodes/registry.py"
      to: "EXECUTION_NODES"
      via: "node registration on startup"
      pattern: "from src\\.core\\.nodes\\.execution import"
    - from: "src/core/nodes/execution/code_runner.py"
      to: "subprocess"
      via: "subprocess.run with timeout"
      pattern: "subprocess\\.run\\("
---

<objective>
Add a code execution node that runs code snippets within workflows with timeout protection.

Purpose: Users can execute Python, JavaScript, Bash, or PowerShell code as part of automated workflows, enabling scripted data processing, API calls, and custom logic.

Output: CodeExecutionNode registered in node registry, supporting multiple languages with configurable timeout, capturing stdout/stderr/return_code.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-advanced-integration/05-RESEARCH.md
@.planning/phases/05-advanced-integration/05-CONTEXT.md

# Key existing files
@src/core/nodes/registry.py
@src/core/nodes/base.py (not read but standard pattern)
@src/core/workflow/executor.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CodeExecutionNode with subprocess execution</name>
  <files>
    src/core/nodes/execution/__init__.py
    src/core/nodes/execution/code_runner.py
  </files>
  <action>
Create execution nodes package:

1. Create src/core/nodes/execution/ directory
2. Create __init__.py with EXECUTION_NODES list export

Implement CodeExecutionNode (code_runner.py):

1. Import dependencies:
   ```python
   import subprocess
   import tempfile
   from pathlib import Path
   from src.core.nodes.base import BaseNode, NodeDefinition, NodeInput, NodeOutput
   ```

2. Define class attributes:
   ```python
   type = "code_execution"
   name = "Execute Code"
   category = "Execution"
   description = "Run code snippets (Python, JavaScript, Bash, PowerShell)"
   is_trigger = False
   ```

3. Implement get_definition() classmethod:
   - Inputs: code (textarea), language (dropdown: python/javascript/bash/powershell), timeout (number, default 30)
   - Outputs: stdout (string), stderr (string), return_code (number), success (boolean)

4. Implement async execute(config, context) -> dict:
   ```python
   code = config.get("code", "")
   language = config.get("language", "python")
   timeout = config.get("timeout", 30)
   working_dir = config.get("working_directory")

   # Inject workflow variables for Python
   if language == "python":
       var_lines = [f'{k} = {repr(v)}' for k, v in context.get("$vars", {}).items()]
       code = "\n".join(var_lines) + "\n\n" + code

   # Write to temp file
   suffix = {"python": ".py", "javascript": ".js", "bash": ".sh", "powershell": ".ps1"}
   with tempfile.NamedTemporaryFile(mode='w', suffix=suffix.get(language, ".txt"), delete=False) as f:
       f.write(code)
       temp_path = f.name

   try:
       cmd = {
           "python": ["python", temp_path],
           "javascript": ["node", temp_path],
           "bash": ["bash", temp_path],
           "powershell": ["powershell", "-File", temp_path],
       }.get(language, ["python", temp_path])

       result = subprocess.run(
           cmd,
           capture_output=True,
           text=True,
           timeout=timeout,
           cwd=working_dir,
       )

       return {
           "stdout": result.stdout,
           "stderr": result.stderr,
           "return_code": result.returncode,
           "success": result.returncode == 0,
       }
   except subprocess.TimeoutExpired:
       return {
           "stdout": "",
           "stderr": f"Execution timed out after {timeout} seconds",
           "return_code": -1,
           "success": False,
       }
   finally:
       Path(temp_path).unlink(missing_ok=True)
   ```

5. Add EXECUTION_NODES = [CodeExecutionNode] in __init__.py
  </action>
  <verify>
    pytest tests/unit/test_code_execution_node.py -v (create test)
    Test: Python code executes and returns stdout
    Test: Timeout triggers after configured seconds
    Test: Non-zero exit code sets success=False
  </verify>
  <done>
    CodeExecutionNode executes code via subprocess
    Timeout prevents runaway processes
    Output captured in stdout/stderr/return_code fields
    Temp files cleaned up after execution
  </done>
</task>

<task type="auto">
  <name>Task 2: Register CodeExecutionNode and add workflow variable injection</name>
  <files>
    src/core/nodes/registry.py
    src/core/nodes/execution/code_runner.py
  </files>
  <action>
Register node in registry:

1. Update registry.py _load_builtin_nodes():
   ```python
   # Load Execution nodes
   try:
       from src.core.nodes.execution import EXECUTION_NODES
       for node_class in EXECUTION_NODES:
           self.register(node_class)
       logger.info(f"Loaded {len(EXECUTION_NODES)} Execution nodes")
   except ImportError as e:
       logger.warning(f"Could not load Execution nodes: {e}")
   ```

Enhance variable injection for all languages:

2. In code_runner.py, add comprehensive variable injection:
   ```python
   def _inject_variables(self, code: str, language: str, variables: dict) -> str:
       """Inject workflow variables into code."""
       if not variables:
           return code

       if language == "python":
           # Python: direct assignment
           var_lines = [f'{k} = {repr(v)}' for k, v in variables.items()]
           return "\n".join(var_lines) + "\n\n" + code

       elif language == "javascript":
           # JavaScript: const declarations
           var_lines = [f'const {k} = {json.dumps(v)};' for k, v in variables.items()]
           return "\n".join(var_lines) + "\n\n" + code

       elif language in ("bash", "powershell"):
           # Shell: export/Set-Variable
           if language == "bash":
               var_lines = [f'export {k}="{v}"' for k, v in variables.items()]
           else:
               var_lines = [f'$env:{k}="{v}"' for k, v in variables.items()]
           return "\n".join(var_lines) + "\n\n" + code

       return code
   ```

3. Update execute() to use _inject_variables

4. Add input validation:
   - Reject empty code
   - Validate language is in supported list
   - Ensure timeout is positive integer (cap at 300 seconds max)
  </action>
  <verify>
    pytest tests/unit/test_code_execution_node.py -v
    Test: Node appears in registry.get_by_category("Execution")
    Test: Variables injected correctly for each language
  </verify>
  <done>
    CodeExecutionNode registered in node registry
    Variables accessible in executed code for all languages
    Input validation prevents invalid configurations
    Node shows in workflow editor palette
  </done>
</task>

<task type="auto">
  <name>Task 3: Add comprehensive tests for code execution node</name>
  <files>
    tests/unit/test_code_execution_node.py
  </files>
  <action>
Create comprehensive test suite:

1. Test basic execution:
   ```python
   async def test_python_execution():
       node = CodeExecutionNode()
       result = await node.execute(
           {"code": "print('hello')", "language": "python", "timeout": 5},
           {"$vars": {}}
       )
       assert result["success"] is True
       assert "hello" in result["stdout"]
   ```

2. Test timeout:
   ```python
   async def test_timeout():
       node = CodeExecutionNode()
       result = await node.execute(
           {"code": "import time; time.sleep(10)", "language": "python", "timeout": 1},
           {"$vars": {}}
       )
       assert result["success"] is False
       assert "timed out" in result["stderr"]
   ```

3. Test variable injection:
   ```python
   async def test_variable_injection():
       node = CodeExecutionNode()
       result = await node.execute(
           {"code": "print(my_var)", "language": "python", "timeout": 5},
           {"$vars": {"my_var": "test_value"}}
       )
       assert "test_value" in result["stdout"]
   ```

4. Test error handling:
   ```python
   async def test_syntax_error():
       node = CodeExecutionNode()
       result = await node.execute(
           {"code": "print(", "language": "python", "timeout": 5},
           {"$vars": {}}
       )
       assert result["success"] is False
       assert result["return_code"] != 0
   ```

5. Test JavaScript execution (if node installed):
   ```python
   @pytest.mark.skipif(not shutil.which("node"), reason="Node.js not installed")
   async def test_javascript_execution():
       node = CodeExecutionNode()
       result = await node.execute(
           {"code": "console.log('hello js')", "language": "javascript", "timeout": 5},
           {"$vars": {}}
       )
       assert result["success"] is True
   ```

6. Test node definition:
   ```python
   def test_node_definition():
       definition = CodeExecutionNode.get_definition()
       assert definition.type == "code_execution"
       assert "code" in [i.name for i in definition.inputs]
       assert "stdout" in [o.name for o in definition.outputs]
   ```

7. Test registry integration:
   ```python
   def test_node_in_registry():
       from src.core.nodes.registry import NodeRegistry
       registry = NodeRegistry()
       handler = registry.get_handler("code_execution")
       assert handler is not None
       assert isinstance(handler, CodeExecutionNode)
   ```
  </action>
  <verify>
    pytest tests/unit/test_code_execution_node.py -v --tb=short
    All tests pass (JavaScript test skipped if node not installed)
  </verify>
  <done>
    Test suite covers: execution, timeout, variables, errors, definition, registry
    Tests are isolated and don't require external services
    Skip markers for optional interpreters (Node.js)
    INTG-03 requirement satisfied with test coverage
  </done>
</task>

</tasks>

<verification>
After all tasks:
1. pytest tests/unit/test_code_execution_node.py -v - All tests pass
2. Open workflow editor, verify "Execute Code" node appears in palette
3. Add code execution node to workflow, configure Python code, run workflow
4. Verify stdout captured in execution results
5. Test timeout with sleep code, verify it stops after configured seconds
</verification>

<success_criteria>
- Code execution node available in workflow editor palette
- Python, JavaScript, Bash, PowerShell code can be executed
- Workflow variables are accessible in executed code
- Timeout prevents runaway processes (verified by test)
- Output captured in stdout/stderr/return_code fields
- INTG-03 requirement satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/05-advanced-integration/05-03-SUMMARY.md`
</output>
