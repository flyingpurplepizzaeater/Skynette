---
phase: 05-advanced-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/ui/views/code_editor/workflow_bridge.py
  - src/ui/views/code_editor/__init__.py
  - src/ui/views/code_editor/toolbar.py
  - src/core/workflow/models.py
autonomous: true

must_haves:
  truths:
    - "User can open a workflow as YAML in the code editor"
    - "User can edit workflow YAML and save changes back to storage"
    - "Workflow visual representation syncs with code editor changes"
    - "Invalid YAML shows error message without corrupting workflow"
  artifacts:
    - path: "src/ui/views/code_editor/workflow_bridge.py"
      provides: "Workflow-Editor bridge for bidirectional sync"
      exports: ["WorkflowBridge", "WorkflowFormat"]
    - path: "src/core/workflow/models.py"
      provides: "Workflow model with JSON and Python DSL support"
      contains: "to_python_dsl"
  key_links:
    - from: "src/ui/views/code_editor/__init__.py"
      to: "WorkflowBridge"
      via: "import and instantiation"
      pattern: "WorkflowBridge\\("
    - from: "src/ui/views/code_editor/workflow_bridge.py"
      to: "WorkflowStorage"
      via: "load_workflow and save_workflow calls"
      pattern: "storage\\.(load|save)_workflow"
---

<objective>
Enable workflow script editing in the code editor with bidirectional sync between code and visual representation.

Purpose: Users who prefer text editing can work with workflows as code (YAML/JSON/Python DSL) while maintaining consistency with the visual workflow editor.

Output: WorkflowBridge service enabling workflow load/save in code editor, toolbar format selector, validation on save.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-advanced-integration/05-RESEARCH.md
@.planning/phases/05-advanced-integration/05-CONTEXT.md

# Key existing files
@src/core/workflow/models.py
@src/data/storage.py
@src/ui/views/code_editor/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create WorkflowBridge service for load/save operations</name>
  <files>
    src/ui/views/code_editor/workflow_bridge.py
    src/core/workflow/models.py
  </files>
  <action>
Create WorkflowBridge class in workflow_bridge.py that:

1. Define WorkflowFormat enum: YAML, JSON, PYTHON_DSL
2. Implement load_as_code(workflow_id, format) -> str:
   - Get workflow from storage via get_storage().load_workflow(workflow_id)
   - Convert to requested format (YAML uses existing to_yaml(), JSON uses model_dump_json())
   - For Python DSL, create simple to_python_dsl() method (see below)
3. Implement save_from_code(workflow_id, code, format) -> tuple[bool, str]:
   - Parse code based on format (YAML uses safe_load, JSON uses model_validate_json)
   - Return (False, error_message) if parsing fails
   - Preserve workflow.id from original on save
   - Return (True, "") on success
4. Add change listeners for notifying visual editor of updates

Add to Workflow model in models.py:
- to_python_dsl() method that generates readable Python-like code:
  ```python
  def to_python_dsl(self) -> str:
      lines = [f'workflow = Workflow(name="{self.name}")']
      for node in self.nodes:
          lines.append(f'workflow.add_node("{node.type}", name="{node.name}")')
      # Add connections
      for conn in self.connections:
          lines.append(f'workflow.connect("{conn.source_node_id}", "{conn.target_node_id}")')
      return "\n".join(lines)
  ```
- from_python_dsl(code: str) class method (use exec with restricted globals)

IMPORTANT: Use yaml.safe_load (not yaml.load) to prevent code execution attacks.
  </action>
  <verify>
    pytest tests/unit/test_workflow_bridge.py -v (create basic test)
    Verify WorkflowBridge can round-trip a workflow through YAML format
  </verify>
  <done>
    WorkflowBridge.load_as_code returns valid YAML/JSON/Python for test workflow
    WorkflowBridge.save_from_code parses code back to Workflow model
    Invalid code returns (False, error_message) without throwing exception
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate WorkflowBridge into CodeEditorView with format selector</name>
  <files>
    src/ui/views/code_editor/__init__.py
    src/ui/views/code_editor/toolbar.py
  </files>
  <action>
Update CodeEditorView to support workflow editing:

1. In __init__.py:
   - Import WorkflowBridge and WorkflowFormat
   - Add _workflow_bridge: WorkflowBridge | None = None
   - Add _current_workflow_id: str | None = None to track if editing workflow
   - Add _workflow_format: WorkflowFormat = WorkflowFormat.YAML

2. Add open_workflow(workflow_id: str, format: WorkflowFormat = YAML) method:
   - Create WorkflowBridge if not exists
   - Load workflow as code using bridge
   - Create virtual file path like "workflows/{workflow_name}.yaml"
   - Open in editor using existing open_file pattern
   - Store workflow_id for save operations

3. Override _save_current_async to detect workflow files:
   - If _current_workflow_id is set, use bridge.save_from_code()
   - Show validation error via _show_error() if parsing fails
   - Otherwise use normal file save

4. Update toolbar.py to add format dropdown:
   - Add format_dropdown: ft.Dropdown with YAML/JSON/Python options
   - Only visible when editing workflow (_current_workflow_id set)
   - on_change triggers format conversion via bridge

5. Add format conversion handler:
   - When format changes, convert current content to new format
   - Use bridge.load_as_code with new format and update editor
  </action>
  <verify>
    Manual test: Open workflow from storage, edit YAML, save, verify workflow updated
    pytest tests/unit/test_workflow_bridge.py tests/unit/test_editor_state.py -v
  </verify>
  <done>
    CodeEditorView.open_workflow() loads workflow as editable code
    Format dropdown appears when editing workflow, hidden for regular files
    Save writes changes back to workflow storage via bridge
    Format switch converts content between YAML/JSON/Python DSL
  </done>
</task>

<task type="auto">
  <name>Task 3: Add workflow validation and error handling</name>
  <files>
    src/ui/views/code_editor/workflow_bridge.py
    src/ui/views/code_editor/__init__.py
  </files>
  <action>
Add robust validation and error handling:

1. In workflow_bridge.py, add validate_code(code: str, format: WorkflowFormat) -> list[str]:
   - Return list of validation errors (empty if valid)
   - Check required fields: name, at least one node for non-empty workflow
   - Validate node types exist in registry (import NodeRegistry)
   - Validate connections reference existing nodes

2. Add real-time validation in CodeEditorView:
   - After content changes (debounced 500ms), run validation
   - Show warnings in status bar or editor gutter
   - Don't block save but warn user of issues

3. Handle edge cases:
   - Empty workflow (no nodes) - valid, just save
   - Circular connections - warn but allow (executor handles)
   - Unknown node types - error, don't save
   - Duplicate node IDs - error, don't save

4. Add sync notification:
   - When workflow saved via code, emit change event
   - Visual workflow editor can subscribe to refresh
   - Use existing listener pattern from EditorState
  </action>
  <verify>
    pytest tests/unit/test_workflow_bridge.py -v --tb=short
    Test: Invalid YAML shows error, doesn't corrupt workflow
    Test: Missing required fields caught by validation
  </verify>
  <done>
    validate_code returns meaningful errors for invalid workflows
    Unknown node types prevent save with clear error message
    Workflow changes via code emit notification for visual sync
    User sees validation warnings in editor
  </done>
</task>

</tasks>

<verification>
After all tasks:
1. pytest tests/unit/test_workflow_bridge.py -v - All workflow bridge tests pass
2. Open app, create workflow, open in code editor, edit YAML, save, verify changes persist
3. Introduce syntax error in YAML, verify error message and no corruption
4. Switch formats (YAML -> JSON -> Python DSL), verify content converts correctly
</verification>

<success_criteria>
- User can open any workflow as editable YAML/JSON/Python code in code editor
- User can modify workflow code and save changes back to storage
- Invalid code shows clear error message without corrupting the workflow
- Format switching preserves workflow semantics while changing syntax
- INTG-01 requirement satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/05-advanced-integration/05-01-SUMMARY.md`
</output>
