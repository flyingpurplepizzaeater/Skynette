---
phase: 16-mcp-tool-registration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/agent/mcp/bridge/__init__.py
  - src/agent/mcp/bridge/tool_bridge.py
  - src/agent/mcp/__init__.py
  - src/ui/app.py
  - tests/agent/mcp/test_tool_bridge.py
autonomous: true

must_haves:
  truths:
    - "MCP tools are registered with ToolRegistry when server connects"
    - "MCP tools are unregistered from ToolRegistry when server disconnects"
    - "Agent can invoke MCP-provided tools successfully"
    - "Transient disconnects don't immediately unregister tools (graceful timeout)"
    - "Reconnection cancels pending unregistration"
  artifacts:
    - path: "src/agent/mcp/bridge/tool_bridge.py"
      provides: "MCPToolBridge coordinator class"
      exports: ["MCPToolBridge", "get_mcp_tool_bridge"]
    - path: "src/agent/mcp/bridge/__init__.py"
      provides: "Bridge module exports"
      exports: ["MCPToolBridge", "get_mcp_tool_bridge", "initialize_mcp_tools"]
    - path: "tests/agent/mcp/test_tool_bridge.py"
      provides: "Unit tests for MCPToolBridge"
      min_lines: 100
  key_links:
    - from: "src/agent/mcp/bridge/tool_bridge.py"
      to: "src/agent/mcp/client/manager.py"
      via: "get_mcp_client_manager()"
      pattern: "get_mcp_client_manager\\(\\)"
    - from: "src/agent/mcp/bridge/tool_bridge.py"
      to: "src/agent/registry/tool_registry.py"
      via: "get_tool_registry()"
      pattern: "register_mcp_tools_from_server|unregister_mcp_tools_from_server"
    - from: "src/ui/app.py"
      to: "src/agent/mcp/bridge/tool_bridge.py"
      via: "initialize_mcp_tools() on startup"
      pattern: "initialize_mcp_tools"
---

<objective>
Wire MCP server tools into ToolRegistry on connect/disconnect so the agent can invoke them.

Purpose: Close the MCP-04 gap where MCP tools are discovered but never registered - the agent currently cannot use MCP-provided tools because they're not in the ToolRegistry.

Output: MCPToolBridge class that coordinates tool registration lifecycle, startup initialization, and unit tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-mcp-tool-registration/16-CONTEXT.md
@.planning/phases/16-mcp-tool-registration/16-RESEARCH.md

Key existing code:
@src/agent/registry/tool_registry.py (ToolRegistry with register_mcp_tools_from_server, unregister_mcp_tools_from_server)
@src/agent/mcp/client/manager.py (MCPClientManager with connect, disconnect, handle_connection_lost)
@src/agent/mcp/adapter/tool_adapter.py (MCPToolAdapter wraps MCP tools as BaseTool)
@src/agent/mcp/storage/server_storage.py (MCPServerStorage.list_servers)
@src/ui/app.py (SkynetteApp.initialize - where MCP init should be called)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MCPToolBridge coordinator class</name>
  <files>
    src/agent/mcp/bridge/__init__.py
    src/agent/mcp/bridge/tool_bridge.py
  </files>
  <action>
Create the MCPToolBridge singleton class in `src/agent/mcp/bridge/tool_bridge.py`:

1. Follow existing singleton pattern (like MCPClientManager, ToolRegistry)
2. Inject dependencies: MCPClientManager (via get_mcp_client_manager) and ToolRegistry (via get_tool_registry)
3. Track pending unregister tasks per server_id in `_pending_unregister: dict[str, asyncio.Task]`
4. Set `GRACEFUL_UNREGISTER_TIMEOUT = 5.0` seconds (per 16-CONTEXT.md)

Methods to implement:

`async def connect_and_register(self, config: MCPServerConfig) -> int`:
- Cancel any pending unregister task for this server_id
- Call `manager.connect(config)` to get connection
- Call `connection.list_tools()` to get tools
- Call `registry.register_mcp_tools_from_server(server_id, server_name, trust_level, tools)`
- Log info with count
- Return count

`async def disconnect_and_unregister(self, server_id: str, graceful: bool = True) -> None`:
- If graceful=True: Schedule delayed unregister via asyncio.create_task
  - Sleep for GRACEFUL_UNREGISTER_TIMEOUT
  - Call `registry.unregister_mcp_tools_from_server(server_id)`
  - Remove from _pending_unregister
  - Track task in _pending_unregister[server_id]
- If graceful=False: Immediate unregister
- Call `manager.disconnect(server_id)` after scheduling/completing

`def cancel_pending_unregister(self, server_id: str) -> bool`:
- Cancel task if exists in _pending_unregister
- Return True if cancelled, False if no pending task

Also create `async def initialize_mcp_tools() -> dict[str, int]`:
- Get bridge singleton
- Get storage via get_mcp_storage()
- List enabled servers via storage.list_servers(enabled_only=True)
- Connect and register all in parallel via asyncio.gather(return_exceptions=True)
- Log results (success count, error count)
- Return dict mapping server_id to tool count (or -1 for errors)

Create `src/agent/mcp/bridge/__init__.py` exporting:
- MCPToolBridge
- get_mcp_tool_bridge
- initialize_mcp_tools
  </action>
  <verify>
- File exists: `src/agent/mcp/bridge/tool_bridge.py`
- File exists: `src/agent/mcp/bridge/__init__.py`
- Python syntax check: `python -c "from src.agent.mcp.bridge import MCPToolBridge, get_mcp_tool_bridge, initialize_mcp_tools"`
  </verify>
  <done>
MCPToolBridge singleton class exists with connect_and_register(), disconnect_and_unregister(), cancel_pending_unregister() methods, plus initialize_mcp_tools() for startup.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire startup initialization into app</name>
  <files>
    src/agent/mcp/__init__.py
    src/ui/app.py
  </files>
  <action>
1. Update `src/agent/mcp/__init__.py` to export the bridge:
   - Add: `from src.agent.mcp.bridge import MCPToolBridge, get_mcp_tool_bridge, initialize_mcp_tools`
   - Add to __all__: "MCPToolBridge", "get_mcp_tool_bridge", "initialize_mcp_tools"

2. Update `src/ui/app.py` SkynetteApp.initialize() method:
   - After `initialize_default_providers()` (line ~106), add async MCP initialization
   - Since initialize() is synchronous, use asyncio.create_task to run in background:

   ```python
   # Initialize MCP tools (non-blocking)
   async def _init_mcp():
       try:
           from src.agent.mcp.bridge import initialize_mcp_tools
           results = await initialize_mcp_tools()
           logger.info(f"MCP initialization complete: {len(results)} servers")
       except Exception as e:
           logger.error(f"MCP initialization failed: {e}")

   asyncio.create_task(_init_mcp())
   ```

   Note: Use logging module for consistency with rest of codebase.
  </action>
  <verify>
- Python syntax check: `python -c "from src.agent.mcp import initialize_mcp_tools"`
- Grep confirms initialize_mcp_tools called in app.py: `grep -n "initialize_mcp_tools" src/ui/app.py`
  </verify>
  <done>
App startup calls initialize_mcp_tools() to connect to enabled MCP servers and register their tools with ToolRegistry.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for MCPToolBridge</name>
  <files>
    tests/agent/mcp/test_tool_bridge.py
  </files>
  <action>
Create comprehensive unit tests in `tests/agent/mcp/test_tool_bridge.py`:

Follow patterns from existing `tests/agent/mcp/test_integration.py`.

Test fixtures:
- `mock_manager`: Mocked MCPClientManager with connect, disconnect methods
- `mock_registry`: Mocked ToolRegistry with register/unregister methods
- `mock_storage`: Mocked MCPServerStorage with list_servers
- `bridge`: Fresh MCPToolBridge instance with mocked dependencies

Test classes:

`TestMCPToolBridgeConnectRegister`:
- test_connect_and_register_success: Mock connection returns tools, verify registry.register_mcp_tools_from_server called with correct args, returns tool count
- test_connect_and_register_cancels_pending_unregister: If pending unregister exists, verify it's cancelled before connect
- test_connect_and_register_connection_failure: Mock connect raises, verify exception propagates, no tools registered

`TestMCPToolBridgeDisconnectUnregister`:
- test_disconnect_graceful_schedules_delayed_unregister: Verify task created, not immediate
- test_disconnect_immediate_unregisters_now: With graceful=False, verify immediate unregister
- test_graceful_timeout_triggers_unregister: Use asyncio.sleep to let timeout elapse, verify unregister called
- test_reconnect_cancels_graceful_unregister: Connect during graceful window, verify unregister cancelled

`TestMCPToolBridgeInitialize`:
- test_initialize_mcp_tools_connects_enabled_servers: Mock storage returns 2 enabled servers, verify both connected
- test_initialize_mcp_tools_skips_disabled_servers: Mock storage returns only enabled, verify disabled not connected
- test_initialize_mcp_tools_handles_partial_failures: One server fails, verify others still connected, errors logged

Use `unittest.mock.patch` to inject mocked singletons.
Use `pytest.mark.asyncio` for async tests.
Use `asyncio.wait_for` with short timeout for graceful timeout tests.

Windows compatibility:
- Use gc.collect() before temp file cleanup (per 09-06 decision)
  </action>
  <verify>
- Tests pass: `python -m pytest tests/agent/mcp/test_tool_bridge.py -v`
  </verify>
  <done>
Unit tests verify MCPToolBridge correctly wires MCP server connections to ToolRegistry registration/unregistration, including graceful disconnect behavior and startup initialization.
  </done>
</task>

</tasks>

<verification>
1. Import check: `python -c "from src.agent.mcp.bridge import MCPToolBridge, get_mcp_tool_bridge, initialize_mcp_tools; print('OK')"`
2. Tests pass: `python -m pytest tests/agent/mcp/test_tool_bridge.py -v`
3. No import cycles: `python -c "from src.ui.app import SkynetteApp; print('OK')"`
</verification>

<success_criteria>
- MCPToolBridge class coordinates tool registration lifecycle
- connect_and_register() registers tools with ToolRegistry after connection
- disconnect_and_unregister() removes tools with graceful timeout option
- initialize_mcp_tools() connects all enabled servers on startup
- App.initialize() calls MCP initialization
- All unit tests pass
- Gap MCP-04 is closed: MCP tools are now usable by the agent
</success_criteria>

<output>
After completion, create `.planning/phases/16-mcp-tool-registration/16-01-SUMMARY.md`
</output>
