---
phase: 11-safety-and-approval-systems
plan: 03
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - src/agent/safety/approval.py
  - src/agent/safety/__init__.py
  - src/agent/__init__.py
autonomous: true

must_haves:
  truths:
    - "Approval requests block execution until user responds"
    - "User can approve, reject, or approve all similar actions"
    - "Similar actions are matched by tool name and parameter patterns"
    - "Approval decisions are scoped to current session only"
  artifacts:
    - path: "src/agent/safety/approval.py"
      provides: "ApprovalRequest, ApprovalResult, ApprovalManager"
      exports: ["ApprovalRequest", "ApprovalResult", "ApprovalDecision", "ApprovalManager"]
  key_links:
    - from: "src/agent/safety/approval.py"
      to: "src/agent/safety/classification.py"
      via: "ActionClassification import"
      pattern: "from.*classification import"
    - from: "ApprovalManager"
      to: "asyncio.Event"
      via: "async waiting"
      pattern: "asyncio\\.Event"
---

<objective>
Create the approval flow models and manager for human-in-the-loop approval

Purpose: Enable blocking on dangerous actions until user explicitly approves
Output: ApprovalRequest, ApprovalResult, ApprovalManager with similarity matching
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-safety-and-approval-systems/11-CONTEXT.md
@.planning/phases/11-safety-and-approval-systems/11-RESEARCH.md
@src/agent/safety/classification.py (from 11-01)
@src/agent/models/cancel.py (for pattern reference)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create approval data models</name>
  <files>src/agent/safety/approval.py</files>
  <action>
Create `src/agent/safety/approval.py` with approval models:

```python
"""
Approval Flow

Models and manager for human-in-the-loop approval of agent actions.
"""

import asyncio
import logging
from dataclasses import dataclass, field
from datetime import datetime, UTC
from pathlib import Path
from typing import Literal, Optional
from uuid import uuid4

from src.agent.safety.classification import ActionClassification

logger = logging.getLogger(__name__)

# Approval decision type
ApprovalDecision = Literal["approved", "rejected", "timeout"]


@dataclass
class ApprovalResult:
    """Result of an approval request."""

    decision: ApprovalDecision
    approve_similar: bool = False  # If True, auto-approve similar future actions
    modified_params: Optional[dict] = None  # If user modified parameters
    decided_at: datetime = field(default_factory=lambda: datetime.now(UTC))
    decided_by: str = "user"  # "user" or "similar_match"


@dataclass
class ApprovalRequest:
    """
    Request for user approval of an action.

    Contains the classification and provides async waiting.
    """

    id: str = field(default_factory=lambda: str(uuid4()))
    classification: ActionClassification = field(default_factory=lambda: ActionClassification(
        risk_level="moderate",
        reason="Unknown action",
        requires_approval=True,
        tool_name="unknown",
        parameters={},
    ))
    step_id: str = ""
    session_id: str = ""
    created_at: datetime = field(default_factory=lambda: datetime.now(UTC))

    # Internal async coordination
    _approved: asyncio.Event = field(default_factory=asyncio.Event, repr=False)
    result: Optional[ApprovalResult] = field(default=None, repr=False)

    async def wait_for_decision(self, timeout: Optional[float] = None) -> ApprovalResult:
        """
        Wait for user decision.

        Args:
            timeout: Optional timeout in seconds. None means wait indefinitely.

        Returns:
            ApprovalResult with decision

        Raises:
            asyncio.TimeoutError if timeout expires
        """
        try:
            await asyncio.wait_for(self._approved.wait(), timeout=timeout)
        except asyncio.TimeoutError:
            self.result = ApprovalResult(decision="timeout")
        return self.result

    def set_result(self, result: ApprovalResult):
        """Set the approval result and unblock waiting."""
        self.result = result
        self._approved.set()
```
  </action>
  <verify>Create ApprovalRequest and verify asyncio.Event is created: `ar = ApprovalRequest(); assert hasattr(ar, '_approved')`</verify>
  <done>ApprovalRequest and ApprovalResult dataclasses with async waiting capability</done>
</task>

<task type="auto">
  <name>Task 2: Create ApprovalManager with similarity matching</name>
  <files>src/agent/safety/approval.py</files>
  <action>
Add ApprovalManager class to approval.py:

```python
class ApprovalManager:
    """
    Manages pending approval requests and similarity matching.

    Handles:
    - Tracking pending approval requests
    - Similarity matching for "Approve All Similar"
    - Session-scoped approval caching
    """

    def __init__(self):
        """Initialize the approval manager."""
        self._pending: dict[str, ApprovalRequest] = {}
        # Cache of approved similar actions: (tool_name, pattern) -> True
        self._similarity_cache: dict[tuple[str, str], bool] = {}
        self._session_id: Optional[str] = None

    def start_session(self, session_id: str):
        """Start a new session, clearing any cached approvals."""
        self._session_id = session_id
        self._similarity_cache.clear()
        self._pending.clear()
        logger.debug(f"Approval manager started for session {session_id}")

    def end_session(self):
        """End the session and clear caches."""
        self._session_id = None
        self._similarity_cache.clear()
        self._pending.clear()

    async def request_approval(
        self,
        classification: ActionClassification,
        step_id: str,
        timeout: Optional[float] = 60.0,
    ) -> ApprovalResult:
        """
        Request approval for an action.

        First checks similarity cache for auto-approval.
        If not cached, creates request and waits for user.

        Args:
            classification: The action classification
            step_id: ID of the plan step requesting approval
            timeout: Seconds to wait before timeout (default 60s per CONTEXT.md)

        Returns:
            ApprovalResult with decision
        """
        # Check similarity cache first
        pattern = self._get_similarity_pattern(classification)
        cache_key = (classification.tool_name, pattern)

        if cache_key in self._similarity_cache:
            logger.debug(f"Auto-approved via similarity cache: {cache_key}")
            return ApprovalResult(
                decision="approved",
                approve_similar=False,
                decided_by="similar_match",
            )

        # Create and track request
        request = ApprovalRequest(
            classification=classification,
            step_id=step_id,
            session_id=self._session_id or "",
        )
        self._pending[request.id] = request

        logger.info(f"Approval requested for {classification.tool_name}: {classification.reason}")

        # Wait for decision
        result = await request.wait_for_decision(timeout=timeout)

        # Remove from pending
        self._pending.pop(request.id, None)

        # Update similarity cache if approved with "approve similar"
        if result.decision == "approved" and result.approve_similar:
            self._similarity_cache[cache_key] = True
            logger.debug(f"Added to similarity cache: {cache_key}")

        return result

    def approve(self, request_id: str, approve_similar: bool = False):
        """
        Approve a pending request.

        Args:
            request_id: ID of the request to approve
            approve_similar: If True, auto-approve similar future actions
        """
        request = self._pending.get(request_id)
        if request:
            request.set_result(ApprovalResult(
                decision="approved",
                approve_similar=approve_similar,
            ))
            logger.info(f"Approved request {request_id} (similar={approve_similar})")

    def reject(self, request_id: str):
        """
        Reject a pending request.

        Args:
            request_id: ID of the request to reject
        """
        request = self._pending.get(request_id)
        if request:
            request.set_result(ApprovalResult(decision="rejected"))
            logger.info(f"Rejected request {request_id}")

    def get_pending(self) -> list[ApprovalRequest]:
        """Get list of pending approval requests."""
        return list(self._pending.values())

    def _get_similarity_pattern(self, classification: ActionClassification) -> str:
        """
        Generate a pattern for similarity matching.

        For file operations: parent directory path
        For other tools: empty string (exact tool match only)
        """
        params = classification.parameters
        tool = classification.tool_name

        if tool in ("file_write", "file_read", "file_delete", "file_list"):
            path = params.get("path", "")
            if path:
                return str(Path(path).parent)

        # Default: no parameter pattern (matches all uses of same tool)
        return ""

    @staticmethod
    def are_similar(a1: ActionClassification, a2: ActionClassification) -> bool:
        """
        Check if two actions are similar enough for batch approval.

        Args:
            a1: First action
            a2: Second action

        Returns:
            True if similar, False otherwise
        """
        # Must be same tool
        if a1.tool_name != a2.tool_name:
            return False

        # For file operations: check if paths share parent or one is child of other
        if a1.tool_name in ("file_write", "file_read", "file_delete", "file_list"):
            path1 = Path(a1.parameters.get("path", ""))
            path2 = Path(a2.parameters.get("path", ""))

            # Same parent directory
            if path1.parent == path2.parent:
                return True

            # One is child of the other's parent
            try:
                if path2.is_relative_to(path1.parent) or path1.is_relative_to(path2.parent):
                    return True
            except (ValueError, TypeError):
                pass

            return False

        # For other tools: same tool name is enough
        return True
```
  </action>
  <verify>Test similarity: `ApprovalManager.are_similar(c1, c2)` where c1 and c2 are file_write to same directory</verify>
  <done>ApprovalManager with pending tracking, similarity caching, approve/reject methods</done>
</task>

<task type="auto">
  <name>Task 3: Export approval types and add global manager factory</name>
  <files>src/agent/safety/approval.py, src/agent/safety/__init__.py, src/agent/__init__.py</files>
  <action>
1. Add singleton factory to approval.py:

```python
# Module-level singleton
_global_approval_manager: Optional[ApprovalManager] = None


def get_approval_manager() -> ApprovalManager:
    """
    Get the global approval manager instance.

    Returns:
        Global ApprovalManager singleton
    """
    global _global_approval_manager
    if _global_approval_manager is None:
        _global_approval_manager = ApprovalManager()
    return _global_approval_manager
```

2. Update src/agent/safety/__init__.py to export:
```python
from .approval import (
    ApprovalDecision,
    ApprovalRequest,
    ApprovalResult,
    ApprovalManager,
    get_approval_manager,
)
```

3. Update src/agent/__init__.py to export approval types:
   - Add imports from safety module
   - Add to __all__
  </action>
  <verify>`from src.agent import ApprovalManager, get_approval_manager, ApprovalRequest`</verify>
  <done>Approval types exported from src.agent package with global manager factory</done>
</task>

</tasks>

<verification>
```python
# Verification script
import asyncio
from src.agent import (
    ApprovalManager,
    ApprovalRequest,
    ApprovalResult,
    ApprovalDecision,
    get_approval_manager,
    ActionClassification,
)

async def test_approval():
    manager = ApprovalManager()
    manager.start_session("test-session")

    # Create a classification
    classification = ActionClassification(
        risk_level="destructive",
        reason="Destructive: modifies file /src/test.py",
        requires_approval=True,
        tool_name="file_write",
        parameters={"path": "/src/test.py", "content": "test"},
    )

    # Test immediate approval (simulate UI callback)
    async def approve_after_delay():
        await asyncio.sleep(0.1)
        pending = manager.get_pending()
        assert len(pending) == 1
        manager.approve(pending[0].id, approve_similar=True)

    # Run approval request and auto-approve concurrently
    task = asyncio.create_task(approve_after_delay())
    result = await manager.request_approval(classification, "step-1", timeout=5.0)
    await task

    assert result.decision == "approved"
    assert result.approve_similar == True

    # Test similarity cache - second request should auto-approve
    classification2 = ActionClassification(
        risk_level="destructive",
        reason="Destructive: modifies file /src/other.py",
        requires_approval=True,
        tool_name="file_write",
        parameters={"path": "/src/other.py", "content": "test2"},
    )

    result2 = await manager.request_approval(classification2, "step-2", timeout=1.0)
    assert result2.decision == "approved"
    assert result2.decided_by == "similar_match"

    # Test singleton
    m1 = get_approval_manager()
    m2 = get_approval_manager()
    assert m1 is m2

    print("All approval tests passed!")

asyncio.run(test_approval())
```
</verification>

<success_criteria>
- ApprovalRequest with async wait_for_decision() and set_result()
- ApprovalResult with decision, approve_similar, modified_params fields
- ApprovalManager tracks pending requests
- Similarity matching for file operations (same parent directory)
- Similarity cache auto-approves after "Approve All Similar"
- Session-scoped caching (clears on end_session)
- Global singleton via get_approval_manager()
- All types exported from src.agent
</success_criteria>

<output>
After completion, create `.planning/phases/11-safety-and-approval-systems/11-03-SUMMARY.md`
</output>
