---
phase: 11-safety-and-approval-systems
plan: 06
type: execute
wave: 4
depends_on: ["11-01", "11-02", "11-03", "11-04"]
files_modified:
  - src/agent/loop/executor.py
  - src/agent/models/event.py
autonomous: true

must_haves:
  truths:
    - "Executor classifies each tool action before execution"
    - "Actions requiring approval pause and emit approval_requested event"
    - "Kill switch is checked at every step boundary"
    - "All tool executions are logged to audit trail"
  artifacts:
    - path: "src/agent/loop/executor.py"
      provides: "Safety-integrated executor with classification, approval, kill switch, audit"
  key_links:
    - from: "src/agent/loop/executor.py"
      to: "src/agent/safety/classification.py"
      via: "ActionClassifier import"
      pattern: "ActionClassifier"
    - from: "src/agent/loop/executor.py"
      to: "src/agent/safety/approval.py"
      via: "ApprovalManager import"
      pattern: "ApprovalManager"
    - from: "src/agent/loop/executor.py"
      to: "src/agent/safety/kill_switch.py"
      via: "get_kill_switch import"
      pattern: "get_kill_switch"
    - from: "src/agent/loop/executor.py"
      to: "src/agent/safety/audit.py"
      via: "get_audit_store import"
      pattern: "get_audit_store"
---

<objective>
Integrate safety systems into the agent executor: classification, approval, kill switch, and audit

Purpose: Wire all safety components into the execution loop for complete protection
Output: Enhanced AgentExecutor with safety checks at every action
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-safety-and-approval-systems/11-CONTEXT.md
@.planning/phases/11-safety-and-approval-systems/11-RESEARCH.md
@src/agent/loop/executor.py
@src/agent/models/event.py
@src/agent/safety/classification.py (from 11-01)
@src/agent/safety/kill_switch.py (from 11-02)
@src/agent/safety/approval.py (from 11-03)
@src/agent/safety/audit.py (from 11-04)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add new event types for safety system</name>
  <files>src/agent/models/event.py</files>
  <action>
Update `src/agent/models/event.py` to add safety-related event types:

1. Update AgentEventType Literal to include:
   - `"action_classified"` - emitted when action is classified
   - `"approval_requested"` - emitted when approval is needed
   - `"approval_received"` - emitted when user responds
   - `"kill_switch_triggered"` - emitted when kill switch stops execution

2. Add factory methods to AgentEvent class:

```python
@classmethod
def action_classified(
    cls,
    tool_name: str,
    risk_level: str,
    reason: str,
    requires_approval: bool,
    session_id: str,
) -> "AgentEvent":
    """Create an action_classified event."""
    return cls(
        type="action_classified",
        data={
            "tool_name": tool_name,
            "risk_level": risk_level,
            "reason": reason,
            "requires_approval": requires_approval,
        },
        session_id=session_id,
    )

@classmethod
def approval_requested(
    cls,
    request_id: str,
    tool_name: str,
    risk_level: str,
    reason: str,
    parameters: dict,
    session_id: str,
) -> "AgentEvent":
    """Create an approval_requested event."""
    return cls(
        type="approval_requested",
        data={
            "request_id": request_id,
            "tool_name": tool_name,
            "risk_level": risk_level,
            "reason": reason,
            "parameters": parameters,
        },
        session_id=session_id,
    )

@classmethod
def approval_received(
    cls,
    request_id: str,
    decision: str,  # "approved", "rejected", "timeout"
    approve_similar: bool,
    session_id: str,
) -> "AgentEvent":
    """Create an approval_received event."""
    return cls(
        type="approval_received",
        data={
            "request_id": request_id,
            "decision": decision,
            "approve_similar": approve_similar,
        },
        session_id=session_id,
    )

@classmethod
def kill_switch_triggered(cls, reason: str, session_id: str) -> "AgentEvent":
    """Create a kill_switch_triggered event."""
    return cls(
        type="kill_switch_triggered",
        data={"reason": reason},
        session_id=session_id,
    )
```
  </action>
  <verify>Import new event type: `from src.agent.models.event import AgentEvent; AgentEvent.action_classified("test", "safe", "reason", False, "s1")`</verify>
  <done>New event types and factory methods for safety system integration</done>
</task>

<task type="auto">
  <name>Task 2: Integrate safety systems into AgentExecutor</name>
  <files>src/agent/loop/executor.py</files>
  <action>
Update `src/agent/loop/executor.py` to integrate safety systems:

1. Add imports at top:
```python
from src.agent.safety import (
    ActionClassifier,
    get_kill_switch,
    get_approval_manager,
    get_audit_store,
    AuditEntry,
)
```

2. Add safety components to __init__:
```python
def __init__(self, session: AgentSession):
    # ... existing init ...
    self.classifier = ActionClassifier()
    self.kill_switch = get_kill_switch()
    self.approval_manager = get_approval_manager()
    self.audit_store = get_audit_store()
```

3. Update run() method to:
   - Reset kill switch at start
   - Start approval manager session
   - Check kill switch in main loop (add check alongside existing _should_cancel)

4. Add kill switch check method:
```python
def _check_kill_switch(self) -> bool:
    """Check if kill switch has been triggered."""
    return self.kill_switch.is_triggered()
```

5. Update main execution loop in run() to check kill switch:
```python
# Add after existing cancellation check:
if self._check_kill_switch():
    self.session.state = AgentState.CANCELLED
    yield AgentEvent.kill_switch_triggered(
        self.kill_switch.trigger_reason or "Kill switch activated",
        self.session.id
    )
    return
```

6. End approval session and reset kill switch in cleanup.
  </action>
  <verify>Executor initializes with classifier, kill_switch, approval_manager, audit_store</verify>
  <done>AgentExecutor has safety components initialized and kill switch checked in main loop</done>
</task>

<task type="auto">
  <name>Task 3: Add classification and approval to tool execution</name>
  <files>src/agent/loop/executor.py</files>
  <action>
Update _execute_tool_with_retry to include classification, approval, and audit:

```python
async def _execute_tool_with_retry(
    self,
    tool_name: str,
    params: dict,
    step_id: str = "",
) -> ToolResult:
    """
    Execute a tool with classification, approval (if needed), retry, and audit.
    """
    start_time = time.time()

    # 1. Classify the action
    classification = self.classifier.classify(tool_name, params)

    # Emit classification event
    await self.emitter.emit(AgentEvent.action_classified(
        tool_name=tool_name,
        risk_level=classification.risk_level,
        reason=classification.reason,
        requires_approval=classification.requires_approval,
        session_id=self.session.id,
    ))

    # 2. Request approval if needed
    approval_decision = "auto"
    approval_time_ms = None

    if classification.requires_approval:
        self.session.state = AgentState.AWAITING_APPROVAL

        # Emit approval request event (UI will show ApprovalSheet)
        await self.emitter.emit(AgentEvent.approval_requested(
            request_id="",  # Will be set by approval manager
            tool_name=tool_name,
            risk_level=classification.risk_level,
            reason=classification.reason,
            parameters=params,
            session_id=self.session.id,
        ))

        approval_start = time.time()
        result = await self.approval_manager.request_approval(
            classification=classification,
            step_id=step_id,
            timeout=60.0,  # 60s default per CONTEXT.md
        )
        approval_time_ms = (time.time() - approval_start) * 1000

        # Emit approval result event
        await self.emitter.emit(AgentEvent.approval_received(
            request_id="",
            decision=result.decision,
            approve_similar=result.approve_similar,
            session_id=self.session.id,
        ))

        approval_decision = result.decision

        if result.decision == "rejected":
            return ToolResult.failure_result(
                tool_call_id="rejected",
                error="Action rejected by user",
            )
        elif result.decision == "timeout":
            # Per CONTEXT.md: pause (don't auto-reject)
            return ToolResult.failure_result(
                tool_call_id="timeout",
                error="Approval timeout - action skipped",
            )

        self.session.state = AgentState.EXECUTING

    # 3. Execute the tool (existing code)
    tool = self.registry.get_tool(tool_name)
    if tool is None:
        return ToolResult.failure_result(
            tool_call_id="unknown",
            error=f"Tool not found: {tool_name}"
        )

    # ... existing validation and retry code ...
    # (Keep existing _retry_tool_execution call)
    result = await self._retry_tool_execution(tool, params, context)

    # 4. Audit the action
    duration_ms = (time.time() - start_time) * 1000
    audit_entry = AuditEntry(
        session_id=self.session.id,
        step_id=step_id,
        tool_name=tool_name,
        parameters=params,
        result={"data": result.data} if result.success else None,
        error=result.error,
        duration_ms=duration_ms,
        risk_level=classification.risk_level,
        approval_required=classification.requires_approval,
        approval_decision=approval_decision,
        approved_by="user" if approval_decision == "approved" else None,
        approval_time_ms=approval_time_ms,
        success=result.success,
    )
    self.audit_store.log(audit_entry)

    return result
```

Update _execute_step to pass step_id to _execute_tool_with_retry.
  </action>
  <verify>Tool execution includes classification, approval check, and audit logging</verify>
  <done>Complete safety flow: classify -> approve (if needed) -> execute -> audit</done>
</task>

</tasks>

<verification>
```python
# Verification script - test integration points exist
from src.agent.loop.executor import AgentExecutor
from src.agent.models.state import AgentSession
from src.agent.models.event import AgentEvent

# Verify new event types exist
event = AgentEvent.action_classified("test_tool", "safe", "Safe operation", False, "session-1")
assert event.type == "action_classified"

event = AgentEvent.approval_requested("req-1", "file_write", "destructive", "Writes file", {}, "session-1")
assert event.type == "approval_requested"

event = AgentEvent.kill_switch_triggered("User triggered", "session-1")
assert event.type == "kill_switch_triggered"

# Verify executor has safety components
session = AgentSession(task="test")
executor = AgentExecutor(session)

assert hasattr(executor, 'classifier')
assert hasattr(executor, 'kill_switch')
assert hasattr(executor, 'approval_manager')
assert hasattr(executor, 'audit_store')

print("All executor integration tests passed!")
```
</verification>

<success_criteria>
- New event types: action_classified, approval_requested, approval_received, kill_switch_triggered
- AgentExecutor initializes classifier, kill_switch, approval_manager, audit_store
- Kill switch checked at every step boundary in main loop
- Tool execution classifies action before execution
- Destructive/critical actions pause for approval
- All tool executions logged to audit store
- Events emitted for classification, approval request, approval response
- Approval timeout results in skipped action (not auto-reject)
</success_criteria>

<output>
After completion, create `.planning/phases/11-safety-and-approval-systems/11-06-SUMMARY.md`
</output>
