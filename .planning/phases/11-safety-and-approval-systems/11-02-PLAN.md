---
phase: 11-safety-and-approval-systems
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/agent/safety/kill_switch.py
  - src/agent/safety/__init__.py
autonomous: true

must_haves:
  truths:
    - "Kill switch can be triggered from any thread or process"
    - "Kill switch state is checkable without blocking"
    - "Kill switch can be reset for new executions"
    - "Kill switch works even if agent loop is blocked"
  artifacts:
    - path: "src/agent/safety/kill_switch.py"
      provides: "KillSwitch class with multiprocessing.Event"
      exports: ["KillSwitch"]
  key_links:
    - from: "src/agent/safety/kill_switch.py"
      to: "multiprocessing.Event"
      via: "inter-process communication"
      pattern: "multiprocessing\\.Event"
---

<objective>
Create the kill switch mechanism that operates outside the agent process

Purpose: Emergency stop that works even when UI is sluggish or agent is in tight loop
Output: KillSwitch class using multiprocessing.Event for cross-thread/process safety
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-safety-and-approval-systems/11-CONTEXT.md
@.planning/phases/11-safety-and-approval-systems/11-RESEARCH.md
@src/agent/loop/executor.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create KillSwitch class with multiprocessing.Event</name>
  <files>src/agent/safety/kill_switch.py</files>
  <action>
Create `src/agent/safety/kill_switch.py`:

```python
"""
Kill Switch

Emergency stop mechanism that operates outside the agent event loop.
Uses multiprocessing.Event for cross-thread/process communication.
"""

import logging
import multiprocessing
from datetime import datetime, UTC
from typing import Optional

logger = logging.getLogger(__name__)


class KillSwitch:
    """
    Kill switch for emergency agent termination.

    Uses multiprocessing.Event for inter-process communication,
    allowing the kill switch to work even if the agent loop is blocked.

    Usage:
        kill_switch = KillSwitch()

        # In UI/external thread:
        kill_switch.trigger()

        # In agent loop:
        if kill_switch.is_triggered():
            # Stop execution
            pass

        # Reset for new execution:
        kill_switch.reset()
    """

    def __init__(self):
        """Initialize kill switch with multiprocessing Event."""
        self._stop_event = multiprocessing.Event()
        self._triggered_at: Optional[datetime] = None
        self._trigger_reason: Optional[str] = None

    def trigger(self, reason: str = "Kill switch activated"):
        """
        Trigger the kill switch.

        Can be called from any thread or process.

        Args:
            reason: Human-readable reason for triggering
        """
        self._stop_event.set()
        self._triggered_at = datetime.now(UTC)
        self._trigger_reason = reason
        logger.warning(f"Kill switch triggered: {reason}")

    def is_triggered(self) -> bool:
        """
        Check if kill switch has been triggered.

        Non-blocking check that can be called frequently.

        Returns:
            True if triggered, False otherwise
        """
        return self._stop_event.is_set()

    def reset(self):
        """
        Reset the kill switch for a new execution.

        Should be called before starting a new agent task.
        """
        self._stop_event.clear()
        self._triggered_at = None
        self._trigger_reason = None
        logger.debug("Kill switch reset")

    @property
    def triggered_at(self) -> Optional[datetime]:
        """Timestamp when kill switch was triggered."""
        return self._triggered_at

    @property
    def trigger_reason(self) -> Optional[str]:
        """Reason provided when kill switch was triggered."""
        return self._trigger_reason

    def get_status(self) -> dict:
        """
        Get kill switch status as dict.

        Returns:
            Dict with triggered, triggered_at, and reason fields
        """
        return {
            "triggered": self.is_triggered(),
            "triggered_at": self._triggered_at.isoformat() if self._triggered_at else None,
            "reason": self._trigger_reason,
        }
```

Note: multiprocessing.Event is cross-platform (Windows, macOS, Linux) and atomic.
  </action>
  <verify>Create instance and test: `ks = KillSwitch(); ks.trigger(); assert ks.is_triggered(); ks.reset(); assert not ks.is_triggered()`</verify>
  <done>KillSwitch class with trigger(), is_triggered(), reset() methods using multiprocessing.Event</done>
</task>

<task type="auto">
  <name>Task 2: Create global kill switch factory and export</name>
  <files>src/agent/safety/kill_switch.py, src/agent/safety/__init__.py</files>
  <action>
1. Add module-level factory function to kill_switch.py (follows ToolRegistry pattern):

```python
# Module-level singleton instance
_global_kill_switch: Optional[KillSwitch] = None


def get_kill_switch() -> KillSwitch:
    """
    Get the global kill switch instance.

    Creates one if it doesn't exist (singleton pattern).

    Returns:
        Global KillSwitch instance
    """
    global _global_kill_switch
    if _global_kill_switch is None:
        _global_kill_switch = KillSwitch()
    return _global_kill_switch
```

2. Update src/agent/safety/__init__.py to export:
   - `from .kill_switch import KillSwitch, get_kill_switch`

3. Update src/agent/__init__.py to include KillSwitch exports:
   - Add: `from src.agent.safety import KillSwitch, get_kill_switch`
   - Add to __all__
  </action>
  <verify>`from src.agent import KillSwitch, get_kill_switch; ks = get_kill_switch(); ks2 = get_kill_switch(); assert ks is ks2`</verify>
  <done>Global kill switch singleton available via get_kill_switch() and exported from src.agent</done>
</task>

<task type="auto">
  <name>Task 3: Add keyboard shortcut constant for future UI integration</name>
  <files>src/agent/safety/kill_switch.py</files>
  <action>
Add constant for kill switch keyboard shortcut at module level:

```python
# Default keyboard shortcut for kill switch (can be overridden in settings)
# Using Ctrl+Shift+K as it's unlikely to conflict with other shortcuts
KILL_SWITCH_SHORTCUT = "ctrl+shift+k"

# Alternative shortcuts for different platforms
KILL_SWITCH_SHORTCUTS = {
    "windows": "ctrl+shift+k",
    "darwin": "cmd+shift+k",  # macOS
    "linux": "ctrl+shift+k",
}
```

This prepares for Phase 12 UI integration where the keyboard shortcut will be wired up.
The actual shortcut registration will happen in the UI layer.
  </action>
  <verify>Import constant: `from src.agent.safety.kill_switch import KILL_SWITCH_SHORTCUT`</verify>
  <done>Keyboard shortcut constants defined for future UI integration</done>
</task>

</tasks>

<verification>
```python
# Verification script
import threading
import time
from src.agent import KillSwitch, get_kill_switch

# Test basic functionality
ks = KillSwitch()
assert not ks.is_triggered()
ks.trigger("Test trigger")
assert ks.is_triggered()
assert "Test trigger" in ks.trigger_reason
assert ks.triggered_at is not None
ks.reset()
assert not ks.is_triggered()

# Test singleton
ks1 = get_kill_switch()
ks2 = get_kill_switch()
assert ks1 is ks2

# Test cross-thread access
global_ks = get_kill_switch()
global_ks.reset()

def trigger_from_thread():
    time.sleep(0.1)
    global_ks.trigger("From thread")

thread = threading.Thread(target=trigger_from_thread)
thread.start()
thread.join()
assert global_ks.is_triggered()

# Test status dict
status = global_ks.get_status()
assert status["triggered"] == True
assert "From thread" in status["reason"]

print("All kill switch tests passed!")
```
</verification>

<success_criteria>
- KillSwitch class with trigger(), is_triggered(), reset() methods
- Uses multiprocessing.Event for cross-thread/process safety
- Global singleton via get_kill_switch() factory
- triggered_at and trigger_reason properties for audit trail
- get_status() returns dict for serialization
- Keyboard shortcut constants for Phase 12 UI
- Exported from src.agent package
</success_criteria>

<output>
After completion, create `.planning/phases/11-safety-and-approval-systems/11-02-SUMMARY.md`
</output>
