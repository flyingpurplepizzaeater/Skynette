---
phase: 07-agent-core-infrastructure
plan: 03
type: execute
wave: 2
depends_on: ["07-01", "07-02"]
files_modified:
  - src/agent/budget/__init__.py
  - src/agent/budget/token_budget.py
  - src/agent/events/__init__.py
  - src/agent/events/emitter.py
  - src/agent/loop/__init__.py
  - src/agent/loop/executor.py
  - src/agent/loop/planner.py
autonomous: true

must_haves:
  truths:
    - "TokenBudget tracks input/output tokens with remaining() and can_proceed()"
    - "AgentEventEmitter broadcasts events to async subscribers"
    - "AgentPlanner generates plan from task using AI Gateway"
    - "AgentExecutor runs plan steps with retry and budget enforcement"
    - "Failed tool calls retry with exponential backoff (3 attempts)"
  artifacts:
    - path: "src/agent/budget/token_budget.py"
      provides: "TokenBudget class for resource management"
      exports: ["TokenBudget"]
    - path: "src/agent/events/emitter.py"
      provides: "AgentEventEmitter for streaming events"
      exports: ["AgentEventEmitter"]
    - path: "src/agent/loop/planner.py"
      provides: "AgentPlanner for task decomposition"
      exports: ["AgentPlanner"]
    - path: "src/agent/loop/executor.py"
      provides: "AgentExecutor for plan execution"
      exports: ["AgentExecutor"]
  key_links:
    - from: "src/agent/loop/executor.py"
      to: "src/ai/gateway.py"
      via: "Uses get_gateway() for LLM calls"
      pattern: "from src\\.ai\\.gateway import.*get_gateway"
    - from: "src/agent/loop/executor.py"
      to: "src/agent/registry/tool_registry.py"
      via: "Uses get_tool_registry() for tool invocation"
      pattern: "from src\\.agent\\.registry import.*get_tool_registry"
    - from: "src/agent/loop/executor.py"
      to: "tenacity"
      via: "Uses @retry decorator for tool execution"
      pattern: "@retry"
---

<objective>
Create the agent runtime: token budget tracking, event broadcasting, plan generation, and step execution with retry logic.

Purpose: This plan wires together the models (Plan 01) and tools (Plan 02) into a functioning agent loop. The executor handles plan steps, invokes tools with retry, respects budget limits, and emits events for UI consumption.

Output: `src/agent/budget/`, `src/agent/events/`, and `src/agent/loop/` directories with working components
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-agent-core-infrastructure/07-RESEARCH.md

# Dependencies from prior plans
@src/agent/models/state.py
@src/agent/models/plan.py
@src/agent/models/event.py
@src/agent/models/tool.py
@src/agent/registry/tool_registry.py

# Existing infrastructure to use
@src/ai/gateway.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TokenBudget and event emitter</name>
  <files>
    src/agent/budget/__init__.py
    src/agent/budget/token_budget.py
    src/agent/events/__init__.py
    src/agent/events/emitter.py
  </files>
  <action>
**Install tenacity dependency:**
```bash
pip install "tenacity>=9.0.0"
```
Add to requirements.txt or pyproject.toml if the project uses one.

**Create `src/agent/budget/token_budget.py`:**

```python
from dataclasses import dataclass, field

@dataclass
class TokenBudget:
    """Track token usage against a budget."""

    max_tokens: int = 50000  # Default 50K tokens per task
    used_input_tokens: int = 0
    used_output_tokens: int = 0
    warning_threshold: float = 0.8  # Warn at 80%

    @property
    def used_total(self) -> int:
        """Total tokens consumed."""
        return self.used_input_tokens + self.used_output_tokens

    @property
    def remaining(self) -> int:
        """Tokens remaining in budget."""
        return max(0, self.max_tokens - self.used_total)

    @property
    def usage_percentage(self) -> float:
        """Usage as percentage (0.0 to 1.0)."""
        if self.max_tokens == 0:
            return 1.0
        return self.used_total / self.max_tokens

    def can_proceed(self, estimated_tokens: int = 0) -> bool:
        """Check if we can proceed with estimated additional usage."""
        return (self.used_total + estimated_tokens) <= self.max_tokens

    def consume(self, input_tokens: int, output_tokens: int) -> bool:
        """
        Record token consumption.
        Returns True if within budget, False if exceeded.
        """
        self.used_input_tokens += input_tokens
        self.used_output_tokens += output_tokens
        return self.used_total <= self.max_tokens

    def is_warning(self) -> bool:
        """True if approaching budget limit."""
        return self.usage_percentage >= self.warning_threshold

    def to_dict(self) -> dict:
        """Convert to dict for event data."""
        return {
            "max_tokens": self.max_tokens,
            "used_input": self.used_input_tokens,
            "used_output": self.used_output_tokens,
            "used_total": self.used_total,
            "remaining": self.remaining,
            "percentage": round(self.usage_percentage * 100, 1),
        }
```

**Create `src/agent/events/emitter.py`:**

```python
import asyncio
from typing import AsyncIterator, Optional
from src.agent.models.event import AgentEvent

class AgentEventEmitter:
    """Broadcast agent events to async subscribers."""

    def __init__(self):
        self._subscribers: list[asyncio.Queue[AgentEvent]] = []

    async def emit(self, event: AgentEvent):
        """Emit event to all subscribers."""
        for queue in self._subscribers:
            try:
                queue.put_nowait(event)
            except asyncio.QueueFull:
                # Drop event if subscriber is slow (bounded queue)
                pass

    def subscribe(self, maxsize: int = 100) -> "EventSubscription":
        """
        Create a subscription to events.
        Returns an EventSubscription that can be iterated.
        """
        queue: asyncio.Queue[AgentEvent] = asyncio.Queue(maxsize=maxsize)
        self._subscribers.append(queue)
        return EventSubscription(queue, self)

    def _unsubscribe(self, queue: asyncio.Queue):
        """Remove a subscriber queue."""
        if queue in self._subscribers:
            self._subscribers.remove(queue)


class EventSubscription:
    """Async iterator for event subscription."""

    def __init__(self, queue: asyncio.Queue[AgentEvent], emitter: AgentEventEmitter):
        self._queue = queue
        self._emitter = emitter
        self._active = True

    async def __aiter__(self) -> AsyncIterator[AgentEvent]:
        while self._active:
            try:
                event = await asyncio.wait_for(self._queue.get(), timeout=1.0)
                yield event
                if event.type in ("completed", "cancelled", "error"):
                    break
            except asyncio.TimeoutError:
                continue

    def close(self):
        """Close the subscription."""
        self._active = False
        self._emitter._unsubscribe(self._queue)
```

Create `__init__.py` files exporting TokenBudget, AgentEventEmitter, EventSubscription.
  </action>
  <verify>
Run: `python -c "
from src.agent.budget import TokenBudget
from src.agent.events import AgentEventEmitter

# Test budget
b = TokenBudget(max_tokens=1000)
b.consume(400, 100)
print(f'Budget: {b.used_total}/{b.max_tokens}, can_proceed: {b.can_proceed(400)}')

# Test emitter
import asyncio
async def test_emitter():
    from src.agent.models.event import AgentEvent
    emitter = AgentEventEmitter()
    sub = emitter.subscribe()
    await emitter.emit(AgentEvent(type='message', data={'text': 'hello'}))
    event = await asyncio.wait_for(sub._queue.get(), timeout=1.0)
    print(f'Event received: {event.type}')
    sub.close()
asyncio.run(test_emitter())
"`
Expected: Prints budget info and "Event received: message"
  </verify>
  <done>TokenBudget tracks usage with remaining/can_proceed; AgentEventEmitter broadcasts to async subscribers</done>
</task>

<task type="auto">
  <name>Task 2: Create AgentPlanner</name>
  <files>
    src/agent/loop/__init__.py
    src/agent/loop/planner.py
  </files>
  <action>
**Create `src/agent/loop/planner.py`:**

```python
import json
import logging
from typing import Optional
from src.ai.gateway import get_gateway, AIMessage, GenerationConfig
from src.agent.models.plan import AgentPlan, PlanStep
from src.agent.registry import get_tool_registry

logger = logging.getLogger(__name__)

class AgentPlanner:
    """Generate execution plans from user tasks."""

    SYSTEM_PROMPT = '''You are a planning agent. Break down the user's task into concrete, executable steps.

Available tools:
{tools}

Return a JSON object with:
- "overview": One sentence summary of your approach
- "steps": Array of step objects, each with:
  - "description": What this step accomplishes
  - "tool_name": Name of tool to use (optional, null if no tool needed)
  - "tool_params": Parameters for the tool (optional, empty object if no tool)
  - "dependencies": Array of step indices (0-based) that must complete first

Guidelines:
- Keep plans simple: 3-7 steps typically sufficient
- Each step should be atomic and verifiable
- Use tools when available; describe manual reasoning otherwise
- Order steps logically with correct dependencies

Return ONLY valid JSON, no markdown formatting.'''

    def __init__(self):
        self.gateway = get_gateway()
        self.registry = get_tool_registry()

    def _get_tools_description(self) -> str:
        """Get formatted tool descriptions for prompt."""
        definitions = self.registry.get_all_definitions()
        if not definitions:
            return "No tools available."

        lines = []
        for d in definitions:
            params = json.dumps(d.parameters, indent=2)
            lines.append(f"- {d.name}: {d.description}\n  Parameters: {params}")
        return "\n".join(lines)

    async def create_plan(self, task: str, context: Optional[dict] = None) -> AgentPlan:
        """
        Generate an execution plan for the given task.

        Args:
            task: User's task description
            context: Optional context (e.g., prior conversation)

        Returns:
            AgentPlan with steps
        """
        tools_desc = self._get_tools_description()
        system_content = self.SYSTEM_PROMPT.format(tools=tools_desc)

        messages = [
            AIMessage(role="system", content=system_content),
            AIMessage(role="user", content=f"Task: {task}")
        ]

        try:
            response = await self.gateway.chat(
                messages=messages,
                config=GenerationConfig(max_tokens=2048, temperature=0.2)
            )

            # Parse response
            text = response.content.strip()

            # Clean potential markdown wrapping
            if text.startswith("```"):
                lines = text.split("\n")
                lines = [l for l in lines if not l.startswith("```")]
                text = "\n".join(lines)

            data = json.loads(text)

            # Build plan
            plan = AgentPlan(
                task=task,
                overview=data.get("overview", "Plan generated")
            )

            # Convert step indices to UUIDs for dependencies
            raw_steps = data.get("steps", [])
            step_ids = []

            for i, step_data in enumerate(raw_steps):
                step = PlanStep(
                    description=step_data.get("description", f"Step {i+1}"),
                    tool_name=step_data.get("tool_name"),
                    tool_params=step_data.get("tool_params", {}),
                )
                step_ids.append(step.id)
                plan.steps.append(step)

            # Resolve dependencies (indices to IDs)
            for i, step_data in enumerate(raw_steps):
                dep_indices = step_data.get("dependencies", [])
                for idx in dep_indices:
                    if 0 <= idx < len(step_ids) and idx != i:
                        plan.steps[i].dependencies.append(step_ids[idx])

            logger.info(f"Created plan with {len(plan.steps)} steps for task: {task[:50]}...")
            return plan

        except Exception as e:
            logger.error(f"Plan generation failed: {e}")
            # Fallback: single-step plan
            return AgentPlan(
                task=task,
                overview=f"Fallback plan (planning failed: {e})",
                steps=[
                    PlanStep(
                        description=f"Execute task directly: {task}",
                        tool_name=None,
                        tool_params={}
                    )
                ]
            )
```

Create `src/agent/loop/__init__.py` exporting AgentPlanner.
  </action>
  <verify>
Run: `python -c "
import asyncio
from src.agent.loop.planner import AgentPlanner

async def test():
    planner = AgentPlanner()
    # This will use the AI gateway - may fail without provider
    # But we can test the structure
    print(f'Planner created, tools desc length: {len(planner._get_tools_description())}')

asyncio.run(test())
"`
Expected: Prints planner info without error
  </verify>
  <done>AgentPlanner generates AgentPlan from task using AI Gateway with tool context</done>
</task>

<task type="auto">
  <name>Task 3: Create AgentExecutor with retry logic</name>
  <files>
    src/agent/loop/executor.py
  </files>
  <action>
**Create `src/agent/loop/executor.py`:**

```python
import asyncio
import logging
import time
from typing import AsyncIterator, Optional
from tenacity import (
    retry,
    stop_after_attempt,
    wait_exponential_jitter,
    retry_if_exception_type,
    before_sleep_log,
)

from src.agent.models.state import AgentState, AgentSession
from src.agent.models.plan import AgentPlan, PlanStep, StepStatus
from src.agent.models.event import AgentEvent
from src.agent.models.tool import ToolCall, ToolResult
from src.agent.budget import TokenBudget
from src.agent.events import AgentEventEmitter
from src.agent.registry import get_tool_registry, AgentContext
from src.agent.loop.planner import AgentPlanner

logger = logging.getLogger(__name__)


class ToolExecutionError(Exception):
    """Raised when tool execution fails."""
    pass


class AgentExecutor:
    """
    Execute agent plans with tool invocation, retry logic, and budget enforcement.
    """

    MAX_ITERATIONS = 20
    TIMEOUT_SECONDS = 300  # 5 minutes

    def __init__(self, session: AgentSession):
        self.session = session
        self.planner = AgentPlanner()
        self.registry = get_tool_registry()
        self.emitter = AgentEventEmitter()
        self.budget = TokenBudget(max_tokens=session.token_budget)
        self._cancelled = False

    def cancel(self):
        """Request cancellation of execution."""
        self._cancelled = True

    async def run(self, task: str) -> AsyncIterator[AgentEvent]:
        """
        Execute a task, yielding events as execution progresses.

        Args:
            task: The user's task

        Yields:
            AgentEvent objects for each state change, step, etc.
        """
        self.session.task = task
        self.session.state = AgentState.PLANNING
        yield AgentEvent.state_change("planning", self.session.id)

        # Phase 1: Generate plan
        try:
            plan = await self.planner.create_plan(task)
            yield AgentEvent.plan_created(plan.model_dump(), self.session.id)
        except Exception as e:
            self.session.state = AgentState.FAILED
            yield AgentEvent.error(f"Planning failed: {e}", self.session.id)
            return

        # Phase 2: Execute steps
        self.session.state = AgentState.EXECUTING
        yield AgentEvent.state_change("executing", self.session.id)

        iteration = 0
        start_time = time.time()

        while not plan.is_complete() and not plan.has_failed():
            # Check cancellation
            if self._cancelled:
                self.session.state = AgentState.CANCELLED
                yield AgentEvent(type="cancelled", data={}, session_id=self.session.id)
                return

            # Check iteration limit
            iteration += 1
            if iteration > self.MAX_ITERATIONS:
                yield AgentEvent(type="iteration_limit", data={"max": self.MAX_ITERATIONS}, session_id=self.session.id)
                break

            # Check timeout
            if time.time() - start_time > self.TIMEOUT_SECONDS:
                yield AgentEvent(type="error", data={"message": "Execution timeout"}, session_id=self.session.id)
                break

            # Check budget
            if not self.budget.can_proceed():
                yield AgentEvent(type="budget_exceeded", data=self.budget.to_dict(), session_id=self.session.id)
                break

            if self.budget.is_warning():
                yield AgentEvent(type="budget_warning", data=self.budget.to_dict(), session_id=self.session.id)

            # Get next step
            step = plan.get_next_step()
            if step is None:
                # No step ready (dependencies not met or all done)
                await asyncio.sleep(0.1)
                continue

            # Execute step
            yield AgentEvent(type="step_started", data={"step_id": step.id, "description": step.description}, session_id=self.session.id)

            step.status = StepStatus.RUNNING
            async for event in self._execute_step(step):
                yield event

            self.session.steps_completed += 1

        # Determine final state
        if plan.has_failed():
            self.session.state = AgentState.FAILED
            yield AgentEvent.error("Plan execution failed", self.session.id)
        elif plan.is_complete():
            self.session.state = AgentState.COMPLETED
            yield AgentEvent(type="completed", data=self._get_summary(plan), session_id=self.session.id)
        else:
            self.session.state = AgentState.FAILED
            yield AgentEvent.error("Plan did not complete", self.session.id)

    async def _execute_step(self, step: PlanStep) -> AsyncIterator[AgentEvent]:
        """Execute a single plan step."""
        try:
            if step.tool_name:
                # Tool invocation
                result = await self._execute_tool_with_retry(step.tool_name, step.tool_params)

                if result.success:
                    step.status = StepStatus.COMPLETED
                    step.result = result.data
                    yield AgentEvent(
                        type="step_completed",
                        data={"step_id": step.id, "result": result.data},
                        session_id=self.session.id
                    )
                else:
                    step.status = StepStatus.FAILED
                    step.error = result.error
                    yield AgentEvent(
                        type="error",
                        data={"step_id": step.id, "error": result.error},
                        session_id=self.session.id
                    )
            else:
                # No tool - step is informational/reasoning
                step.status = StepStatus.COMPLETED
                step.result = {"note": "Reasoning step completed"}
                yield AgentEvent(
                    type="step_completed",
                    data={"step_id": step.id, "result": step.result},
                    session_id=self.session.id
                )

        except Exception as e:
            step.status = StepStatus.FAILED
            step.error = str(e)
            yield AgentEvent(
                type="error",
                data={"step_id": step.id, "error": str(e)},
                session_id=self.session.id
            )

    @retry(
        stop=stop_after_attempt(3),
        wait=wait_exponential_jitter(initial=1, max=30, exp_base=2),
        retry=retry_if_exception_type(ToolExecutionError),
        before_sleep=before_sleep_log(logger, logging.WARNING),
        reraise=True,
    )
    async def _execute_tool_with_retry(self, tool_name: str, params: dict) -> ToolResult:
        """
        Execute a tool with automatic retry on transient failures.
        Retries up to 3 times with exponential backoff.
        """
        tool = self.registry.get_tool(tool_name)
        if tool is None:
            return ToolResult.failure_result(
                tool_call_id="unknown",
                error=f"Tool not found: {tool_name}"
            )

        # Validate parameters
        valid, error = tool.validate_params(params)
        if not valid:
            return ToolResult.failure_result(
                tool_call_id="validation",
                error=f"Parameter validation failed: {error}"
            )

        # Create context
        context = AgentContext(
            session_id=self.session.id,
            variables=self.session.variables
        )

        # Execute
        start = time.time()
        try:
            result = await tool.execute(params, context)
            result.duration_ms = (time.time() - start) * 1000
            return result
        except Exception as e:
            # Wrap in ToolExecutionError for retry
            raise ToolExecutionError(f"Tool {tool_name} failed: {e}") from e

    def _get_summary(self, plan: AgentPlan) -> dict:
        """Get execution summary."""
        completed = sum(1 for s in plan.steps if s.status == StepStatus.COMPLETED)
        failed = sum(1 for s in plan.steps if s.status == StepStatus.FAILED)
        return {
            "task": self.session.task,
            "overview": plan.overview,
            "steps_total": len(plan.steps),
            "steps_completed": completed,
            "steps_failed": failed,
            "tokens_used": self.budget.used_total,
        }
```

Update `src/agent/loop/__init__.py` to export AgentExecutor.
Update `src/agent/__init__.py` to export all loop, budget, and events components.
  </action>
  <verify>
Run: `python -c "
import asyncio
from src.agent.models.state import AgentSession
from src.agent.loop.executor import AgentExecutor

async def test():
    session = AgentSession(task='test', token_budget=10000)
    executor = AgentExecutor(session)
    print(f'Executor created for session {session.id[:8]}...')
    print(f'Budget: {executor.budget.max_tokens} tokens')
    print(f'Registry tools: {executor.registry.tool_names}')

asyncio.run(test())
"`
Expected: Prints executor info with budget and tool names
  </verify>
  <done>AgentExecutor runs plan steps with retry (3 attempts, exponential backoff), budget enforcement, and event streaming</done>
</task>

</tasks>

<verification>
Full integration test:
```bash
python -c "
import asyncio
from src.agent.models.state import AgentSession
from src.agent.loop.executor import AgentExecutor

async def test_executor():
    # Create session
    session = AgentSession(task='Echo hello world using the mock tool', token_budget=10000)
    executor = AgentExecutor(session)

    # Subscribe to events
    sub = executor.emitter.subscribe()

    # Run in background
    events = []
    async for event in executor.run('Echo hello world using the mock tool'):
        events.append(event)
        print(f'Event: {event.type}')
        if event.type in ('completed', 'error', 'cancelled'):
            break

    print(f'Total events: {len(events)}')
    print(f'Final state: {session.state}')

asyncio.run(test_executor())
"
```

Note: Full integration requires AI provider configured. The test above will show planning failure if no provider, but executor structure is verified.

Retry logic test:
```bash
python -c "
from tenacity import retry, stop_after_attempt, wait_exponential_jitter
print('Tenacity imported successfully')
"
```
</verification>

<success_criteria>
- TokenBudget tracks input/output tokens with can_proceed() and is_warning()
- AgentEventEmitter broadcasts to async subscribers with bounded queues
- AgentPlanner generates AgentPlan from task using AI Gateway
- AgentExecutor:
  - Runs plan steps sequentially respecting dependencies
  - Invokes tools through ToolRegistry
  - Retries failed tool calls up to 3 times with exponential backoff (tenacity)
  - Enforces MAX_ITERATIONS (20) and TIMEOUT_SECONDS (300)
  - Emits events for each state change and step completion
  - Respects token budget limits
- All components importable from src.agent
</success_criteria>

<output>
After completion, create `.planning/phases/07-agent-core-infrastructure/07-03-SUMMARY.md`
</output>
