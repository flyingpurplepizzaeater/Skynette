---
phase: 07-agent-core-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/agent/__init__.py
  - src/agent/models/__init__.py
  - src/agent/models/state.py
  - src/agent/models/plan.py
  - src/agent/models/event.py
autonomous: true

must_haves:
  truths:
    - "AgentSession tracks task, state, messages, token budget"
    - "AgentPlan contains ordered steps with dependencies"
    - "AgentEvent types cover all execution lifecycle events"
    - "All models are Pydantic BaseModels with proper validation"
  artifacts:
    - path: "src/agent/models/state.py"
      provides: "AgentState enum, AgentSession model"
      exports: ["AgentState", "AgentSession"]
    - path: "src/agent/models/plan.py"
      provides: "PlanStep, StepStatus, AgentPlan models"
      exports: ["StepStatus", "PlanStep", "AgentPlan"]
    - path: "src/agent/models/event.py"
      provides: "AgentEvent model with typed event types"
      exports: ["AgentEvent", "AgentEventType"]
  key_links:
    - from: "src/agent/models/state.py"
      to: "AgentState enum"
      via: "AgentSession.state uses AgentState"
      pattern: "state:\\s*AgentState"
    - from: "src/agent/models/plan.py"
      to: "StepStatus enum"
      via: "PlanStep.status uses StepStatus"
      pattern: "status:\\s*StepStatus"
---

<objective>
Create the foundational Pydantic data models for the agent system: state management, plan representation, and event types.

Purpose: These models define the data contracts that all agent components use. Type-safe models catch errors at development time and provide clear structure for the agent loop.

Output: `src/agent/models/` with state.py, plan.py, and event.py
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-agent-core-infrastructure/07-RESEARCH.md

# Existing patterns to follow
@src/core/nodes/base.py
@src/ai/gateway.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create agent module structure and state models</name>
  <files>
    src/agent/__init__.py
    src/agent/models/__init__.py
    src/agent/models/state.py
  </files>
  <action>
Create the `src/agent/` directory structure:
```
src/agent/
  __init__.py           # Expose key classes
  models/
    __init__.py         # Expose all models
    state.py            # AgentState, AgentSession
```

In `src/agent/models/state.py`:
1. Create `AgentState` enum (str, Enum) with values:
   - IDLE, PLANNING, EXECUTING, AWAITING_TOOL, AWAITING_APPROVAL, COMPLETED, FAILED, CANCELLED
2. Create `AgentSession` Pydantic BaseModel with fields:
   - id: str (default uuid4)
   - task: str (the user's original task)
   - state: AgentState (default IDLE)
   - messages: list[dict] (conversation history)
   - variables: dict[str, Any] (session variables)
   - token_budget: int (default 50000)
   - tokens_used: int (default 0)
   - created_at: datetime (default now UTC)
   - updated_at: datetime (default now UTC)
   - steps_completed: int (default 0)
3. Add methods to AgentSession:
   - `can_continue() -> bool`: True if state allows execution and tokens_used < token_budget
   - `remaining_tokens() -> int`: token_budget - tokens_used
   - `usage_percentage() -> float`: tokens_used / token_budget
   - `is_budget_warning() -> bool`: True if usage_percentage >= 0.8

Use Field(default_factory=...) for mutable defaults. Import datetime from datetime, use UTC timezone.

In `__init__.py` files, export all public classes.
  </action>
  <verify>
Run: `python -c "from src.agent.models.state import AgentState, AgentSession; s = AgentSession(task='test'); print(s.state, s.can_continue())"`
Expected: Prints "idle True" (or AgentState.IDLE True)
  </verify>
  <done>AgentState enum and AgentSession model exist with all specified fields and methods</done>
</task>

<task type="auto">
  <name>Task 2: Create plan and step models</name>
  <files>
    src/agent/models/plan.py
  </files>
  <action>
In `src/agent/models/plan.py`:

1. Create `StepStatus` enum (str, Enum) with values:
   - PENDING, RUNNING, COMPLETED, FAILED, SKIPPED

2. Create `PlanStep` Pydantic BaseModel with fields:
   - id: str (default uuid4)
   - description: str (what this step does)
   - tool_name: Optional[str] = None (tool to invoke, if any)
   - tool_params: dict = Field(default_factory=dict)
   - dependencies: list[str] = Field(default_factory=list) (step IDs that must complete first)
   - status: StepStatus = StepStatus.PENDING
   - result: Optional[Any] = None
   - error: Optional[str] = None

3. Create `AgentPlan` Pydantic BaseModel with fields:
   - id: str (default uuid4)
   - task: str (original user task)
   - overview: str (one-sentence summary of approach)
   - steps: list[PlanStep] = Field(default_factory=list)
   - created_at: datetime (default now UTC)

4. Add methods to AgentPlan:
   - `get_next_step() -> Optional[PlanStep]`: Return first PENDING step whose dependencies are all COMPLETED. Return None if no such step exists.
   - `is_complete() -> bool`: True if all steps are COMPLETED or SKIPPED
   - `has_failed() -> bool`: True if any step is FAILED

Update `src/agent/models/__init__.py` to export StepStatus, PlanStep, AgentPlan.
  </action>
  <verify>
Run: `python -c "from src.agent.models.plan import AgentPlan, PlanStep, StepStatus; p = AgentPlan(task='test', overview='test plan'); p.steps.append(PlanStep(description='step 1')); print(p.get_next_step().description, p.is_complete())"`
Expected: Prints "step 1 False"
  </verify>
  <done>StepStatus enum, PlanStep model, and AgentPlan model exist with dependency-aware step retrieval</done>
</task>

<task type="auto">
  <name>Task 3: Create event types</name>
  <files>
    src/agent/models/event.py
  </files>
  <action>
In `src/agent/models/event.py`:

1. Create `AgentEventType` as a Literal type (not enum, for JSON serialization):
```python
from typing import Literal

AgentEventType = Literal[
    "state_change",
    "plan_created",
    "step_started",
    "step_completed",
    "tool_called",
    "tool_result",
    "message",
    "error",
    "budget_warning",
    "budget_exceeded",
    "iteration_limit",
    "completed",
    "cancelled",
]
```

2. Create `AgentEvent` Pydantic BaseModel with fields:
   - type: AgentEventType
   - data: dict = Field(default_factory=dict)
   - timestamp: datetime = Field(default_factory=lambda: datetime.now(UTC))
   - session_id: Optional[str] = None (for event routing)

3. Add Config class to AgentEvent with `use_enum_values = True` for clean JSON serialization.

4. Add convenience class methods to AgentEvent for common events:
   - `@classmethod state_change(cls, state: str, session_id: str) -> "AgentEvent"`
   - `@classmethod plan_created(cls, plan_dict: dict, session_id: str) -> "AgentEvent"`
   - `@classmethod step_completed(cls, step_id: str, result: Any, session_id: str) -> "AgentEvent"`
   - `@classmethod error(cls, message: str, session_id: str) -> "AgentEvent"`

Update `src/agent/models/__init__.py` to export AgentEvent, AgentEventType.
Update `src/agent/__init__.py` to export all models from models subpackage.
  </action>
  <verify>
Run: `python -c "from src.agent.models.event import AgentEvent; e = AgentEvent.state_change('planning', 'sess-1'); print(e.type, e.data)"`
Expected: Prints "state_change {'state': 'planning'}"
  </verify>
  <done>AgentEvent model exists with typed event types and convenience constructors</done>
</task>

</tasks>

<verification>
All models importable from src.agent:
```bash
python -c "from src.agent import AgentState, AgentSession, AgentPlan, PlanStep, StepStatus, AgentEvent, AgentEventType; print('All imports successful')"
```

Models are type-safe and validate:
```bash
python -c "
from src.agent.models.state import AgentSession
from src.agent.models.plan import AgentPlan, PlanStep
# Valid
s = AgentSession(task='test')
p = AgentPlan(task='test', overview='plan')
print('Validation passed')
"
```
</verification>

<success_criteria>
- AgentState enum has all 8 states
- AgentSession tracks task, state, messages, tokens with utility methods
- AgentPlan contains steps with dependency resolution via get_next_step()
- AgentEvent supports all lifecycle event types
- All models use Pydantic BaseModel with proper Field defaults
- Clean imports from src.agent package
</success_criteria>

<output>
After completion, create `.planning/phases/07-agent-core-infrastructure/07-01-SUMMARY.md`
</output>
