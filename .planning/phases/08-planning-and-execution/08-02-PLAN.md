---
phase: 08-planning-and-execution
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - src/agent/models/cancel.py
  - src/agent/loop/executor.py
  - src/agent/ui/__init__.py
  - src/agent/ui/status_indicator.py
  - src/agent/ui/cancel_dialog.py
  - src/agent/__init__.py
  - src/agent/models/__init__.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can cancel agent execution and choose cancel mode (immediate vs after current step)"
    - "User can choose what to do with partial results (keep vs rollback)"
    - "User can distinguish active vs idle agent states visually"
    - "User sees step progress during execution (e.g., 'Step 2 of 5')"
    - "Status updates automatically as agent emits events"
    - "Cancel produces summary of what completed before cancellation"
  artifacts:
    - path: "src/agent/models/cancel.py"
      provides: "CancelMode, ResultMode, CancellationRequest models"
      exports: ["CancelMode", "ResultMode", "CancellationRequest", "CancellationResult"]
    - path: "src/agent/loop/executor.py"
      provides: "Enhanced executor with cooperative cancellation"
      contains: "CancellationRequest"
    - path: "src/agent/ui/status_indicator.py"
      provides: "Flet status indicator component with step progress"
      exports: ["AgentStatusIndicator"]
    - path: "src/agent/ui/cancel_dialog.py"
      provides: "Flet cancel dialog with options"
      exports: ["CancelDialog"]
  key_links:
    - from: "src/agent/loop/executor.py"
      to: "src/agent/models/cancel.py"
      via: "import"
      pattern: "from.*cancel import"
    - from: "src/agent/ui/status_indicator.py"
      to: "src/agent/models/state.py"
      via: "state mapping"
      pattern: "AgentState|status.*idle|planning|executing"
    - from: "src/agent/ui/status_indicator.py"
      to: "src/agent/events/emitter.py"
      via: "event subscription"
      pattern: "subscribe|EventSubscription|emitter"
---

<objective>
Implement cancellation controls and status display for agent execution.

Purpose: Give users visibility into what the agent is doing (AGNT-06) and control to stop execution cleanly (AGNT-07). The user chose to have options on cancel behavior per the CONTEXT.md discussion. Addresses Success Criteria #1 (step N of M progress) and #2 (cancel running task).

Output: Cancellation request model with mode options, enhanced executor with cooperative cancellation, and Flet UI components for status display (with step progress) and cancel dialog.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-planning-and-execution/08-RESEARCH.md
@.planning/phases/08-planning-and-execution/08-CONTEXT.md

# Dependencies from Phase 7 and 08-01
@src/agent/loop/executor.py
@src/agent/models/state.py
@src/agent/models/event.py
@src/agent/events/emitter.py
@src/ui/views/agents.py
@src/ui/theme.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Cancellation Models</name>
  <files>
    src/agent/models/cancel.py
    src/agent/models/__init__.py
  </files>
  <action>
Create cancellation data models for user-controlled cancel behavior.

1. Create `src/agent/models/cancel.py`:
   - CancelMode (str, Enum):
     - IMMEDIATE = "immediate" (stop now, mid-step)
     - AFTER_CURRENT = "after_current" (finish current step, then stop)

   - ResultMode (str, Enum):
     - KEEP = "keep" (keep all completed work)
     - ROLLBACK = "rollback" (attempt to undo - note: we track intent, actual rollback is future work)

   - CancellationRequest (pydantic BaseModel):
     - cancel_mode: CancelMode
     - result_mode: ResultMode
     - reason: Optional[str] = None
     - requested_at: datetime (auto UTC)

   - CancellationResult (pydantic BaseModel):
     - completed_steps: list[str] (step descriptions)
     - cancelled_step: Optional[str] (if cancelled mid-step)
     - cancel_mode: CancelMode
     - result_mode: ResultMode
     - options: list[str] = ["resume", "restart", "abandon"]

2. Update `src/agent/models/__init__.py`:
   - Export CancelMode, ResultMode, CancellationRequest, CancellationResult
  </action>
  <verify>
```bash
cd "C:\Users\karlt\OneDrive\Desktop\Claude\skynette-repo"

# Test models
python -c "
from src.agent.models.cancel import CancelMode, ResultMode, CancellationRequest, CancellationResult

req = CancellationRequest(
    cancel_mode=CancelMode.AFTER_CURRENT,
    result_mode=ResultMode.KEEP,
    reason='User requested'
)
print(f'Request: {req.cancel_mode.value}, {req.result_mode.value}')

result = CancellationResult(
    completed_steps=['Step 1', 'Step 2'],
    cancelled_step='Step 3',
    cancel_mode=CancelMode.IMMEDIATE,
    result_mode=ResultMode.KEEP
)
print(f'Result options: {result.options}')
"

# Verify exports
python -c "from src.agent.models import CancelMode, ResultMode, CancellationRequest, CancellationResult; print('Exports working')"
```
  </verify>
  <done>Cancellation models defined with mode enums and result structure. Exported from models package.</done>
</task>

<task type="auto">
  <name>Task 2: Enhance Executor with Cooperative Cancellation</name>
  <files>
    src/agent/loop/executor.py
  </files>
  <action>
Enhance the executor with cooperative cancellation that respects user's mode choice.

1. Update `src/agent/loop/executor.py`:
   - Import CancellationRequest, CancellationResult from models.cancel
   - Replace `self._cancelled: bool` with `self._cancel_request: Optional[CancellationRequest] = None`

   - Add method `request_cancel(self, request: CancellationRequest)`:
     - Store the request
     - Emit "cancellation_requested" event immediately

   - Modify cancellation check in run() loop:
     - If _cancel_request is None: continue normally
     - If cancel_mode == IMMEDIATE: cancel immediately
     - If cancel_mode == AFTER_CURRENT and _current_step is None: cancel
     - If cancel_mode == AFTER_CURRENT and _current_step is running: continue (cancel after step)

   - Track `self._current_step: Optional[PlanStep]` during execution
   - Track `self._completed_steps: list[str]` for cancellation result

   - When cancelled, emit "cancelled" event with CancellationResult in data:
     - List completed step descriptions
     - Include cancel_mode and result_mode
     - Include post-cancel options

   - Keep existing cancel() method for backward compatibility (calls request_cancel with IMMEDIATE mode)
  </action>
  <verify>
```bash
cd "C:\Users\karlt\OneDrive\Desktop\Claude\skynette-repo"

# Test enhanced executor
python -c "
from src.agent.loop.executor import AgentExecutor
from src.agent.models.state import AgentSession
from src.agent.models.cancel import CancellationRequest, CancelMode, ResultMode

session = AgentSession(task='test')
executor = AgentExecutor(session)

# Test new cancel method
req = CancellationRequest(cancel_mode=CancelMode.AFTER_CURRENT, result_mode=ResultMode.KEEP)
executor.request_cancel(req)
print(f'Cancel request stored: {executor._cancel_request is not None}')

# Test backward compatibility
executor2 = AgentExecutor(AgentSession(task='test2'))
executor2.cancel()  # Old method should still work
print(f'Old cancel() still works: {executor2._cancel_request is not None}')
"
```
  </verify>
  <done>Executor supports cooperative cancellation with IMMEDIATE and AFTER_CURRENT modes, emits cancellation events with result summary.</done>
</task>

<task type="auto">
  <name>Task 3: Create Status Indicator UI Component with Step Progress</name>
  <files>
    src/agent/ui/__init__.py
    src/agent/ui/status_indicator.py
  </files>
  <action>
Create Flet UI component for displaying agent execution status with animation and step progress.

1. Create `src/agent/ui/__init__.py`:
   - Export AgentStatusIndicator from status_indicator
   - Export CancelDialog from cancel_dialog (anticipating Task 4)

2. Create `src/agent/ui/status_indicator.py`:
   - Import flet as ft
   - Import Theme from src.ui.theme
   - Import AgentEventEmitter, EventSubscription from src.agent.events.emitter
   - Import AgentEvent from src.agent.models.event

   - AgentStatusIndicator(ft.UserControl):
     - STATUS_CONFIG dict mapping status -> {icon, color, animate, text}:
       - "idle": PENDING icon, TEXT_MUTED, no animate, "Ready"
       - "planning": AUTO_AWESOME icon, PRIMARY, animate, "Planning..."
       - "executing": PLAY_ARROW icon, SECONDARY, animate, "Executing..."
       - "awaiting_tool": BUILD icon, INFO, animate, "Running tool..."
       - "awaiting_approval": PAUSE icon, WARNING, no animate, "Waiting for approval"
       - "completed": CHECK_CIRCLE icon, SUCCESS, no animate, "Completed"
       - "failed": ERROR icon, ERROR, no animate, "Failed"
       - "cancelled": CANCEL icon, WARNING, no animate, "Cancelled"

     - __init__(self, initial_status: str = "idle"):
       - self.current_status = initial_status
       - self.current_step: int = 0
       - self.total_steps: int = 0
       - self._subscription: Optional[EventSubscription] = None

     - build(self) -> ft.Row:
       - ProgressRing (visible when animate=True)
       - Icon (visible when animate=False)
       - Text showing status and step progress

     - update_status(self, status: str, detail: str = None):
       - Update all components based on STATUS_CONFIG
       - If detail provided, use it instead of default text
       - Call self.update()

     - set_step_progress(self, current: int, total: int):
       - self.current_step = current
       - self.total_steps = total
       - Update display to show "Executing (Step 2 of 5)" format
       - Call self.update()

     - update_from_event(self, event: AgentEvent):
       - Map event.type to status:
         - state_change -> use event.data["state"]
         - plan_created -> extract total_steps from event.data["plan"]["steps"] length
         - step_started -> "executing" with step description, increment current_step
         - tool_called -> "awaiting_tool" with tool name
         - completed -> "completed"
         - error -> "failed"
         - cancelled -> "cancelled"
       - Extract detail from event.data where appropriate
       - Handle step progress: on plan_created set total_steps, on step_started increment current_step

     - subscribe_to_emitter(self, emitter: AgentEventEmitter):
       - Subscribe to emitter with callback that calls update_from_event
       - Store subscription in self._subscription
       - Return the subscription for caller to manage lifecycle

     - unsubscribe(self):
       - If self._subscription exists, call close() on it
       - Set self._subscription to None

     - _format_status_text(self) -> str:
       - If executing and total_steps > 0: return "Executing (Step {current} of {total})"
       - Otherwise return default text from STATUS_CONFIG
  </action>
  <verify>
```bash
cd "C:\Users\karlt\OneDrive\Desktop\Claude\skynette-repo"
python -c "
from src.agent.ui.status_indicator import AgentStatusIndicator

# Test instantiation
indicator = AgentStatusIndicator()
print(f'Initial status: {indicator.current_status}')

# Test status config
assert 'idle' in indicator.STATUS_CONFIG
assert 'planning' in indicator.STATUS_CONFIG
assert indicator.STATUS_CONFIG['planning']['animate'] == True
assert indicator.STATUS_CONFIG['idle']['animate'] == False
print('Status configs correct')

# Test step progress
indicator.set_step_progress(2, 5)
assert indicator.current_step == 2
assert indicator.total_steps == 5
text = indicator._format_status_text()
assert 'Step 2 of 5' in text or '2' in text
print(f'Step progress: {text}')

# Test update methods exist
assert hasattr(indicator, 'update_status')
assert hasattr(indicator, 'update_from_event')
assert hasattr(indicator, 'subscribe_to_emitter')
assert hasattr(indicator, 'unsubscribe')
print('All methods exist')
"
```
  </verify>
  <done>AgentStatusIndicator component created with animated/static states, step N of M progress display, and event subscription support.</done>
</task>

<task type="auto">
  <name>Task 4: Create Cancel Dialog UI Component</name>
  <files>
    src/agent/ui/cancel_dialog.py
    src/agent/__init__.py
  </files>
  <action>
Create Flet dialog for cancellation with mode selection per CONTEXT.md requirements.

1. Create `src/agent/ui/cancel_dialog.py`:
   - Import flet as ft
   - Import Theme from src.ui.theme
   - Import CancelMode, ResultMode, CancellationRequest from src.agent.models.cancel

   - CancelDialog(ft.AlertDialog):
     - __init__(self, on_cancel: Callable[[CancellationRequest], None], elapsed_seconds: float = 0):
       - on_cancel callback receives the CancellationRequest
       - elapsed_seconds for confirmation on long-running tasks (>30s shows warning)

     - Internal state:
       - cancel_mode: CancelMode = CancelMode.AFTER_CURRENT (default safer option)
       - result_mode: ResultMode = ResultMode.KEEP (default safer option)

     - Dialog content (ft.Column):
       - Title: "Cancel Task?"
       - Text: "How would you like to stop?"
       - RadioGroup for cancel mode:
         - "Stop immediately" (IMMEDIATE)
         - "Finish current step, then stop" (AFTER_CURRENT) - default selected
       - Divider
       - Text: "What about completed work?"
       - RadioGroup for result mode:
         - "Keep changes" (KEEP) - default selected
         - "Rollback changes" (ROLLBACK)
       - If elapsed_seconds > 30: show warning text with elapsed time

     - Actions:
       - "Continue Task" TextButton -> close dialog
       - "Cancel Task" ElevatedButton -> call on_cancel with request, close dialog

     - Event handlers:
       - _on_mode_change(e): update cancel_mode
       - _on_result_change(e): update result_mode
       - _confirm_cancel(e): create CancellationRequest, call on_cancel, close
       - _close(e): set open=False, update

2. Update `src/agent/__init__.py`:
   - Add exports: from src.agent.ui import AgentStatusIndicator, CancelDialog
  </action>
  <verify>
```bash
cd "C:\Users\karlt\OneDrive\Desktop\Claude\skynette-repo"
python -c "
from src.agent.ui.cancel_dialog import CancelDialog
from src.agent.models.cancel import CancellationRequest, CancelMode

# Test instantiation with callback
received_request = None
def on_cancel(req):
    global received_request
    received_request = req

dialog = CancelDialog(on_cancel=on_cancel, elapsed_seconds=45)
print(f'Dialog created with elapsed time: 45s')

# Verify default modes are safer options
assert dialog.cancel_mode == CancelMode.AFTER_CURRENT, 'Default should be AFTER_CURRENT'
print('Default cancel mode correct')

# Test that it has required structure
assert hasattr(dialog, '_confirm_cancel')
assert hasattr(dialog, '_close')
print('Methods exist')
"

# Verify package exports
python -c "
from src.agent import AgentStatusIndicator, CancelDialog
print('UI components exported from src.agent')
"
```
  </verify>
  <done>CancelDialog component created with mode selection, result mode options, long-task warning, and proper exports from src.agent package.</done>
</task>

</tasks>

<verification>
After all tasks complete:

```bash
cd "C:\Users\karlt\OneDrive\Desktop\Claude\skynette-repo"

# Full integration test
python -c "
from src.agent.loop.executor import AgentExecutor
from src.agent.models.state import AgentSession
from src.agent.models.cancel import CancellationRequest, CancelMode, ResultMode
from src.agent.ui.status_indicator import AgentStatusIndicator
from src.agent.ui.cancel_dialog import CancelDialog
from src.agent.models.event import AgentEvent

# Test 1: Create executor and simulate cancellation
session = AgentSession(task='Test cancellation')
executor = AgentExecutor(session)

# Request cancellation with options
req = CancellationRequest(
    cancel_mode=CancelMode.AFTER_CURRENT,
    result_mode=ResultMode.KEEP,
    reason='User clicked cancel'
)
executor.request_cancel(req)
assert executor._cancel_request is not None
print('Executor accepts cancellation request')

# Test 2: Status indicator responds to events with step progress
indicator = AgentStatusIndicator()

# Simulate plan created event (sets total steps)
plan_event = AgentEvent(type='plan_created', data={'plan': {'steps': [{}, {}, {}, {}, {}]}}, session_id='test')
indicator.update_from_event(plan_event)
assert indicator.total_steps == 5, 'Total steps set from plan'

# Simulate step started
step_event = AgentEvent(type='step_started', data={'step_id': '1', 'description': 'Fetching data'}, session_id='test')
indicator.update_from_event(step_event)
assert indicator.current_status == 'executing'
assert indicator.current_step >= 1, 'Current step incremented'
status_text = indicator._format_status_text()
assert 'Step' in status_text, f'Step progress in text: {status_text}'
print(f'Status indicator updates: {status_text}')

# Test 3: Dialog creates proper request
captured_req = None
def capture(r):
    global captured_req
    captured_req = r

dialog = CancelDialog(on_cancel=capture, elapsed_seconds=10)
# Simulate mode changes
dialog.cancel_mode = CancelMode.IMMEDIATE
dialog.result_mode = ResultMode.ROLLBACK
# Dialog would call _confirm_cancel which creates request

print('All integration tests passed')
"
```
</verification>

<success_criteria>
- [ ] CancelMode and ResultMode enums define cancellation options
- [ ] CancellationRequest holds user's cancellation preferences
- [ ] CancellationResult includes completed steps and post-cancel options
- [ ] AgentExecutor.request_cancel() stores request and emits event
- [ ] Executor respects IMMEDIATE vs AFTER_CURRENT cancel modes
- [ ] Cancelled event includes summary of what completed
- [ ] User can distinguish active vs idle states (animated spinner vs static icon)
- [ ] User sees step progress (Step N of M) during execution
- [ ] Status indicator can subscribe to event emitter for automatic updates
- [ ] CancelDialog presents mode options with safer defaults
- [ ] Long-running tasks (>30s) show warning in cancel dialog
- [ ] All components exportable from src.agent
</success_criteria>

<output>
After completion, create `.planning/phases/08-planning-and-execution/08-02-SUMMARY.md`
</output>
