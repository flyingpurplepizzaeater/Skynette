---
phase: 08-planning-and-execution
plan: 03
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - src/agent/routing/__init__.py
  - src/agent/routing/model_router.py
  - src/agent/routing/routing_rules.py
  - src/agent/__init__.py
  - tests/unit/test_agent_core.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Agent can classify tasks into categories (simple, code, research, etc.)"
    - "Agent recommends model based on task category with cost estimate"
    - "User can configure custom routing rules per task type"
    - "Routing provides alternatives with tradeoff explanations"
    - "Unit tests verify agent core components (executor, planner, budget, events)"
  artifacts:
    - path: "src/agent/routing/model_router.py"
      provides: "ModelRouter with task classification and recommendations"
      exports: ["ModelRouter", "ModelRecommendation", "TaskCategory"]
    - path: "src/agent/routing/routing_rules.py"
      provides: "User-configurable routing rules"
      exports: ["RoutingRules", "RoutingRule"]
    - path: "tests/unit/test_agent_core.py"
      provides: "Unit tests for agent components"
      min_lines: 150
  key_links:
    - from: "src/agent/routing/model_router.py"
      to: "src/ai/cost.py"
      via: "cost calculation"
      pattern: "CostCalculator|estimate_cost"
    - from: "tests/unit/test_agent_core.py"
      to: "src/agent"
      via: "test imports"
      pattern: "from src\\.agent import"
---

<objective>
Implement model routing intelligence and comprehensive unit tests.

Purpose: Enable smart model selection that balances cost and capability (AI-01, AI-02), and establish test coverage for agent core components (QUAL-01). This completes Phase 8's goal of making the agent visible, controllable, and intelligent.

Output: ModelRouter with task classification and cost-aware recommendations, configurable routing rules, and unit tests for executor, planner, budget, and event components.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-planning-and-execution/08-RESEARCH.md

# Dependencies
@src/ai/cost.py
@src/agent/loop/executor.py
@src/agent/loop/planner.py
@src/agent/budget/token_budget.py
@src/agent/events/emitter.py
@tests/unit/test_cost_calculator.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Model Routing System</name>
  <files>
    src/agent/routing/__init__.py
    src/agent/routing/model_router.py
    src/agent/routing/routing_rules.py
  </files>
  <action>
Create intelligent model routing with task classification and cost awareness.

1. Create `src/agent/routing/__init__.py`:
   - Export ModelRouter, ModelRecommendation, TaskCategory from model_router
   - Export RoutingRules, RoutingRule from routing_rules

2. Create `src/agent/routing/routing_rules.py`:
   - RoutingRule (pydantic BaseModel):
     - provider: str
     - model: str
     - reason: str

   - RoutingRules (pydantic BaseModel):
     - rules: dict[str, RoutingRule] (category name -> rule)
     - Custom rules override defaults

   - DEFAULT_RULES constant dict:
     - "simple_query": {"provider": "anthropic", "model": "claude-3-haiku", "reason": "Fast and cost-effective for simple queries"}
     - "code_generation": {"provider": "anthropic", "model": "claude-3-sonnet", "reason": "Strong code generation with good cost balance"}
     - "code_review": {"provider": "anthropic", "model": "claude-3-sonnet", "reason": "Effective for code analysis"}
     - "research": {"provider": "anthropic", "model": "claude-3-opus", "reason": "Best reasoning for complex multi-step research"}
     - "creative": {"provider": "anthropic", "model": "claude-3-sonnet", "reason": "Good creative writing capabilities"}
     - "analysis": {"provider": "anthropic", "model": "claude-3-opus", "reason": "Deep analytical reasoning"}
     - "general": {"provider": "anthropic", "model": "claude-3-sonnet", "reason": "Good all-around performance"}

   - Methods on RoutingRules:
     - get_rule(category: str) -> RoutingRule: Return custom or default
     - set_rule(category: str, rule: RoutingRule): Set custom rule
     - reset_to_defaults(): Clear custom rules

3. Create `src/agent/routing/model_router.py`:
   - Import CostCalculator from src.ai.cost
   - Import RoutingRules, DEFAULT_RULES from routing_rules

   - TaskCategory (str, Enum):
     - SIMPLE_QUERY = "simple_query"
     - CODE_GENERATION = "code_generation"
     - CODE_REVIEW = "code_review"
     - RESEARCH = "research"
     - CREATIVE = "creative"
     - ANALYSIS = "analysis"
     - GENERAL = "general"

   - ModelRecommendation (pydantic BaseModel):
     - provider: str
     - model: str
     - reason: str
     - estimated_cost_usd: float
     - capabilities: list[str] = ["chat"]
     - alternatives: list["ModelRecommendation"] = []

   - ModelRouter class:
     - __init__(self, custom_rules: RoutingRules = None):
       - self.rules = custom_rules or RoutingRules()
       - self.cost_calc = CostCalculator()

     - classify_task(self, task: str) -> TaskCategory:
       - Use keyword matching (simple heuristics per RESEARCH.md)
       - Keywords for code_generation: "write code", "create function", "implement", "build"
       - Keywords for code_review: "review", "analyze code", "find bugs", "refactor"
       - Keywords for research: "research", "find out", "investigate", "explore"
       - Keywords for simple_query: "what is", "how do", "when", "where", "who"
       - Keywords for creative: "write", "story", "brainstorm", "design"
       - Keywords for analysis: "analyze", "compare", "evaluate", "assess"
       - Default to GENERAL

     - recommend(self, task: str, estimated_tokens: int = 4000) -> ModelRecommendation:
       - Classify task
       - Get rule for category
       - Calculate estimated cost
       - Get alternatives
       - Return ModelRecommendation

     - _get_alternatives(self, category: TaskCategory, tokens: int) -> list[ModelRecommendation]:
       - Always include cheaper option (haiku)
       - Include more capable option (opus) if not already recommended
       - Calculate costs for each
  </action>
  <verify>
```bash
cd "C:\Users\karlt\OneDrive\Desktop\Claude\skynette-repo"
python -c "
from src.agent.routing import ModelRouter, TaskCategory, ModelRecommendation
from src.agent.routing.routing_rules import RoutingRules, RoutingRule

# Test task classification
router = ModelRouter()
cat1 = router.classify_task('Write code to parse JSON')
print(f'Code task: {cat1} == {TaskCategory.CODE_GENERATION}')
assert cat1 == TaskCategory.CODE_GENERATION

cat2 = router.classify_task('What is the capital of France?')
print(f'Simple query: {cat2} == {TaskCategory.SIMPLE_QUERY}')
assert cat2 == TaskCategory.SIMPLE_QUERY

cat3 = router.classify_task('Research the history of AI')
print(f'Research task: {cat3} == {TaskCategory.RESEARCH}')
assert cat3 == TaskCategory.RESEARCH

# Test recommendation
rec = router.recommend('Help me write a Python script')
print(f'Recommendation: {rec.provider}/{rec.model}')
print(f'Cost estimate: \${rec.estimated_cost_usd:.4f}')
print(f'Alternatives: {len(rec.alternatives)}')
assert rec.estimated_cost_usd >= 0
assert len(rec.alternatives) > 0

# Test custom rules
custom_rules = RoutingRules()
custom_rules.set_rule('simple_query', RoutingRule(
    provider='local',
    model='mistral-7b',
    reason='Use local for simple queries'
))
router2 = ModelRouter(custom_rules=custom_rules)
rec2 = router2.recommend('What is 2+2?')
print(f'Custom rule applied: {rec2.provider} == local')
assert rec2.provider == 'local'
"
```
  </verify>
  <done>ModelRouter classifies tasks, provides cost-aware recommendations with alternatives, and supports user-configurable routing rules.</done>
</task>

<task type="auto">
  <name>Task 2: Create Agent Core Unit Tests</name>
  <files>
    tests/unit/test_agent_core.py
  </files>
  <action>
Create comprehensive unit tests for agent core components following existing test patterns.

1. Create `tests/unit/test_agent_core.py`:

Reference existing test patterns from tests/unit/test_cost_calculator.py.

Test classes to create:

```python
import pytest
from unittest.mock import AsyncMock, MagicMock, patch
from datetime import datetime, timezone

# Test TokenBudget
class TestTokenBudget:
    def test_initial_state(self):
        # Budget starts with 0 used, full remaining

    def test_consume_tokens(self):
        # consume() updates counts correctly

    def test_can_proceed_under_budget(self):
        # can_proceed() returns True when tokens available

    def test_can_proceed_over_budget(self):
        # can_proceed() returns False when budget exceeded

    def test_is_warning_at_threshold(self):
        # is_warning() returns True at 80%+

    def test_to_dict_serialization(self):
        # to_dict() returns correct structure

# Test AgentEventEmitter
class TestAgentEventEmitter:
    def test_subscribe_creates_subscription(self):
        # subscribe() returns EventSubscription

    @pytest.mark.asyncio
    async def test_emit_reaches_subscriber(self):
        # emitted event received by subscriber

    @pytest.mark.asyncio
    async def test_multiple_subscribers(self):
        # multiple subscribers each receive events

    @pytest.mark.asyncio
    async def test_bounded_queue_drops_events(self):
        # slow subscriber doesn't block, events dropped

    def test_unsubscribe_removes_subscriber(self):
        # close() removes subscriber from list

# Test AgentPlanner
class TestAgentPlanner:
    def test_planner_has_system_prompt(self):
        # System prompt includes tool descriptions

    @pytest.mark.asyncio
    async def test_fallback_plan_on_failure(self):
        # Returns single-step plan when AI fails

# Test AgentExecutor
class TestAgentExecutor:
    @pytest.fixture
    def mock_session(self):
        from src.agent.models.state import AgentSession
        return AgentSession(task='Test task', token_budget=10000)

    def test_executor_initial_state(self, mock_session):
        # Executor created with session

    def test_cancel_sets_flag(self, mock_session):
        # cancel() sets cancelled state

    def test_cancel_request_stores_request(self, mock_session):
        # request_cancel() stores CancellationRequest

    @pytest.mark.asyncio
    async def test_budget_exceeded_stops_execution(self, mock_session):
        # Emits budget_exceeded when over limit

# Test ModelRouter
class TestModelRouter:
    def test_classify_code_generation(self):
        # 'write code' -> CODE_GENERATION

    def test_classify_simple_query(self):
        # 'what is' -> SIMPLE_QUERY

    def test_classify_research(self):
        # 'research' -> RESEARCH

    def test_classify_defaults_to_general(self):
        # Unrecognized -> GENERAL

    def test_recommend_returns_valid_model(self):
        # Recommendation has provider, model, cost

    def test_recommend_includes_alternatives(self):
        # Alternatives list not empty

    def test_custom_rules_override_defaults(self):
        # Custom rules take precedence

# Test CancellationRequest
class TestCancellation:
    def test_cancellation_request_modes(self):
        # CancelMode and ResultMode enums work

    def test_cancellation_result_structure(self):
        # CancellationResult includes required fields
```

Use setup_method() or @pytest.fixture for shared setup.
Mock AI calls with AsyncMock to avoid actual API calls.
  </action>
  <verify>
```bash
cd "C:\Users\karlt\OneDrive\Desktop\Claude\skynette-repo"

# Run the new tests
python -m pytest tests/unit/test_agent_core.py -v --tb=short 2>&1 | head -50

# Verify test file structure
python -c "
import ast
with open('tests/unit/test_agent_core.py', 'r') as f:
    tree = ast.parse(f.read())

classes = [node.name for node in ast.walk(tree) if isinstance(node, ast.ClassDef)]
print(f'Test classes: {classes}')
assert 'TestTokenBudget' in classes, 'Missing TestTokenBudget'
assert 'TestAgentEventEmitter' in classes, 'Missing TestAgentEventEmitter'
assert 'TestModelRouter' in classes, 'Missing TestModelRouter'
print('Test structure verified')
"
```
  </verify>
  <done>Unit tests created for TokenBudget, AgentEventEmitter, AgentPlanner, AgentExecutor, ModelRouter, and Cancellation components. Tests pass.</done>
</task>

<task type="auto">
  <name>Task 3: Export Routing Components and Final Verification</name>
  <files>
    src/agent/__init__.py
  </files>
  <action>
Export routing components from src.agent and verify complete Phase 8 integration.

1. Update `src/agent/__init__.py`:
   - Add imports from routing:
     ```python
     from src.agent.routing import (
         ModelRouter,
         ModelRecommendation,
         TaskCategory,
         RoutingRules,
         RoutingRule,
     )
     ```
   - Add to __all__ list (if present) or ensure all are exported

2. Verify all Phase 8 components are accessible from src.agent:
   - Trace: TraceStore, TraceEntry, TraceSession
   - Cancel: CancelMode, ResultMode, CancellationRequest, CancellationResult
   - UI: AgentStatusIndicator, CancelDialog
   - Routing: ModelRouter, ModelRecommendation, TaskCategory, RoutingRules
  </action>
  <verify>
```bash
cd "C:\Users\karlt\OneDrive\Desktop\Claude\skynette-repo"

# Verify all exports
python -c "
from src.agent import (
    # Phase 7 exports (should still work)
    AgentSession,
    AgentState,
    AgentPlan,
    PlanStep,
    AgentEvent,
    TokenBudget,
    AgentEventEmitter,
    AgentExecutor,
    AgentPlanner,

    # Phase 8: Observability
    TraceStore,
    TraceEntry,
    TraceSession,

    # Phase 8: Cancellation
    CancelMode,
    ResultMode,
    CancellationRequest,
    CancellationResult,

    # Phase 8: UI
    AgentStatusIndicator,
    CancelDialog,

    # Phase 8: Routing
    ModelRouter,
    ModelRecommendation,
    TaskCategory,
    RoutingRules,
    RoutingRule,
)
print('All Phase 8 components exported successfully')
"

# Run full test suite for agent
python -m pytest tests/unit/test_agent_core.py -v 2>&1 | tail -20
```
  </verify>
  <done>All Phase 8 components exported from src.agent package, full test suite passes.</done>
</task>

</tasks>

<verification>
After all tasks complete:

```bash
cd "C:\Users\karlt\OneDrive\Desktop\Claude\skynette-repo"

# Comprehensive Phase 8 verification
python -c "
print('=== Phase 8 Complete Integration Test ===')

# 1. Observability
from src.agent import TraceStore, TraceEntry
import tempfile, os
db_path = os.path.join(tempfile.gettempdir(), 'phase8_test.db')
store = TraceStore(db_path=db_path)
session = store.start_session('Phase 8 verification')
entry = TraceEntry(session_id=session.id, type='verification', data={'test': True})
store.save_trace(entry)
traces = store.get_traces(session_id=session.id)
assert len(traces) == 1, 'Trace storage working'
print('[OK] Observability: Traces stored and queried')

# 2. Cancellation
from src.agent import CancelMode, ResultMode, CancellationRequest, AgentExecutor, AgentSession
session = AgentSession(task='Cancel test')
executor = AgentExecutor(session)
req = CancellationRequest(cancel_mode=CancelMode.AFTER_CURRENT, result_mode=ResultMode.KEEP)
executor.request_cancel(req)
assert executor._cancel_request is not None, 'Cancellation request stored'
print('[OK] Cancellation: Request stored with mode options')

# 3. Status UI
from src.agent import AgentStatusIndicator
indicator = AgentStatusIndicator()
assert indicator.STATUS_CONFIG['planning']['animate'] == True
print('[OK] Status: Indicator with animation support')

# 4. Model Routing
from src.agent import ModelRouter, TaskCategory
router = ModelRouter()
rec = router.recommend('Write code to sort a list')
assert rec.model is not None
assert rec.estimated_cost_usd >= 0
assert len(rec.alternatives) > 0
print('[OK] Routing: Recommendations with cost and alternatives')

# Cleanup
os.remove(db_path)
print('\\n=== All Phase 8 Components Verified ===')
"

# Run unit tests
python -m pytest tests/unit/test_agent_core.py -v --tb=short
```
</verification>

<success_criteria>
- [ ] TaskCategory enum defines all task types
- [ ] ModelRouter.classify_task() categorizes tasks via keywords
- [ ] ModelRouter.recommend() returns model with cost estimate
- [ ] Recommendations include alternatives with cost/capability tradeoffs
- [ ] RoutingRules allows custom rules per category
- [ ] Custom rules override default routing
- [ ] Unit tests exist for TokenBudget (4+ tests)
- [ ] Unit tests exist for AgentEventEmitter (4+ tests)
- [ ] Unit tests exist for AgentExecutor (3+ tests)
- [ ] Unit tests exist for ModelRouter (5+ tests)
- [ ] All tests pass
- [ ] All Phase 8 components exported from src.agent
</success_criteria>

<output>
After completion, create `.planning/phases/08-planning-and-execution/08-03-SUMMARY.md`
</output>
