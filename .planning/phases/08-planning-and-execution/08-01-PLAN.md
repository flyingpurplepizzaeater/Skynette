---
phase: 08-planning-and-execution
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/agent/models/event.py
  - src/agent/observability/__init__.py
  - src/agent/observability/trace_models.py
  - src/agent/observability/trace_store.py
  - src/agent/observability/trace_viewer.py
  - src/agent/__init__.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Every agent event includes trace context (trace_id, parent, duration)"
    - "Traces persist to SQLite and survive app restart"
    - "Traces can be queried by session, type, time range, and text search"
    - "Old traces are automatically cleaned up based on retention setting"
    - "User can view traces for debugging (what happened, in what order)"
  artifacts:
    - path: "src/agent/observability/trace_models.py"
      provides: "TraceEntry and TraceSession pydantic models"
      exports: ["TraceEntry", "TraceSession"]
    - path: "src/agent/observability/trace_store.py"
      provides: "SQLite trace persistence with query and cleanup"
      exports: ["TraceStore"]
    - path: "src/agent/observability/trace_viewer.py"
      provides: "Trace viewing utilities for debugging"
      exports: ["TraceViewer"]
    - path: "src/agent/models/event.py"
      provides: "Enhanced AgentEvent with tracing fields"
      contains: "trace_id"
  key_links:
    - from: "src/agent/observability/trace_store.py"
      to: "sqlite3"
      via: "database connection"
      pattern: "sqlite3\\.connect"
    - from: "src/agent/observability/trace_store.py"
      to: "src/agent/observability/trace_models.py"
      via: "model import"
      pattern: "from.*trace_models import"
    - from: "src/agent/observability/trace_viewer.py"
      to: "src/agent/observability/trace_store.py"
      via: "store query"
      pattern: "TraceStore|get_traces"
---

<objective>
Create the observability foundation for agent execution tracing.

Purpose: Enable debugging and audit of agent behavior by persisting all execution events with full context (timestamps, durations, token counts, raw I/O). This satisfies AGNT-03 (observability/tracing) and Success Criteria #3 (traces are viewable for debugging).

Output: Enhanced AgentEvent model with trace fields, TraceStore for SQLite persistence, trace query/cleanup capabilities, and TraceViewer for debugging.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-planning-and-execution/08-RESEARCH.md

# Phase 7 deliverables this builds on
@src/agent/models/event.py
@src/agent/events/emitter.py
@src/data/storage.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Trace Models</name>
  <files>
    src/agent/observability/__init__.py
    src/agent/observability/trace_models.py
  </files>
  <action>
Create the observability subpackage with trace data models.

1. Create `src/agent/observability/__init__.py`:
   - Export TraceEntry, TraceSession from trace_models
   - Export TraceStore from trace_store (anticipating Task 2)
   - Export TraceViewer from trace_viewer (anticipating Task 3)

2. Create `src/agent/observability/trace_models.py`:
   - TraceEntry (pydantic BaseModel):
     - id: str (UUID, auto-generated)
     - session_id: str
     - type: str (event type)
     - timestamp: datetime (UTC)
     - duration_ms: Optional[float]
     - parent_trace_id: Optional[str] (for nested operations)
     - data: dict (event-specific data, JSON-serializable)
     - input_tokens: Optional[int]
     - output_tokens: Optional[int]
     - model_used: Optional[str]
     - provider_used: Optional[str]
     - cost_usd: Optional[float]
     - raw_input: Optional[str] (truncated to 4KB)
     - raw_output: Optional[str] (truncated to 4KB)

   - TraceSession (pydantic BaseModel):
     - id: str
     - task: str
     - started_at: datetime
     - completed_at: Optional[datetime]
     - status: str (running, completed, failed, cancelled)
     - total_events: int
     - total_tokens: int
     - total_cost_usd: float

   - Add helper method `TraceEntry.from_agent_event(event: AgentEvent)` for conversion
   - Add constant MAX_RAW_LENGTH = 4096 for truncation
  </action>
  <verify>
```bash
cd "C:\Users\karlt\OneDrive\Desktop\Claude\skynette-repo"
python -c "from src.agent.observability.trace_models import TraceEntry, TraceSession; print('Models importable')"
python -c "from src.agent.observability.trace_models import TraceEntry; e = TraceEntry(session_id='test', type='test_event'); print(f'TraceEntry: {e.id}')"
```
  </verify>
  <done>TraceEntry and TraceSession models exist, are importable, and can be instantiated with required fields.</done>
</task>

<task type="auto">
  <name>Task 2: Create TraceStore with SQLite Persistence</name>
  <files>
    src/agent/observability/trace_store.py
  </files>
  <action>
Create SQLite-backed trace storage following patterns from src/data/storage.py.

1. Create `src/agent/observability/trace_store.py`:
   - TraceStore class:
     - __init__(self, db_path: str = None): Default to ~/.skynette/agent_traces.db
     - _init_db(): Create tables if not exist

   - Tables:
     - agent_trace_sessions: id, task, started_at, completed_at, status
     - agent_traces: id, session_id, type, timestamp, duration_ms, parent_trace_id, data (JSON), input_tokens, output_tokens, model_used, provider_used, cost_usd, raw_input, raw_output, created_at

   - Indexes:
     - idx_traces_session ON agent_traces(session_id)
     - idx_traces_timestamp ON agent_traces(timestamp)
     - idx_traces_type ON agent_traces(type)

   - Methods:
     - start_session(task: str) -> TraceSession: Insert new session, return model
     - end_session(session_id: str, status: str): Update completed_at and status
     - save_trace(entry: TraceEntry): Insert trace entry
     - get_traces(session_id=None, event_type=None, start_time=None, end_time=None, search_text=None, limit=100) -> list[TraceEntry]: Query with filters
     - get_session(session_id: str) -> Optional[TraceSession]: Get session by ID
     - get_sessions(limit=50, offset=0) -> list[TraceSession]: List recent sessions
     - cleanup_old_traces(retention_days: int = 30) -> int: Delete old traces, return count deleted
     - get_retention_days() -> int: Get current retention setting (default 30)
     - set_retention_days(days: int): Update retention setting

   - Use trace_settings table for retention config (key-value)
   - Truncate raw_input/raw_output to MAX_RAW_LENGTH on save
   - Use WAL mode for concurrent access: PRAGMA journal_mode=WAL
  </action>
  <verify>
```bash
cd "C:\Users\karlt\OneDrive\Desktop\Claude\skynette-repo"
python -c "
from src.agent.observability.trace_store import TraceStore
from src.agent.observability.trace_models import TraceEntry
import tempfile, os

# Test with temp database
db_path = os.path.join(tempfile.gettempdir(), 'test_traces.db')
store = TraceStore(db_path=db_path)

# Test session
session = store.start_session('Test task')
print(f'Session created: {session.id}')

# Test trace
entry = TraceEntry(session_id=session.id, type='test_event', data={'test': True})
store.save_trace(entry)

# Test query
traces = store.get_traces(session_id=session.id)
print(f'Traces found: {len(traces)}')

# Clean up
os.remove(db_path)
print('TraceStore working')
"
```
  </verify>
  <done>TraceStore creates database, saves/queries traces, manages sessions, and supports cleanup with configurable retention.</done>
</task>

<task type="auto">
  <name>Task 3: Create TraceViewer for Debugging</name>
  <files>
    src/agent/observability/trace_viewer.py
  </files>
  <action>
Create trace viewing utilities that enable debugging per Success Criteria #3.

1. Create `src/agent/observability/trace_viewer.py`:
   - TraceViewer class:
     - __init__(self, store: TraceStore = None): Use default store if not provided

   - Methods for viewing traces:
     - list_sessions(limit: int = 20) -> list[dict]: Recent sessions with summary (id, task, status, event count, duration)
     - get_session_timeline(session_id: str) -> list[dict]: Chronological event list with timestamps, types, durations
     - get_session_summary(session_id: str) -> dict: High-level stats (total time, tokens, cost, step count, errors)
     - search_traces(query: str, session_id: str = None) -> list[dict]: Full-text search across trace data
     - get_trace_detail(trace_id: str) -> dict: Full trace entry with all fields including raw I/O
     - format_timeline(traces: list[TraceEntry]) -> str: Human-readable timeline format
     - format_tree(traces: list[TraceEntry]) -> str: Indented tree showing parent-child relationships

   - Filtering helpers:
     - filter_by_type(traces: list[TraceEntry], event_types: list[str]) -> list[TraceEntry]
     - filter_errors(traces: list[TraceEntry]) -> list[TraceEntry]: Only error events
     - filter_by_duration(traces: list[TraceEntry], min_ms: float) -> list[TraceEntry]: Slow operations

   - Output is dict/list suitable for UI display or CLI output
   - format_timeline() and format_tree() return strings for CLI/debug use
  </action>
  <verify>
```bash
cd "C:\Users\karlt\OneDrive\Desktop\Claude\skynette-repo"
python -c "
from src.agent.observability.trace_viewer import TraceViewer
from src.agent.observability.trace_store import TraceStore
from src.agent.observability.trace_models import TraceEntry
import tempfile, os

# Create store with test data
db_path = os.path.join(tempfile.gettempdir(), 'viewer_test.db')
store = TraceStore(db_path=db_path)
session = store.start_session('Viewer test task')

# Add some traces
for i, etype in enumerate(['step_started', 'tool_called', 'step_completed']):
    entry = TraceEntry(session_id=session.id, type=etype, data={'step': i}, duration_ms=100*i)
    store.save_trace(entry)

# Test viewer
viewer = TraceViewer(store)

# List sessions
sessions = viewer.list_sessions()
print(f'Sessions found: {len(sessions)}')
assert len(sessions) >= 1

# Get timeline
timeline = viewer.get_session_timeline(session.id)
print(f'Timeline entries: {len(timeline)}')
assert len(timeline) == 3

# Get summary
summary = viewer.get_session_summary(session.id)
print(f'Summary: {summary[\"total_events\"]} events')

# Format timeline
formatted = viewer.format_timeline(store.get_traces(session_id=session.id))
print(f'Formatted timeline length: {len(formatted)} chars')
assert len(formatted) > 0

# Clean up
os.remove(db_path)
print('TraceViewer working')
"
```
  </verify>
  <done>TraceViewer provides session listing, timeline view, summary stats, search, and formatted output for debugging.</done>
</task>

<task type="auto">
  <name>Task 4: Enhance AgentEvent with Trace Fields</name>
  <files>
    src/agent/models/event.py
    src/agent/__init__.py
  </files>
  <action>
Extend AgentEvent model with trace context fields while maintaining backward compatibility.

1. Update `src/agent/models/event.py`:
   - Add imports: from uuid import uuid4

   - Add new event types to AgentEventType Literal:
     - "model_selected" (for model routing)
     - "model_switched" (for mid-task model changes)
     - "trace_started" (session begin)
     - "trace_ended" (session end)

   - Add trace fields to AgentEvent:
     - trace_id: str = Field(default_factory=lambda: str(uuid4()))
     - parent_trace_id: Optional[str] = None
     - duration_ms: Optional[float] = None
     - input_tokens: Optional[int] = None
     - output_tokens: Optional[int] = None
     - model_used: Optional[str] = None
     - provider_used: Optional[str] = None
     - estimated_cost_usd: Optional[float] = None
     - raw_input: Optional[str] = None
     - raw_output: Optional[str] = None

   - Add factory methods:
     - AgentEvent.model_selected(model: str, provider: str, reason: str, session_id: str)
     - AgentEvent.model_switched(from_model: str, to_model: str, session_id: str)

   - Ensure existing factory methods still work (backward compatible)

2. Update `src/agent/__init__.py`:
   - Add exports: from src.agent.observability import TraceStore, TraceEntry, TraceSession, TraceViewer
  </action>
  <verify>
```bash
cd "C:\Users\karlt\OneDrive\Desktop\Claude\skynette-repo"
python -c "
from src.agent.models.event import AgentEvent

# Test new fields exist
e = AgentEvent(type='step_completed', data={})
print(f'Has trace_id: {hasattr(e, \"trace_id\") and e.trace_id is not None}')
print(f'Has duration_ms field: {hasattr(e, \"duration_ms\")}')

# Test new event types
e2 = AgentEvent.model_selected('claude-3-sonnet', 'anthropic', 'Best for code', 'sess-123')
print(f'model_selected event type: {e2.type}')

# Test backward compatibility
e3 = AgentEvent.state_change('planning', 'sess-456')
print(f'Existing factory still works: {e3.type == \"state_change\"}')
"

# Verify exports
python -c "from src.agent import TraceStore, TraceEntry, TraceSession, TraceViewer; print('Exports working')"
```
  </verify>
  <done>AgentEvent has trace context fields, new event types for model selection, and exports are available from src.agent package.</done>
</task>

</tasks>

<verification>
After all tasks complete:

```bash
cd "C:\Users\karlt\OneDrive\Desktop\Claude\skynette-repo"

# Full integration test
python -c "
from src.agent.models.event import AgentEvent
from src.agent.observability import TraceStore, TraceEntry, TraceSession, TraceViewer
import tempfile, os

# Create event with trace context
event = AgentEvent(
    type='tool_called',
    data={'tool': 'mock_tool', 'params': {'query': 'test'}},
    session_id='test-session',
    input_tokens=100,
    output_tokens=50,
    model_used='claude-3-sonnet',
    duration_ms=1234.5
)

# Convert to trace entry
entry = TraceEntry.from_agent_event(event)

# Store in database
db_path = os.path.join(tempfile.gettempdir(), 'integration_test.db')
store = TraceStore(db_path=db_path)
session = store.start_session('Integration test task')
entry.session_id = session.id
store.save_trace(entry)

# Query back
traces = store.get_traces(session_id=session.id, event_type='tool_called')
assert len(traces) == 1, 'Expected 1 trace'
assert traces[0].input_tokens == 100, 'Token count preserved'

# Test TraceViewer (Success Criteria #3: traces are viewable)
viewer = TraceViewer(store)
timeline = viewer.get_session_timeline(session.id)
assert len(timeline) == 1, 'Timeline has trace'
summary = viewer.get_session_summary(session.id)
assert summary['total_events'] == 1, 'Summary counts trace'
formatted = viewer.format_timeline(traces)
assert 'tool_called' in formatted, 'Timeline shows event type'

# Cleanup test
store.set_retention_days(0)  # Expire everything
deleted = store.cleanup_old_traces(retention_days=0)

os.remove(db_path)
print('Integration test passed')
"
```
</verification>

<success_criteria>
- [ ] TraceEntry and TraceSession models defined with all required fields
- [ ] TraceStore creates SQLite database with proper schema and indexes
- [ ] Sessions can be started, ended, and queried
- [ ] Trace entries can be saved and queried with filters (session, type, time, text search)
- [ ] Retention cleanup deletes traces older than configured days
- [ ] TraceViewer can list sessions, show timelines, and format output
- [ ] TraceViewer supports search and filtering for debugging
- [ ] AgentEvent has trace_id, duration_ms, token counts, and cost fields
- [ ] New event types (model_selected, model_switched) are available
- [ ] All components exportable from src.agent package
</success_criteria>

<output>
After completion, create `.planning/phases/08-planning-and-execution/08-01-SUMMARY.md`
</output>
